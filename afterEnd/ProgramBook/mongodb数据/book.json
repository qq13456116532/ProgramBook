[{
  "_id": "741d488c-47ad-4b55-9b82-26fbe52633d3",
  "headerImage": "https://wk-gulimall.oss-cn-beijing.aliyuncs.com/ProgramBook/d5ef6b4b-c667-47b8-8986-cff1776e9862.jpg",
  "updateTime": {
    "$date": "2023-01-23T16:59:24.367Z"
  },
  "author": "孙秀梅, ",
  "des": "前　言\n面试是获得一份工作的开始，也是求职者跨进职场的第一步。如何成功地打开求职面试的大门，是每一个求职者必须要面对的问题。而我们写作这本书的目的，就是希望帮助广大求职者顺利通过面试，从而开启自己的职场生涯。\n本书内容\n本书以C/C++面试求职为核心，全面介绍了在C/C++面试中重点考查的各个考点，并从面试求职、职业规划、面试渠道、面试真题、面试过程及职场生存等各个方面讲解了一个面试者应该掌握的所有知识。全书共分6篇23章，主要内容如下。\n第1篇：面试求职第一步。\n第2篇：面试成功有道。\n第3篇：C/C++程序设计篇。\n第4篇：数据结构与常用算法。\n第5篇：综合测试篇。\n第6篇：职场生存篇。\n本书特点\n详细讲解应聘者从职业规划、求职渠道、简历、面试过程等各个环节需要注意的问题，并且讲解应聘者在进入公司后应该如何做一个好员工。\n通过面试真题讲解专业知识，让读者真正知道所学知识能用在实际工作中的哪些方面，并且让读者熟悉企业常见的面试题，为应聘做好充分的准备。\n每个面试真题通过出现频率、考点解析和参考答案3个方面进行讲解。其中，出现频率用星号的数量体现；考点解析对该面试题涉及的技术进行详细讲解；参考答案给出最后的解答。\n光盘中附带“实战能力测试系统”，包含模拟面试系统、技术能力笔试模拟系统与本书相关的实战模拟考试，通过这两个系统，读者可以轻松训练自己的面试和笔试能力。另外，该系统还包含技能学习系统、技能测试系统、实战热身系统、项目实践系统等，使读者可以轻松掌握C/C++语言的实战开发能力。\n读者对象\n致读者\n本书由明日科技C/C++程序开发团队策划并组织编写，主要编写人员有孙秀梅、高春艳等。在编写本书的过程中，我们以科学、严谨的态度，力求精益求精，但错误、疏漏之处在所难免，敬请广大读者批评指正。\n有关于本书的问题，读者可以通过如下方式与我们沟通，我们将在3～5个工作日内给您提供满意的答复。\n最后，感谢您选择本书，希望本书能为您打开求职面试的大门。\n编　者\n",
  "factionName": "C/C++求职宝典",
  "newest": 10,
  "comments": [],
  "source": [],
  "index": "1"
},{
  "_id": "943579b9-afe1-41fc-8f6b-f49ecc7773dc",
  "headerImage": "https://wk-gulimall.oss-cn-beijing.aliyuncs.com/ProgramBook/10c48144-2446-4909-aa7c-9310c78c489d.jpg",
  "updateTime": {
    "$date": "2023-01-23T16:59:25.229Z"
  },
  "author": "（美）凯西恩",
  "des": "前言\n这本书反映了Web技术的革命。之前，人们普遍认为Web无须编程，只要把脚本硬塞入网页之中就行了。现在，HTML和JavaScript在实现良好用户体验的过程中产生了重要作用。通过阅读本书，你将会掌握Web发展进程中最前沿的技术。\n本书覆盖的内容如下：\n第1章　Web应用平台\n介绍在新的HTML 5平台编程的原因，以及新平台为JavaScript编程人员提供的便利。\n第2章　JavaScript的力量\n介绍JavaScript中很强大但是你可能并不知道的功能，以及为什么你需要使用这些功能去探索本书涵盖的HTML 5的新特性以及相关库。\n第3章　测试JavaScript应用\n展示由JavaScript和浏览器提供的特定环境中测试程序的方法。\n第4章　本地存储\n描述使用localStorage和sessionStorage对象缓存在浏览器中的简单数据。\n第5章　IndexedDB\n展示支持本地存储的更强大的NoSQL数据库。\n第6章　文件\n描述从用户系统中读取和上传文件的方法。\n第7章　离线处理\n描述让用户在设备不能联网的情况下使用你开发的应用程序所要做的操作。\n第8章　把工作分割成Web Worker\n展示HTML 5和JavaScript的多线程能力。\n第9章　Web Socket\n演示如何通过使用Web Socket提高浏览器端和服务器端的数据传输效率。\n第10章　新标记\n总结HTML 5引入的对Web开发人员最为有用的新标记。\n附录A　需要了解的JavaScript工具\n描述本书中用到的以及其他可以让编程更快更准确的工具。\n",
  "factionName": "HTML 5应用开发实践指南 ",
  "newest": 10,
  "comments": [],
  "source": [],
  "index": "4"
},{
  "_id": "189b0646-279a-4340-8768-7ff7713b61a3",
  "headerImage": "https://wk-gulimall.oss-cn-beijing.aliyuncs.com/ProgramBook/5fb6b368-c3c5-4403-b7fe-9f109122f41a.jpg",
  "updateTime": {
    "$date": "2023-01-23T16:59:26.211Z"
  },
  "author": "Meloni",
  "des": "无",
  "factionName": "HTML、CSS和JavaScript入门经典",
  "newest": 10,
  "comments": [],
  "source": [],
  "index": "4"
},{
  "_id": "99b83ee6-cd0f-49d4-b748-9878fc437ff6",
  "headerImage": "https://wk-gulimall.oss-cn-beijing.aliyuncs.com/ProgramBook/dc1a3b36-fb27-4e95-acd9-26eba901b3bf.jpg",
  "updateTime": {
    "$date": "2023-01-23T16:59:26.960Z"
  },
  "author": "wizard",
  "des": "无",
  "factionName": "JavaScript 模式",
  "newest": 10,
  "comments": [],
  "source": [],
  "index": "4"
},{
  "_id": "5110dd34-6391-4b4f-bb4f-985fe20ff59c",
  "headerImage": "https://wk-gulimall.oss-cn-beijing.aliyuncs.com/ProgramBook/67bb1601-eaab-4ed3-8913-e06bfb94c054.jpg",
  "updateTime": {
    "$date": "2023-01-23T16:59:27.500Z"
  },
  "author": "wizard",
  "des": "无",
  "factionName": "JavaScript 秘密花园",
  "newest": 10,
  "comments": [],
  "source": [],
  "index": "4"
},{
  "_id": "0c036ab7-e746-4b22-8f03-aa3878b1cd47",
  "headerImage": "https://wk-gulimall.oss-cn-beijing.aliyuncs.com/ProgramBook/87c41bc9-9081-4d50-b109-a2bc0d8e2a3e.jpg",
  "updateTime": {
    "$date": "2023-01-23T16:59:28.406Z"
  },
  "author": "wizard",
  "des": "零、前言\n零、前言\nIntroduction\n飞龙\nCC BY-NC-SA 4.0\n谷歌翻译\n《JavaScript 编程精解（第 2 版）》\nWe think we are creating the system for our own purposes. We believe we are making it in our own image... But the computer is not really like us. It is a projection of a very slim part of ourselves: that portion devoted to logic, order, rule, and clarity.\nEllen Ullman，《Close to the Machine: Technophilia and its Discontents》\n这是一本关于指导电脑的书。时至今日，计算机就像螺丝刀一样随处可见，但相比于螺丝刀而言，计算机更复杂一些，并且，让他们做你想让他们做的事情，并不总是那么容易。\n如果你让计算机执行的任务是常见的，易于理解的任务，例如向你显示你的电子邮件，或像计算器一样工作，则可以打开相应的应用并开始工作。 但对于独特的或开放式的任务，应用可能不存在。\n这就是编程可能出现的地方。编程是构建一个程序的行为 - 它是一组精确的指令，告诉计算机做什么。 由于计算机是愚蠢的，迂腐的野兽，编程从根本上是乏味和令人沮丧的。\n幸运的是，如果你可以克服这个事实，并且甚至可以享受愚蠢机器可以处理的严谨思维，那么编程可以是非常有益的。 它可以让你在几秒钟内完成手动操作。 这是一种方法，让你的电脑工具去做它以前做不到的事情。 它也提供了抽象思维的优秀练习。\n大多数编程都是用编程语言完成的。 编程语言是一种人工构建的语言，用于指导计算机。 有趣的是，我们发现与电脑沟通的最有效的方式，与我们彼此沟通的方式相差太大。 与人类语言一样，计算机语言可以以新的方式组合词语和词组，从而可以表达新的概念。\n在某种程度上，基于语言的界面，例如 80 年代和 90 年代的 BASIC 和 DOS 提示符，是与计算机交互的主要方法。 这些已经在很大程度上被视觉界面取代，这些视觉界面更容易学习，但提供更少的自由。 计算机语言仍然存在，如果你知道在哪里看到。 每种现代 Web 浏览器都内置了一种这样的语言，即 JavaScript，因此几乎可以在所有设备上使用。\n本书将试图让你足够了解这门语言，从而完成有用和有趣的东西。\n关于程序设计\n除了讲解 JavaScript 之外，本书也会介绍一些程序设计的基本原则。程序设计还是比较复杂的。编程的基本规则简单清晰，但在这些基本规则之上构建的程序却容易变得复杂，导致程序产生了自己的规则和复杂性。即便程序是按照你自己的思路去构建的，你也有可能迷失在代码之间。\n在阅读本书时，你有可能会觉得书中的概念难以理解。如果你刚刚开始学习编程，那么你估计还有不少东西需要掌握呢。如果你想将所学知识融会贯通，那么就需要去多参考和学习一些资料。\n是否付出必要的努力完全取决于你自己。当你阅读本书的时候发现任何难点，千万不要轻易就对自己的能力下结论。只要能坚持下去，你就是好样的。稍做休息，复习一下所学的知识点，始终确保自己阅读并理解了示例程序和相关的练习。学习是一项艰巨的任务，但你掌握的所有知识都属于你自己，而且今后的学习道路会愈加轻松。\n当行动无利可图时，就收集信息；当信息无利可图时，就休息。\nUrsula K. Le Guin，《The Left Hand of Darkness》\n一个程序有很多含义：它是开发人员编写的一段文本、计算机执行的一段指令集合、计算机内存当中的数据以及控制内存中数据的操作集合。我们通常很难将程序与我们日常生活中熟悉的事物进行对比。有一种表面上比较恰当的比喻，即将程序视作包含许多组件的机器，为了让机器正常工作，这些组件通过内部通信来实现整个机器的正常运转。\n计算机是一台物理机器，充当这些非物质机器的载体。计算机本身并不能实现多么复杂的功能，但计算机之所以有用是因为它们的运算速度非常快。而程序的作用就是将这些看似简单的动作组合起来，然后实现复杂的功能。\n程序是思想的结晶。编写程序不需要什么物质投入，它很轻量级，通过我们的双手创造。\n但如果不稍加注意，程序的体积和复杂度就会失去控制，甚至代码的编写者也会感到迷惑。在可控的范围内编写程序是编程过程中首要解决的问题。当程序运行时，一切都是那么美好。编程的精粹就在于如何更好地控制复杂度。质量高的程序的复杂度都不会太高。\n很多开发人员认为，控制程序复杂度的最好方法就是避免使用不熟悉的技术。他们制定了严格的规则（“最佳实践”），并小心翼翼地呆在他们安全区内。\n这不仅无聊，而且也是无效的。新问题往往需要新的解决方案。编程领域还很年轻，仍然在迅速发展，并且多样到足以为各种不同的方法留出空间。在程序设计中有许多可怕的错误，你应该继续犯错，以便你能理解它们。好的程序看起来是什么样的感觉，是在实践中发展的，而不是从一系列规则中学到的。\n为什么编程语言重要\n在计算技术发展伊始，并没有编程语言这个概念。程序看起来就像这样：\n00110001 00000000 00000000\n00110001 00000001 00000001\n00110011 00000001 00000010\n01010001 00001011 00000010\n00100010 00000010 00001000\n01000011 00000001 00000000\n01000001 00000001 00000001\n00010000 00000010 00000000\n01100010 00000000 00000000\n1+2+...+10=55\n当然了，手动输入这些晦涩难懂的位序列（1 和 0）来编写程序的确能让程序员感到很有成就感，而且能给你的职业带来极大的满足感。\n在上面的程序中，每行都包含一条指令。我们可以用中文来描述这些指令：\n将数字 0 存储在内存地址中的位置 0。\n将数字 1 存储在内存地址的位置 1。\n将内存地址的位置 1 中的值存储在内存地址的位置 2。\n将内存地址的位置 2 中的值减去数字 11。\n如果内存地址的位置 2 中的值是 0，则跳转到指令 9。\n将内存地址的位置 1 中的值加到内存地址的位置 0。\n将内存地址的位置 1 中的值加上数字 1。\n跳转到指令 3。\n输出内存地址的位置 0 中的值。\n虽说这已经比一大堆位序列要好读了许多，但仍然不清晰。使用名称而不是数字用于指令和存储位置有所帮助：\nSet “total” to 0.\n Set “count” to 1.\n[loop]\n Set “compare” to “count”.\n Subtract 11 from “compare”.\n If “compare” is zero, continue at [end].\n Add “count” to “total”.\n Add 1 to “count”.\n Continue at [loop].\n[end]\n Output “total”.\ntotal\ncount\ncompare\ncount\ncompare\ncount–11\ncount\ncount\ncount\n11\n下面使用 JavaScript 重新编写了上面的程序：\nlet\n0\n1\nwhile\n10\n1\nconsole\n// → 55\nwhile\nwhile\ncount<=10\ncount\nwhile\nconsole.log\nrange\nsum\nrange\nsum\nconsole\n1\n10\n// → 55\nsum\nrange\nwhile\nconsole.log\nsum\nrange\n什么是 JavaScript\nJavaScript 诞生于 1995 年。起初，Netscape Navigator 浏览器将其运用在网页上添加程序。自此以后，各类主流图形网页浏览器均采用了 JavaScript。JavaScript 使得现代网页应用程序成为可能 —— 使用 JavaScript 可以直接与用户交互，从而避免每一个动作都需要重新载入页面。但有许多传统网站也会使用 JavaScript 来提供实时交互以及更加智能的表单功能。\nJavaScript 其实和名为Java的程序设计语言没有任何关系。起了这么一个相似的名字完全是市场考虑使然，这并非是一个明智的决定。当 JavaScript 出现时，Java 语言已在市场上得到大力推广且拥有了极高人气，因此某些人觉得依附于 Java 的成功是个不错的主意。而我们现在已经无法摆脱这个名字了。\n在 JavaScript 被广泛采用之后，ECMA 国际制订了一份标准文档来描述 JavaScript 的工作行为，以便所有声称支持 JavaScript 的软件都使用同一种语言。标准化完成后，该标准被称为 ECMAScript 标准。实际上，术语 ECMAScript 和 JavaScript 可以交换使用。它们不过是同一种语言的两个名字而已。\n许多人会说 JavaScript 语言的坏话。这其中有很多这样的言论都是正确的。当被要求第一次使用 JavaScript 编写代码时，我当时就觉得这门语言难以驾驭。JavaScript 接受我输入的任何代码，但是又使用和我的想法完全不同的方式来解释代码。由于我没有任何线索知道我之前做了什么，因此我需要做出更多工作，但这也就存在一个实际问题：我们可以自由使用 JavaScript，而这种自由却几乎没有限度。这种设计其实是希望初学者更容易使用 JavaScript 编写程序。但实际上，系统不会指出我们错在何处，因此从程序中找出问题变得更加棘手。\n但这种自由性也有其优势，许多技术在更为严格的语言中不可能实现，而在 JavaScript 中则留下了实现的余地，正如你看到的那样（比如第十章），有些优势可以弥补 JavaScript 的一些缺点。在正确地学习 JavaScript 并使用它工作了一段时间后，我真正喜欢上了 JavaScript。\nJavaScript 版本众多。大约在 2000~2010 年间，这正是 JavaScript 飞速发展的时期，浏览器支持最多的是 ECMAScript 3。在此期间，ECMA 着手制定 ECMAScript 4，这是一个雄心勃勃的版本，ECMA 计划在这个版本中加入许多彻底的改进与扩展。但由于 ECMAScript 3 被广泛使用，这种过于激进的修改必然会遭遇重重阻碍，最后 ECMA 不得不于 2008 年放弃了版本 4 的制定。这就产生了不那么雄心勃勃的版本 5，这只是一些没有争议的改进，出现在 2009 年。 然后版本 6 在 2015 年诞生，这是一个重大的更新，其中包括计划用于版本 4 的一些想法。从那以后，每年都会有新的更新。\n语言不断发展的事实意味着，浏览器必须不断跟上，如果你使用的是较老的浏览器，它可能不支持每个特性。 语言设计师会注意，不要做任何可能破坏现有程序的改变，所以新的浏览器仍然可以运行旧的程序。 在本书中，我使用的是 2017 版的 JavaScript。\nWeb 浏览器并不是唯一一个可以运行 JavaScript 的平台。有些数据库，比如 MongoDB 和 CouchDB，也使用 JavaScript 作为脚本语言和查询语言。一些桌面和服务器开发的平台，特别是 Node.js 项目（第二十章介绍），为浏览器以外的 JavaScript 编程提供了一个环境。\n代码及相关工作\n代码是程序的文本内容。本书多数章节都介绍了大量代码。我相信阅读代码和编写代码是学习编程不可或缺的部分。尝试不要仅仅看一眼示例，而应该认真阅读并理解每个示例。刚开始使用这种方式可能会速度较慢并为代码所困惑，但我坚信你很快就可以熟能生巧。对待习题的方法也应该一样。除非你确实已经编写代码解决了问题，否则不要假设你已经理解了问题。\n建议读者应尝试在实际的 JavaScript 解释器中执行习题代码。这样一来，你就可以马上获知代码工作情况的反馈，而且我希望读者去做更多的试验，而不仅仅局限于习题的要求。\nhttp://eloquentjavascript.net/\nhttp://eloquentjavascript.net/code/\n如果想要在本书提供的沙箱以外执行本书代码，需要稍加注意。许多的示例是独立的，而且可以在任何 JavaScript 环境下运行。但后续章节的代码大多数都是为特定环境（浏览器或者 Node.js）编写的，而且只能在这些特定环境下执行代码。此外，许多章节定义了更大的程序，这些章节中出现的代码片段会互相依赖或是依赖于一些外部文件。本书网站的沙箱提供了 zip 压缩文件的链接，该文件包含了所有运行特定章节代码所需的脚本和数据文件。\n本书概览\n本书包括三个部分。前十二章讨论 JavaScript 语言本身的一些特性。接下来的 8 章讨论网页浏览器和 JavaScript 在网页编程中的实践。最后两章专门讲解另一个使用 JavaScript 编程的环境 —— Node.js。\n纵观本书，共有 5 个项目实战章，用于讲解规模较大的示例程序，你可以通过这些章来仔细品味真实的编程过程。根据项目出现次序，我们会陆续构建递送机器人（7）、程序设计语言（12）、平台游戏（16）、像素绘图程序（19）和一个动态网站（21）。\nwhile\n介绍完第一个项目实战（7）之后，将会继续讲解语言部分，例如第八章错误处理和 bug 修复、第九章正则表达式（处理文本数据的重要工具）、第十章模块化（解决复杂度的问题）以及第十一章异步编程（处理需要时间的事件）。第二个项目实战章节（12）则是对本书第一部分的总结。\n第二部分（第十三章到第十九章），阐述了浏览器 JavaScript 中的一些工具。你将会学到在屏幕上显示某些元素的方法（第十四章与第十七章），响应用户输入的方法（第十五章）和通过网络通信的方法（第十八章）。这部分又有两个项目实战章节。\n此后，第二十章阐述 Node.js，而第二十一章使用该工具构建一个简单的网页系统。\n本书版式约定\n本书中存在大量代码，程序（包括你迄今为止看到的一些示例）代码的字体如下所示：\nfunction\nfactorial\nn\nif\n0\nreturn\n1\nelse\nreturn\n1\n为了展示程序产生的输出，本书常在代码后编写代码期望输出，输出结果前会加上两个反斜杠和一个箭头。\nconsole\n8\n// → 40320\n祝好运！\n",
  "factionName": "JavaScript 编程精解",
  "newest": 10,
  "comments": [],
  "source": [],
  "index": "4"
},{
  "_id": "9903f039-d632-407a-986b-8eb0af1210fc",
  "headerImage": "https://wk-gulimall.oss-cn-beijing.aliyuncs.com/ProgramBook/09e23430-f36c-4901-b083-e9c2a9d5fa79.jpg",
  "updateTime": {
    "$date": "2023-01-23T16:59:34.023Z"
  },
  "author": "姜承尧, ",
  "des": "数据库技术丛书\nMySQL技术内幕\n——InnoDB存储引擎 第2版\n姜承尧　著\nISBN：978-7-111-42206-8\n本书纸版由机械工业出版社于2013年出版，电子版由华章分社（北京华章图文信息有限公司）全球范围内制作与发行。\n版权所有，侵权必究\n客服热线：+ 86-10-68995265\n客服信箱：service@bbbvip.com\n官方网址：www.hzmedia.com.cn\n新浪微博 @研发书局\n腾讯微博 @yanfabook\n目　录\n推荐序\n前言\n为什么要写这本书\n第1版与第2版的区别\n读者对象\n如何阅读本书\n勘误和支持\n致谢\n第1章　MySQL体系结构和存储引擎\n1.1　定义数据库和实例\n1.2　MySQL体系结构\n1.3　MySQL存储引擎\n1.3.1　InnoDB存储引擎\n1.3.2　MyISAM存储引擎\n1.3.3　NDB存储引擎\n1.3.4　Memory存储引擎\n1.3.5　Archive存储引擎\n1.3.6　Federated存储引擎\n1.3.7　Maria存储引擎\n1.3.8　其他存储引擎\n1.4　各存储引擎之间的比较\n1.5　连接MySQL\n1.5.1　TCP/IP\n1.5.2　命名管道和共享内存\n1.5.3　UNIX域套接字\n1.6　小结\n第2章　InnoDB存储引擎\n2.1　InnoDB存储引擎概述\n2.2　InnoDB存储引擎的版本\n2.3　InnoDB体系架构\n2.3.1　后台线程\n2.3.2　内存\n2.4　Checkpoint技术\n2.5　Master Thread工作方式\n2.5.1　InnoDB 1.0.x版本之前的Master Thread\n2.5.2　InnoDB1.2.x版本之前的Master Thread\n2.5.3　InnoDB 1.2.x版本的Master Thread\n2.6　InnoDB关键特性\n2.6.1　插入缓冲\n2.6.2　两次写\n2.6.3　自适应哈希索引\n2.6.4　异步IO\n2.6.5　刷新邻接页\n2.7　启动、关闭与恢复\n2.8　小结\n第3章　文件\n3.1　参数文件\n3.1.1　什么是参数\n3.1.2　参数类型\n3.2　日志文件\n3.2.1　错误日志\n3.2.2　慢查询日志\n3.2.3　查询日志\n3.2.4　二进制日志\n3.3　套接字文件\n3.4　pid文件\n3.5　表结构定义文件\n3.6　InnoDB存储引擎文件\n3.6.1　表空间文件\n3.6.2　重做日志文件\n3.7　小结\n第4章　表\n4.1　索引组织表\n4.2　InnoDB逻辑存储结构\n4.2.1　表空间\n4.2.2　段\n4.2.3　区\n4.2.4　页\n4.2.5　行\n4.3　InnoDB行记录格式\n4.3.1　Compact行记录格式\n4.3.2　Redundant行记录格式\n4.3.3　行溢出数据\n4.3.4　Compressed和Dynamic行记录格式\n4.3.5　CHAR的行结构存储\n4.4　InnoDB数据页结构\n4.4.1　File Header\n4.4.2　Page Header\n4.4.3　Infimum和Supremum Record\n4.4.4　User Record和Free Space\n4.4.5　Page Directory\n4.4.6　File Trailer\n4.4.7　InnoDB数据页结构示例分析\n4.5　Named File Formats机制\n4.6　约束\n4.6.1　数据完整性\n4.6.2　约束的创建和查找\n4.6.3　约束和索引的区别\n4.6.4　对错误数据的约束\n4.6.5　ENUM和SET约束\n4.6.6　触发器与约束\n4.6.7　外键约束\n4.7　视图\n4.7.1　视图的作用\n4.7.2　物化视图\n4.8　分区表\n4.8.1　分区概述\n4.8.2　分区类型\n4.8.3　子分区\n4.8.4　分区中的NULL值\n4.8.5　分区和性能\n4.8.6　在表和分区间交换数据\n4.9　小结\n第5章　索引与算法\n5.1　InnoDB存储引擎索引概述\n5.2　数据结构与算法\n5.2.1　二分查找法\n5.2.2　二叉查找树和平衡二叉树\n5.3　B+树\n5.3.1　B+树的插入操作\n5.3.2　B+树的删除操作\n5.4　B+树索引\n5.4.1　聚集索引\n5.4.2　辅助索引\n5.4.3　B+树索引的分裂\n5.4.4　B+树索引的管理\n5.5　Cardinality值\n5.5.1　什么是Cardinality\n5.5.2　InnoDB存储引擎的Cardinality统计\n5.6　B+树索引的使用\n5.6.1　不同应用中B+树索引的使用\n5.6.2　联合索引\n5.6.3　覆盖索引\n5.6.4　优化器选择不使用索引的情况\n5.6.5　索引提示\n5.6.6　Multi-Range Read优化\n5.6.7　Index Condition Pushdown（ICP）优化\n5.7　哈希算法\n5.7.1　哈希表\n5.7.2　InnoDB存储引擎中的哈希算法\n5.7.3　自适应哈希索引\n5.8　全文检索\n5.8.1　概述\n5.8.2　倒排索引\n5.8.3　InnoDB全文检索\n5.8.4　全文检索\n5.9　小结\n第6章　锁\n6.1　什么是锁\n6.2　lock与latch\n6.3　InnoDB存储引擎中的锁\n6.3.1　锁的类型\n6.3.2　一致性非锁定读\n6.3.3　一致性锁定读\n6.3.4　自增长与锁\n6.3.5　外键和锁\n6.4　锁的算法\n6.4.1　行锁的3种算法\n6.4.2　解决Phantom Problem\n6.5　锁问题\n6.5.1　脏读\n6.5.2　不可重复读\n6.5.3　丢失更新\n6.6　阻塞\n6.7　死锁\n6.7.1　死锁的概念\n6.7.2　死锁概率\n6.7.3　死锁的示例\n6.8　锁升级\n6.9　小结\n第7章　事务\n7.1　认识事务\n7.1.1　概述\n7.1.2　分类\n7.2　事务的实现\n7.2.1　redo\n7.2.2　undo\n7.2.3　purge\n7.2.4　group commit\n7.3　事务控制语句\n7.4　隐式提交的SQL语句\n7.5　对于事务操作的统计\n7.6　事务的隔离级别\n7.7　分布式事务\n7.7.1　MySQL数据库分布式事务\n7.7.2　内部XA事务\n7.8　不好的事务习惯\n7.8.1　在循环中提交\n7.8.2　使用自动提交\n7.8.3　使用自动回滚\n7.9　长事务\n7.10　小结\n第8章　备份与恢复\n8.1　备份与恢复概述\n8.2　冷备\n8.3　逻辑备份\n8.3.1　mysqldump\n8.3.2　SELECT...INTO OUTFILE\n8.3.3　逻辑备份的恢复\n8.3.4　LOAD DATA INFILE\n8.3.5　mysqlimport\n8.4　二进制日志备份与恢复\n8.5　热备\n8.5.1　ibbackup\n8.5.2　XtraBackup\n8.5.3　XtraBackup实现增量备份\n8.6　快照备份\n8.7　复制\n8.7.1　复制的工作原理\n8.7.2　快照+复制的备份架构\n8.8　小结\n第9章　性能调优\n9.1　选择合适的CPU\n9.2　内存的重要性\n9.3　硬盘对数据库性能的影响\n9.3.1　传统机械硬盘\n9.3.2　固态硬盘\n9.4　合理地设置RAID\n9.4.1　RAID类型\n9.4.2　RAID Write Back功能\n9.4.3　RAID配置工具\n9.5　操作系统的选择\n9.6　不同的文件系统对数据库性能的影响\n9.7　选择合适的基准测试工具\n9.7.1　sysbench\n9.7.2　mysql-tpcc\n9.8　小结\n第10章　InnoDB存储引擎源代码的编译和调试\n10.1　获取InnoDB存储引擎源代码\n10.2　InnoDB源代码结构\n10.3　MySQL 5.1版本编译和调试InnoDB源代码\n10.3.1　Windows下的调试\n10.3.2　Linux下的调试\n10.4　cmake方式编译和调试InnoDB存储引擎\n10.5　小结\n推荐序\nIt's fair to say that MySQL is the most popular open source database.It has a very large installed base and number of users.Let's see what are the reasons MySQL is so popular,where it stands currently,and maybe touch on some of its future(although predicting the future is rarely successful).\nLooking at the customer area of MySQL,which includes Facebook,Flickr,Adobe(in Creative Suite 3),Drupal,Digg,LinkedIn,Wikipedia,eBay,YouTube,Google AdSense(source http://mysql.com/customers/and public resources),it's obvious that MySQL is everywhere.When you log in to your popular forum(powered by Bulleting)or blog(powered by WordPress),most likely it has MySQL as its backend database.Traditionally,two MySQL's characteristics,simplicity of use and performance,were what allowed it to gain such popularity.In addition to that,availability on a very wide range of platforms(including Windows)and built-in replication,which provides an easy scale-out solution for read-only clients,gave more user attractions and production deployments.There is simple evidence of MySQL's simplicity:In 15 minutes or less,you really can get installed,have a working database,and start running queries and store data.From its early stages MySQL had a good interface to most popular languages for Web development-PHP and Perl,and also Java and ODBC connectors.\nThere are two best known storage engines in MySQL:MyISAM and InnoDB(I don't cover NDB cluster here;it's a totally different story).MyISAM comes as the default storage engine and historically it is the oldest,but InnoDB is ACID compliant and provides transactions,row-level locking,MVCC,automatic recovery and data corruption detection.This makes it the storage engine you want to choose for your application.Also,there is the third-party transaction storage engine PBXT,with characteristics similar to InnoDB,which is included in the MariaDB distribution.\nMySQL's simplicity has its own drawback.Just as it is very easy to start working with it,it is very easy to start getting into trouble with it.As soon as your website or forum gets popular,you may figure out that the database is a bottleneck,and that you need special skills and tools to fix it.\nThe author of this book is a MySQL expert,especially in InnoDB storage engineB.Hence,I highly recommend this book to new users of InnoDB as well as uers who already have well-tuned InnoDB-based applications but need to get internal out of them.\nVadim Tkachenko\n全球知名MySQL数据库服务提供商Percona公司CTO\n知名MySQL数据库博客MySQLPerformanceBlog.com作者\n《高性能MySQL（第2版）》作者之一\n前言\n为什么要写这本书\n过去这些年我一直在和各种不同的数据库打交道，见证了MySQL从一个小型的关系型数据库发展为各大企业的核心数据库系统的过程，并且参与了一些大大小小的项目的开发工作，成功地帮助开发人员构建了可靠的、健壮的应用程序。在这个过程中积累了一些经验，正是这些不断累积的经验赋予了我灵感，于是有了这本书。这本书实际上反映了这些年来我做了哪些事情，其中汇集了很多同行每天可能都会遇到的一些问题，并给出了解决方案。\nMySQL数据库独有的插件式存储引擎架构使其和其他任何数据库都不同。不同的存储引擎有着完全不同的功能，而InnoDB存储引擎的存在使得MySQL跃入了企业级数据库领域。本书完整地讲解了InnoDB存储引擎中最重要的一些内容，即InnoDB的体系结构和工作原理，并结合InnoDB的源代码讲解了它的内部实现机制。\n本书不仅讲述了InnoDB存储引擎的诸多功能和特性，还阐述了如何正确地使用这些功能和特性，更重要的是，还尝试了教我们如何Think Different。Think Different是20世纪90年代苹果公司在其旷日持久的宣传活动中提出的一个口号，借此来重振公司的品牌，更重要的是，这个口号改变了人们对技术在日常生活中的作用的看法。需要注意的是，苹果的口号不是Think Differently，是Think Different，Different在这里做名词，意味该思考些什么。\n很多DBA和开发人员都相信某些“神话”，然而这些“神话”往往都是错误的。无论计算机技术发展的速度变得多快，数据库的使用变得多么简单，任何时候Why都比What重要。只有真正理解了内部实现原理、体系结构，才能更好地去使用。这正是人类正确思考问题的原则。因此，对于当前出现的技术，尽管学习其应用很重要，但更重要的是，应当正确地理解和使用这些技术。\n关于本书，我的头脑里有很多个目标，但最重要的是想告诉大家如下几个简单的观点：\n❑不要相信任何的“神话”，学会自己思考；\n❑不要墨守成规，大部分人都知道的事情可能是错误的；\n❑不要相信网上的传言，去测试，根据自己的实践做出决定；\n❑花时间充分地思考，敢于提出质疑。\n当前有关MySQL的书籍大部分都集中在教读者如何使用MySQL，例如SQL语句的使用、复制的搭建的、数据的切分等。没错，这对快速掌握和使用MySQL数据库非常有好处，但是真正的数据库工作者需要了解的不仅仅是应用，更多的是内部的具体实现。\nMySQL数据库独有的插件式存储引擎使得想要在一本书内完整地讲解各个存储引擎变得十分困难，有的书可能偏重对MyISAM的介绍，有的可能偏重对InnoDB存储引擎的介绍。对于初级的DBA来说，这可能会使他们的理解变得更困难。对于大多数MySQL DBA和开发人员来说，他们往往更希望了解作为MySQL企业级数据库应用的第一存储引擎的InnoDB，我想在本书中，他们完全可以找到他们希望了解的内容。\n再强调一遍，任何时候Why都比What重要，本书从源代码的角度对InnoDB的存储引擎的整个体系架构的各个组成部分进行了系统的分析和讲解，剖析了InnoDB存储引擎的核心实现和工作机制，相信这在其他书中是很难找到的。\n第1版与第2版的区别\n本书是第2版，在写作中吸收了读者对上一版内容的许多意见和建议，同时对于最新MySQL 5.6中许多关于InnoDB存储引擎的部分进行了详细的解析与介绍。希望通过这些改进，给读者一个从应用到设计再到实现的完整理解，弥补上一版中深度有余，内容层次不够丰富、分析手法单一等诸多不足。\n较第1版而言，第2版的改动非常大，基本上重写了50%的内容。其主要体现在以下几个方面，希望读者能够在阅读中体会到。\n❑本书增加了对最新MySQL 5.6中的InnoDB存储引擎特性的介绍。MySQL 5.6版本是有史以来最大的一次更新，InnoDB存储引擎更是添加了许多功能，如多线程清理线程、全文索引、在线索引添加、独立回滚段、非递归死锁检测、新的刷新算法、新的元数据表等。读者通过本书可以知道如何使用这些特性、新特性存在的局限性，并明白新功能与老版本InnoDB存储引擎之间实现的区别，从而在实际应用中充分利用这些特性。\n❑根据读者的要求对于InnoDB存储引擎的redo日志和undo日志进行了详细的分析。读者应该能更好地理解InnoDB存储引擎事务的实现。在undo日志分析中，通过InnoSQL自带的元数据表，用户终于可对undo日志进行统计和分析，极大提高了DBA对于InnoDB存储引擎内部的认知。\n❑对第6章进行大幅度的重写，读者可以更好地理解InnoDB存储引擎特有的next-key locking算法，并且通过分析锁的实现来了解死锁可能产生的情况，以及InnoDB存储引擎内部是如何来避免死锁问题的产生的。\n❑根据读者的反馈，对InnoDB存储引擎的insert buffer模块实现进行了更为详细的介绍，读者可以了解其使用方法以及其内部的实现原理。此外还增加了对insert buffer的升级版本功能——change buffer的介绍。\n读者对象\n本书不是一本面向应用的数据库类书籍，也不是一本参考手册，更不会教你如何在MySQL中使用SQL语句。本书面向那些使用MySQL InnoDB存储引擎作为数据库后端开发应用程序的开发者和有一定经验的MySQL DBA。书中的大部分例子都是用SQL语句来展示关键特性的，如果想通过本书来了解如何启动MySQL、如何配置Replication环境，可能并不能如愿。不过，在本书中，你将知道InnoDB存储引擎是如何工作的，它的关键特性的功能和作用是什么，以及如何正确配置和使用这些特性。\n如果你想更好地使用InnoDB存储引擎，如果你想让你的数据库应用获得更好的性能，就请阅读本书。从某种程度上讲，技术经理或总监也要非常了解数据库，要知道数据库对于企业的重要性。如果技术经理或总监想安排员工参加MySQL数据库技术方面的培训，完全可以利用本书来“充电”，相信你一定不会失望的。\n要想更好地学习本书的内容，要求具备以下条件：\n❑掌握SQL。\n❑掌握基本的MySQL操作。\n❑接触过一些高级语言，如C、C++、Python或Java。\n❑对一些基本算法有所了解，因为本书会分析InnoDB存储引擎的部分源代码，如果你能看懂这些算法，这会对你的理解非常有帮助。\n如何阅读本书\n本书一共有10章，每一章都像一本“迷你书”，可以单独成册，也就说你完全可以从书中任何一章开始阅读。例如，要了解第10章中的InnoDB源代码编译和调试的知识，就不必先去阅读第3章有关文件的知识。当然，如果你不太确定自己是否已经对本书所涉及的内容完全掌握了，建议你系统性地阅读本书。\n本书不是一本入门书籍，不会一步步引导你去如何操作。倘若你尚不了解InnoDB存储引擎，本书对你来说可能就显得沉重一些，建议你先查阅官方的API文档，大致掌握InnoDB的基础知识，然后再来学习本书，相信你会领略到不同的风景。\n为了便于大家阅读，本书在提供源代码下载（下载地址：www.hzbook.com）的同时也将源代码附在了书中，因此占去了一些篇幅，还请大家理解。\n勘误和支持\n由于作者对InnoDB存储引擎的认知水平有限，再加上写作时可能存在疏漏，书中还存在许多需要改进的地方。在此，欢迎读者朋友们指出书中存在的问题，并提出指导性意见，不甚感谢。如果大家有任何与本书相关的内容需要与我探讨，请发邮件到jiangchengyao@gmail.com，或者通过新浪微博@insidemysql与我联系，我会及时给予回复。最后，衷心地希望本书能给大家带来帮助，并祝大家阅读愉快!\n致谢\n在编写本书的过程中，我得到了很多朋友的热心帮助。首先要感谢Pecona公司的CEO Peter Zaitsev和CTO Vadim Tkachenko，通过和他们的不断交流，使我对InnoDB存储引擎有了更进一步的了解，同时知道了怎样才能正确地将InnoDB存储引擎的补丁应用到生产环境。\n其次，要感谢网易公司的各位同事们，能在才华横溢、充满创意的团队中工作我感到非常荣幸和兴奋。也因为在这个开放的工作环境中，我可以不断进行研究和创新。\n此外，我还要感谢我的母亲，写本书不是一件容易的事，特别是这本书还想传达一些思想，在这个过程中我遇到了很多的困难，感谢她在这个过程中给予我的支持和鼓励。\n最后，一份特别的感谢要送给本书的策划编辑杨福川和姜影，他们使得本书变得生动和更具有灵魂。此外还要感谢出版社的其他默默工作的同事们。\n姜承尧\n第1章　MySQL体系结构和存储引擎\nMySQL被设计为一个可移植的数据库，几乎在当前所有系统上都能运行，如Linux，Solaris、FreeBSD、Mac和Windows。尽管各平台在底层（如线程）实现方面都各有不同，但是MySQL基本上能保证在各平台上的物理体系结构的一致性。因此，用户应该能很好地理解MySQL数据库在所有这些平台上是如何运作的。\n1.1　定义数据库和实例\n在数据库领域中有两个词很容易混淆，这就是“数据库”（database）和“实例”（instance）。作为常见的数据库术语，这两个词的定义如下。\n❑数据库：物理操作系统文件或其他形式文件类型的集合。在MySQL数据库中，数据库文件可以是frm、MYD、MYI、ibd结尾的文件。当使用NDB引擎时，数据库的文件可能不是操作系统上的文件，而是存放于内存之中的文件，但是定义仍然不变。\n❑实例：MySQL数据库由后台线程以及一个共享内存区组成。共享内存可以被运行的后台线程所共享。需要牢记的是，数据库实例才是真正用于操作数据库文件的。\n这两个词有时可以互换使用，不过两者的概念完全不同。在MySQL数据库中，实例与数据库的关通常系是一一对应的，即一个实例对应一个数据库，一个数据库对应一个实例。但是，在集群情况下可能存在一个数据库被多个数据实例使用的情况。\nMySQL被设计为一个单进程多线程架构的数据库，这点与SQL Server比较类似，但与Oracle多进程的架构有所不同（Oracle的Windows版本也是单进程多线程架构的）。这也就是说，MySQL数据库实例在系统上的表现就是一个进程。\n在Linux操作系统中通过以下命令启动MySQL数据库实例，并通过命令ps观察MySQL数据库启动后的进程情况：\n[root@xen-server bin]#./mysqld_safe＆\n[root@xen-server bin]#ps-ef|grep mysqld\nroot 3441 3258 0 10:23 pts/3 00:00:00/bin/sh./mysqld_safe\nmysql 3578 3441 0 10:23 pts/3 00:00:00\n/usr/local/mysql/libexec/mysqld--basedir=/usr/local/mysql\n--datadir=/usr/local/mysql/var--user=mysql\n--log-error=/usr/local/mysql/var/xen-server.err\n--pid-file=/usr/local/mysql/var/xen-server.pid\n--socket=/tmp/mysql.sock--port=3306\nroot 3616 3258 0 10:27 pts/3 00:00:00 grep mysqld\n注意进程号为3578的进程，该进程就是MySQL实例。在上述例子中使用了mysqld_safe命令来启动数据库，当然启动MySQL实例的方法还有很多，在各种平台下的方式可能又会有所不同。在这里不一一赘述。\n当启动实例时，MySQL数据库会去读取配置文件，根据配置文件的参数来启动数据库实例。这与Oracle的参数文件（spfile）相似，不同的是，Oracle中如果没有参数文件，在启动实例时会提示找不到该参数文件，数据库启动失败。而在MySQL数据库中，可以没有配置文件，在这种情况下，MySQL会按照编译时的默认参数设置启动实例。用以下命令可以查看当MySQL数据库实例启动时，会在哪些位置查找配置文件。\n[root@xen-server bin]#mysql--help|grep my.cnf\norder of preference,my.cnf,$MYSQL_TCP_PORT,\n/etc/my.cnf/etc/mysql/my.cnf/usr/local/mysql/etc/my.cnf～/.my.cnf\n可以看到，MySQL数据库是按/etc/my.cnf→/etc/mysql/my.cnf→/usr/local/mysql/etc/my.cnf→～/.my.cnf的顺序读取配置文件的。可能有读者会问：“如果几个配置文件中都有同一个参数，MySQL数据库以哪个配置文件为准？”答案很简单，MySQL数据库会以读取到的最后一个配置文件中的参数为准。在Linux环境下，配置文件一般放在/etc/my.cnf下。在Windows平台下，配置文件的后缀名可能是.cnf，也可能是.ini。例如在Windows操作系统下运行mysql--help，可以找到如下类似内容：\nDefault options are read from the following files in the given order:\nC:\\Windows\\my.ini C:\\Windows\\my.cnf C:\\my.ini C:\\my.cnf C:\\Program Files\\MySQL\\M\n\\MySQL Server 5.1\\my.cnf\n配置文件中有一个参数datadir，该参数指定了数据库所在的路径。在Linux操作系统下默认datadir为/usr/local/mysql/data，用户可以修改该参数，当然也可以使用该路径，不过该路径只是一个链接，具体如下：\nmysql＞SHOW VARIABLES LIKE'datadir'\\G;\n***************************1.row***************************\nVariable_name:datadir\nValue:/usr/local/mysql/data/\n1 row in set(0.00 sec)1 row in set(0.00 sec)\nmysql＞system ls-lh/usr/local/mysql/data\ntotal 32K\ndrwxr-xr-x 2 root mysql 4.0K Aug 6 16:23 bin\ndrwxr-xr-x 2 root mysql 4.0K Aug 6 16:23 docs\ndrwxr-xr-x 3 root mysql 4.0K Aug 6 16:04 include\ndrwxr-xr-x 3 root mysql 4.0K Aug 6 16:04 lib\ndrwxr-xr-x 2 root mysql 4.0K Aug 6 16:23 libexec\ndrwxr-xr-x 10 root mysql 4.0K Aug 6 16:23 mysql-test\ndrwxr-xr-x 5 root mysql 4.0K Aug 6 16:04 share\ndrwxr-xr-x 5 root mysql 4.0K Aug 6 16:23 sql-bench\nlrwxrwxrwx 1 root mysql 16 Aug 6 16:05 data-＞/opt/mysql_data/\n从上面可以看到，其实data目录是一个链接，该链接指向了/opt/mysql_data目录。当然，用户必须保证/opt/mysql_data的用户和权限，使得只有mysql用户和组可以访问（通常MySQL数据库的权限为mysql∶mysql）。\n1.2　MySQL体系结构\n由于工作的缘故，笔者的大部分时间需要与开发人员进行数据库方面的沟通，并对他们进行培训。不论他们是DBA，还是开发人员，似乎都对MySQL的体系结构了解得不够透彻。很多人喜欢把MySQL与他们以前使用的SQL Server、Oracle、DB2作比较。因此笔者常常会听到这样的疑问：\n❑为什么MySQL不支持全文索引？\n❑MySQL速度快是因为它不支持事务吗？\n❑数据量大于1000万时MySQL的性能会急剧下降吗？\n……\n对于MySQL数据库的疑问有很多很多，在解释这些问题之前，笔者认为不管对于使用哪种数据库的开发人员，了解数据库的体系结构都是最为重要的内容。\n在给出体系结构图之前，用户应该理解了前一节提出的两个概念：数据库和数据库实例。很多人会把这两个概念混淆，即MySQL是数据库，MySQL也是数据库实例。这样来理解Oracle和Microsoft SQL Server数据库可能是正确的，但是这会给以后理解MySQL体系结构中的存储引擎带来问题。从概念上来说，数据库是文件的集合，是依照某种数据模型组织起来并存放于二级存储器中的数据集合；数据库实例是程序，是位于用户与操作系统之间的一层数据管理软件，用户对数据库数据的任何操作，包括数据库定义、数据查询、数据维护、数据库运行控制等都是在数据库实例下进行的，应用程序只有通过数据库实例才能和数据库打交道。\n如果这样讲解后读者还是不明白，那这里再换一种更为直白的方式来解释：数据库是由一个个文件组成（一般来说都是二进制的文件）的，要对这些文件执行诸如SELECT、INSERT、UPDATE和DELETE之类的数据库操作是不能通过简单的操作文件来更改数据库的内容，需要通过数据库实例来完成对数据库的操作。所以，用户把Oracle、SQL Server、MySQL简单地理解成数据库可能是有失偏颇的，虽然在实际使用中并不会这么强调两者之间的区别。\n好了，在给出上述这些复杂枯燥的定义后，现在可以来看看MySQL数据库的体系结构了，其结构如图1-1所示（摘自MySQL官方手册）。\n图　1-1　MySQL体系结构\n从图1-1可以发现，MySQL由以下几部分组成：\n❑连接池组件\n❑管理服务和工具组件\n❑SQL接口组件\n❑查询分析器组件\n❑优化器组件\n❑缓冲（Cache）组件\n❑插件式存储引擎\n❑物理文件\n从图1-1还可以发现，MySQL数据库区别于其他数据库的最重要的一个特点就是其插件式的表存储引擎。MySQL插件式的存储引擎架构提供了一系列标准的管理和服务支持，这些标准与存储引擎本身无关，可能是每个数据库系统本身都必需的，如SQL分析器和优化器等，而存储引擎是底层物理结构的实现，每个存储引擎开发者可以按照自己的意愿来进行开发。\n需要特别注意的是，存储引擎是基于表的，而不是数据库。此外，要牢记图1-1的MySQL体系结构，它对于以后深入理解MySQL数据库会有极大的帮助。\n1.3　MySQL存储引擎\n通过1.2节大致了解了MySQL数据库独有的插件式体系结构，并了解到存储引擎是MySQL区别于其他数据库的一个最重要特性。存储引擎的好处是，每个存储引擎都有各自的特点，能够根据具体的应用建立不同存储引擎表。对于开发人员来说，存储引擎对其是透明的，但了解各种存储引擎的区别对于开发人员来说也是有好处的。对于DBA来说，他们应该深刻地认识到MySQL数据库的核心在于存储引擎。\n[1]\n由于MySQL数据库开源特性，存储引擎可以分为MySQL官方存储引擎和第三方存储引擎。有些第三方存储引擎很强大，如大名鼎鼎的InnoDB存储引擎（最早是第三方存储引擎，后被Oracle收购），其应用就极其广泛，甚至是MySQL数据库OLTP（Online Transaction Processing在线事务处理）应用中使用最广泛的存储引擎。还是那句话，用户应该根据具体的应用选择适合的存储引擎，以下是对一些存储引擎的简单介绍，以便于读者选择存储引擎时参考。\n1.3.1　InnoDB存储引擎\nInnoDB存储引擎支持事务，其设计目标主要面向在线事务处理（OLTP）的应用。其特点是行锁设计、支持外键，并支持类似于Oracle的非锁定读，即默认读取操作不会产生锁。从MySQL数据库5.5.8版本开始，InnoDB存储引擎是默认的存储引擎。\nInnoDB存储引擎将数据放在一个逻辑的表空间中，这个表空间就像黑盒一样由InnoDB存储引擎自身进行管理。从MySQL 4.1（包括4.1）版本开始，它可以将每个InnoDB存储引擎的表单独存放到一个独立的ibd文件中。此外，InnoDB存储引擎支持用裸设备（row disk）用来建立其表空间。\nInnoDB通过使用多版本并发控制（MVCC）来获得高并发性，并且实现了SQL标准的4种隔离级别，默认为REPEATABLE级别。同时，使用一种被称为next-key locking的策略来避免幻读（phantom）现象的产生。除此之外，InnoDB储存引擎还提供了插入缓冲（insert buffer）、二次写（double write）、自适应哈希索引（adaptive hash index）、预读（read ahead）等高性能和高可用的功能。\n对于表中数据的存储，InnoDB存储引擎采用了聚集（clustered）的方式，因此每张表的存储都是按主键的顺序进行存放。如果没有显式地在表定义时指定主键，InnoDB存储引擎会为每一行生成一个6字节的ROWID，并以此作为主键。\nInnoDB存储引擎是MySQL数据库最为常用的一种引擎，而Facebook、Google、Yahoo！等公司的成功应用已经证明了InnoDB存储引擎具备的高可用性、高性能以及高可扩展性。\n[1]\n1.3.2　MyISAM存储引擎\nMyISAM存储引擎不支持事务、表锁设计，支持全文索引，主要面向一些OLAP数据库应用。在MySQL 5.5.8版本之前MyISAM存储引擎是默认的存储引擎（除Windows版本外）。数据库系统与文件系统很大的一个不同之处在于对事务的支持，然而MyISAM存储引擎是不支持事务的。究其根本，这也不是很难理解。试想用户是否在所有的应用中都需要事务呢？在数据仓库中，如果没有ETL这些操作，只是简单的报表查询是否还需要事务的支持呢？此外，MyISAM存储引擎的另一个与众不同的地方是它的缓冲池只缓存（cache）索引文件，而不缓冲数据文件，这点和大多数的数据库都非常不同。\nMyISAM存储引擎表由MYD和MYI组成，MYD用来存放数据文件，MYI用来存放索引文件。可以通过使用myisampack工具来进一步压缩数据文件，因为myisampack工具使用赫夫曼（Huffman）编码静态算法来压缩数据，因此使用myisampack工具压缩后的表是只读的，当然用户也可以通过myisampack来解压数据文件。\n在MySQL 5.0版本之前，MyISAM默认支持的表大小为4GB，如果需要支持大于4GB的MyISAM表时，则需要制定MAX_ROWS和AVG_ROW_LENGTH属性。从MySQL 5.0版本开始，MyISAM默认支持256TB的单表数据，这足够满足一般应用需求。\n注意　对于MyISAM存储引擎表，MySQL数据库只缓存其索引文件，数据文件的缓存交由操作系统本身来完成，这与其他使用LRU算法缓存数据的大部分数据库大不相同。此外，在MySQL 5.1.23版本之前，无论是在32位还是64位操作系统环境下，缓存索引的缓冲区最大只能设置为4GB。在之后的版本中，64位系统可以支持大于4GB的索引缓冲区。\n1.3.3　NDB存储引擎\n2003年，MySQL AB公司从Sony Ericsson公司收购了NDB集群引擎（见图1-1）。NDB存储引擎是一个集群存储引擎，类似于Oracle的RAC集群，不过与Oracle RAC share everything架构不同的是，其结构是share nothing的集群架构，因此能提供更高的可用性。NDB的特点是数据全部放在内存中（从MySQL 5.1版本开始，可以将非索引数据放在磁盘上），因此主键查找（primary key lookups）的速度极快，并且通过添加NDB数据存储节点（Data Node）可以线性地提高数据库性能，是高可用、高性能的集群系统。\n关于NDB存储引擎，有一个问题值得注意，那就是NDB存储引擎的连接操作（JOIN）是在MySQL数据库层完成的，而不是在存储引擎层完成的。这意味着，复杂的连接操作需要巨大的网络开销，因此查询速度很慢。如果解决了这个问题，NDB存储引擎的市场应该是非常巨大的。\n注意　MySQL NDB Cluster存储引擎有社区版本和企业版本两种，并且NDB Cluster已作为Carrier Grade Edition单独下载版本而存在，可以通过http://dev.mysql.com/downloads/cluster/index.html获得最新版本的NDB Cluster存储引擎。\n1.3.4　Memory存储引擎\nMemory存储引擎（之前称HEAP存储引擎）将表中的数据存放在内存中，如果数据库重启或发生崩溃，表中的数据都将消失。它非常适合用于存储临时数据的临时表，以及数据仓库中的纬度表。Memory存储引擎默认使用哈希索引，而不是我们熟悉的B+树索引。\n虽然Memory存储引擎速度非常快，但在使用上还是有一定的限制。比如，只支持表锁，并发性能较差，并且不支持TEXT和BLOB列类型。最重要的是，存储变长字段（varchar）时是按照定常字段（char）的方式进行的，因此会浪费内存（这个问题之前已经提到，eBay的工程师Igor Chernyshev已经给出了patch解决方案）。\n此外有一点容易被忽视，MySQL数据库使用Memory存储引擎作为临时表来存放查询的中间结果集（intermediate result）。如果中间结果集大于Memory存储引擎表的容量设置，又或者中间结果含有TEXT或BLOB列类型字段，则MySQL数据库会把其转换到MyISAM存储引擎表而存放到磁盘中。之前提到MyISAM不缓存数据文件，因此这时产生的临时表的性能对于查询会有损失。\n1.3.5　Archive存储引擎\nArchive存储引擎只支持INSERT和SELECT操作，从MySQL 5.1开始支持索引。Archive存储引擎使用zlib算法将数据行（row）进行压缩后存储，压缩比一般可达1∶10。正如其名字所示，Archive存储引擎非常适合存储归档数据，如日志信息。Archive存储引擎使用行锁来实现高并发的插入操作，但是其本身并不是事务安全的存储引擎，其设计目标主要是提供高速的插入和压缩功能。\n1.3.6　Federated存储引擎\nFederated存储引擎表并不存放数据，它只是指向一台远程MySQL数据库服务器上的表。这非常类似于SQL Server的链接服务器和Oracle的透明网关，不同的是，当前Federated存储引擎只支持MySQL数据库表，不支持异构数据库表。\n1.3.7　Maria存储引擎\nMaria存储引擎是新开发的引擎，设计目标主要是用来取代原有的MyISAM存储引擎，从而成为MySQL的默认存储引擎。Maria存储引擎的开发者是MySQL的创始人之一的Michael Widenius。因此，它可以看做是MyISAM的后续版本。Maria存储引擎的特点是：支持缓存数据和索引文件，应用了行锁设计，提供了MVCC功能，支持事务和非事务安全的选项，以及更好的BLOB字符类型的处理性能。\n1.3.8　其他存储引擎\n除了上面提到的7种存储引擎外，MySQL数据库还有很多其他的存储引擎，包括Merge、CSV、Sphinx和Infobright，它们都有各自使用的场合，这里不再一一介绍。在了解MySQL数据库拥有这么多存储引擎后，现在我可以回答1.2节中提到的问题了。\n❑为什么MySQL数据库不支持全文索引？不！MySQL支持，MyISAM、InnoDB（1.2版本）和Sphinx存储引擎都支持全文索引。\n❑MySQL数据库速度快是因为不支持事务？错！虽然MySQL的MyISAM存储引擎不支持事务，但是InnoDB支持。“快”是相对于不同应用来说的，对于ETL这种操作，MyISAM会有其优势，但在OLTP环境中，InnoDB存储引擎的效率更好。\n❑当表的数据量大于1000万时MySQL的性能会急剧下降吗？不！MySQL是数据库，不是文件，随着数据行数的增加，性能当然会有所下降，但是这些下降不是线性的，如果用户选择了正确的存储引擎，以及正确的配置，再多的数据量MySQL也能承受。如官方手册上提及的，Mytrix和Inc.在InnoDB上存储超过1 TB的数据，还有一些其他网站使用InnoDB存储引擎，处理插入/更新的操作平均800次/秒。\n1.4　各存储引擎之间的比较\n通过1.3节的介绍，我们了解了存储引擎是MySQL体系结构的核心。本节我们将通过简单比较几个存储引擎来让读者更直观地理解存储引擎的概念。图1-2取自于MySQL的官方手册，展现了一些常用MySQL存储引擎之间的不同之处，包括存储容量的限制、事务支持、锁的粒度、MVCC支持、支持的索引、备份和复制等。\n图　1-2　不同MySQL存储引擎相关特性比较\n可以看到，每种存储引擎的实现都不相同。有些竟然不支持事务，相信在任何一本关于数据库原理的书中，可能都会提到数据库与传统文件系统的最大区别在于数据库是支持事务的。而MySQL数据库的设计者在开发时却认为可能不是所有的应用都需要事务，所以存在不支持事务的存储引擎。更有不明其理的人把MySQL称做文件系统数据库，其实不然，只是MySQL数据库的设计思想和存储引擎的关系可能让人产生了理解上的偏差。\n可以通过SHOW ENGINES语句查看当前使用的MySQL数据库所支持的存储引擎，也可以通过查找information_schema架构下的ENGINES表，如下所示：\nmysql＞SHOW ENGINES\\G;\n***************************1.row***************************\nEngine:InnoDB\nSupport:YES\nComment:Supports transactions,row-level locking,and foreign keys\nTransactions:YES\nXA:YES\nSavepoints:YES\n***************************2.row***************************\nEngine:MRG_MYISAM\nSupport:YES\nComment:Collection of identical MyISAM tables\nTransactions:NO\nXA:NO\nSavepoints:NO\n***************************3.row***************************\nEngine:BLACKHOLE\nSupport:YES\nComment:/dev/null storage engine(anything you write to it disappears)\nTransactions:NO\nXA:NO\nSavepoints:NO\n***************************4.row***************************\nEngine:CSV\nSupport:YES\nComment:CSV storage engine\nTransactions:NO\nXA:NO\nSavepoints:NO\n***************************5.row***************************\nEngine:MEMORY\nSupport:YES\nComment:Hash based,stored in memory,useful for temporary tables\nTransactions:NO\nXA:NO\nSavepoints:NO\n***************************6.row***************************\nEngine:FEDERATED\nSupport:NO\nComment:Federated MySQL storage engine\nTransactions:NULL\nXA:NULL\nSavepoints:NULL\n***************************7.row***************************\nEngine:ARCHIVE\nSupport:YES\nComment:Archive storage engine\nTransactions:NO\nXA:NO\nSavepoints:NO\n***************************8.row***************************\nEngine:MyISAM\nSupport:DEFAULT\nComment:Default engine as of MySQL 3.23 with great performance\nTransactions:NO\nXA:NO\nSavepoints:NO\n8 rows in set(0.00 sec)\n下面将通过MySQL提供的示例数据库来简单显示各存储引擎之间的不同。这里将分别运行以下语句，然后统计每次使用各存储引擎后表的大小。\nmysql＞CREATE TABLE mytest Engine=MyISAM\n-＞AS SELECT*FROM salaries;\nQuery OK,2844047 rows affected(4.37 sec)\nRecords:2844047 Duplicates:0 Warnings:0\nmysql＞ALTER TABLE mytest Engine=InnoDB;\nQuery OK,2844047 rows affected(15.86 sec)\nRecords:2844047 Duplicates:0 Warnings:0\nmysql＞ALTER TABLE mytest Engine=ARCHIVE;\nQuery OK,2844047 rows affected(16.03 sec)\nRecords:2844047 Duplicates:0 Warnings:0\n通过每次的统计，可以发现当最初表使用MyISAM存储引擎时，表的大小为40.7MB，使用InnoDB存储引擎时表增大到了113.6MB，而使用Archive存储引擎时表的大小却只有20.2MB。该例子只从表的大小方面简单地揭示了各存储引擎的不同。\n注意　MySQL提供了一个非常好的用来演示MySQL各项功能的示例数据库，如SQL Server提供的AdventureWorks示例数据库和Oracle提供的示例数据库。据我所知，知道MySQL示例数据库的人很少，可能是因为这个示例数据库没有在安装的时候提示用户是否安装（如Oracle和SQL Server）以及这个示例数据库的下载竟然和文档放在一起。用户可以通过以下地址找到并下载示例数据库：http://dev.mysql.com/doc/。\n1.5　连接MySQL\n本节将介绍连接MySQL数据库的常用方式。需要理解的是，连接MySQL操作是一个连接进程和MySQL数据库实例进行通信。从程序设计的角度来说，本质上是进程通信。如果对进程通信比较了解，可以知道常用的进程通信方式有管道、命名管道、命名字、TCP/IP套接字、UNIX域套接字。MySQL数据库提供的连接方式从本质上看都是上述提及的进程通信方式。\n1.5.1　TCP/IP\nTCP/IP套接字方式是MySQL数据库在任何平台下都提供的连接方式，也是网络中使用得最多的一种方式。这种方式在TCP/IP连接上建立一个基于网络的连接请求，一般情况下客户端（client）在一台服务器上，而MySQL实例（server）在另一台服务器上，这两台机器通过一个TCP/IP网络连接。例如用户可以在Windows服务器下请求一台远程Linux服务器下的MySQL实例，如下所示：\nC:\\＞mysql-h192.168.0.101-u david-p\nEnter password:\nWelcome to the MySQL monitor.Commands end with;or\\g.\nYour MySQL connection id is 18358\nServer version:5.0.77-log MySQL Community Server(GPL)\nType'help;'or'\\h'for help.Type'\\c'to clear the current input statement.\nmysql＞\n这里的客户端是Windows，它向一台Host IP为192.168.0.101的MySQL实例发起了TCP/IP连接请求，并且连接成功。之后就可以对MySQL数据库进行一些数据库操作，如DDL和DML等。\n这里需要注意的是，在通过TCP/IP连接到MySQL实例时，MySQL数据库会先检查一张权限视图，用来判断发起请求的客户端IP是否允许连接到MySQL实例。该视图在mysql架构下，表名为user，如下所示：\nmysql＞USE mysql;\nDatabase changed\nmysql＞SELECT host,user,password FROM user;\n***************************1.row*****************************\nhost:192.168.24.%\nuser:root\npassword:*75DBD4FA548120B54FE693006C41AA9A16DE8FBE\n****************************2.row*****************************\nhost:nineyou0-43\nuser:root\npassword:*75DBD4FA548120B54FE693006C41AA9A16DE8FBE\n****************************3.row*****************************\nhost:127.0.0.1\nuser:root\npassword:*75DBD4FA548120B54FE693006C41AA9A16DE8FBE\n****************************4.row*****************************\nhost:192.168.0.100\nuser:zlm\npassword:*DAE0939275CC7CD8E0293812A31735DA9CF0953C\n****************************5.row*****************************\nhost:%\nuser:david\npassword:\n5 rows in set(0.00 sec)\n从这张权限表中可以看到，MySQL允许david这个用户在任何IP段下连接该实例，并且不需要密码。此外，还给出了root用户在各个网段下的访问控制权限。\n1.5.2　命名管道和共享内存\n在Windows 2000、Windows XP、Windows 2003和Windows Vista以及在此之上的平台上，如果两个需要进程通信的进程在同一台服务器上，那么可以使用命名管道，Microsoft SQL Server数据库默认安装后的本地连接也是使用命名管道。在MySQL数据库中须在配置文件中启用--enable-named-pipe选项。在MySQL 4.1之后的版本中，MySQL还提供了共享内存的连接方式，这是通过在配置文件中添加--shared-memory实现的。如果想使用共享内存的方式，在连接时，MySQL客户端还必须使用--protocol=memory选项。\n1.5.3　UNIX域套接字\n在Linux和UNIX环境下，还可以使用UNIX域套接字。UNIX域套接字其实不是一个网络协议，所以只能在MySQL客户端和数据库实例在一台服务器上的情况下使用。用户可以在配置文件中指定套接字文件的路径，如--socket=/tmp/mysql.sock。当数据库实例启动后，用户可以通过下列命令来进行UNIX域套接字文件的查找：\nmysql＞SHOW VARIABLES LIKE'socket';\n***************************1.row***************************\nVariable_name:socket\nValue:/tmp/mysql.sock\n1 row in set(0.00 sec)\n在知道了UNIX域套接字文件的路径后，就可以使用该方式进行连接了，如下所示：\n[root@stargazer～]#mysql-udavid-S/tmp/mysql.sock\nWelcome to the MySQL monitor.Commands end with;or\\g.\nYour MySQL connection id is 20333\nServer version:5.0.77-log MySQL Community Server(GPL)\nType'help;'or'\\h'for help.Type'\\c'to clear the buffer.\nmysql＞\n1.6　小结\n本章首先介绍了数据库和数据库实例的定义，紧接着分析了MySQL数据库的体系结构，从而进一步突出强调了“实例”和“数据库”的区别。相信不管是MySQL DBA还是MySQL的开发人员都应该从宏观上了解了MySQL体系结构，特别是MySQL独有的插件式存储引擎的概念。因为很多MySQL用户很少意识到这一点，这给他们的管理、使用和开发带来了困扰。\n本章还详细讲解了各种常见的表存储引擎的特性、适用情况以及它们之间的区别，以便于大家在选择存储引擎时作为参考。最后强调一点，虽然MySQL有许多的存储引擎，但是它们之间不存在优劣性的差异，用户应根据不同的应用选择适合自己的存储引擎。当然，如果你能力很强，完全可以修改存储引擎的源代码，甚至是创建属于自己特定应用的存储引擎，这不就是开源的魅力吗？\n第2章　InnoDB存储引擎\nInnoDB是事务安全的MySQL存储引擎，设计上采用了类似于Oracle数据库的架构。通常来说，InnoDB存储引擎是OLTP应用中核心表的首选存储引擎。同时，也正是因为InnoDB的存在，才使MySQL数据库变得更有魅力。本章将详细介绍InnoDB存储引擎的体系架构及其不同于其他存储引擎的特性。\n2.1　InnoDB存储引擎概述\n[1]\nHeikki Tuuri（1964年，芬兰赫尔辛基）是InnoDB存储引擎的创始人，和著名的Linux创始人Linus是芬兰赫尔辛基大学校友。在1990年获得赫尔辛基大学的数学逻辑博士学位后，他于1995年成立Innobase Oy公司并担任CEO。同时，在InnoDB存储引擎的开发团队中，有来自中国科技大学的Calvin Sun。而最近又有一个中国人Jimmy Yang也加入了InnoDB存储引擎的核心开发团队，负责全文索引的开发，其之前任职于Sybase数据库公司，负责数据库的相关开发工作。\nInnoDB存储引擎已经被许多大型网站使用，如用户熟知的Google、Yahoo!、Facebook、YouTube、Flickr，在网络游戏领域有《魔兽世界》、《Second Life》、《神兵玄奇》等。我不是MySQL数据库的布道者，也不是InnoDB的鼓吹者，但是我认为当前实施一个新的OLTP项目不使用MySQL InnoDB存储引擎将是多么的愚蠢。\n从MySQL数据库的官方手册可得知，著名的Internet新闻站点Slashdot.org运行在InnoDB上。Mytrix、Inc.在InnoDB上存储超过1 TB的数据，还有一些其他站点在InnoDB上处理插入/更新操作的速度平均为800次/秒。这些都证明了InnoDB是一个高性能、高可用、高可扩展的存储引擎。\nInnoDB存储引擎同MySQL数据库一样，在GNU GPL 2下发行。更多有关MySQL证书的信息，可参考http://www.mysql.com/about/legal/，这里不再详细介绍。\n[1]\n2.2　InnoDB存储引擎的版本\nInnoDB存储引擎被包含于所有MySQL数据库的二进制发行版本中。早期其版本随着MySQL数据库的更新而更新。从MySQL 5.1版本时，MySQL数据库允许存储引擎开发商以动态方式加载引擎，这样存储引擎的更新可以不受MySQL数据库版本的限制。所以在MySQL 5.1中，可以支持两个版本的InnoDB，一个是静态编译的InnoDB版本，可将其视为老版本的InnoDB；另一个是动态加载的InnoDB版本，官方称为InnoDB Plugin，可将其视为InnoDB 1.0.x版本。MySQL 5.5版本中又将InnoDB的版本升级到了1.1.x。而在最近的MySQL 5.6版本中InnoDB的版本也随着升级为1.2.x版本。表2-1显示了各个版本中InnoDB存储引擎的功能。\n在现实工作中我发现很多MySQL数据库还是停留在MySQL 5.1版本，并使用InnoDB Plugin。很多DBA错误地认为InnoDB Plugin和InnoDB 1.1版本之间是没有区别的。但从表2-1中还是可以发现，虽然都增加了对于compress和dynamic页的支持，但是InnoDB Plugin是不支持Linux Native AIO功能的。此外，由于不支持多回滚段，InnoDB Plugin支持的最大支持并发事务数量也被限制在1023。而且随着MySQL 5.5版本的发布，InnoDB Plugin也变成了一个历史产品。\n2.3　InnoDB体系架构\n通过第1章读者已经了解了MySQL数据库的体系结构，现在可能想更深入地了解InnoDB存储引擎的架构。图2-1简单显示了InnoDB的存储引擎的体系架构，从图可见，InnoDB存储引擎有多个内存块，可以认为这些内存块组成了一个大的内存池，负责如下工作：\n❑维护所有进程/线程需要访问的多个内部数据结构。\n❑缓存磁盘上的数据，方便快速地读取，同时在对磁盘文件的数据修改之前在这里缓存。\n❑重做日志（redo log）缓冲。\n……\n图　2-1　InnoDB存储引擎体系架构\n后台线程的主要作用是负责刷新内存池中的数据，保证缓冲池中的内存缓存的是最近的数据。此外将已修改的数据文件刷新到磁盘文件，同时保证在数据库发生异常的情况下InnoDB能恢复到正常运行状态。\n2.3.1　后台线程\nInnoDB存储引擎是多线程的模型，因此其后台有多个不同的后台线程，负责处理不同的任务。\n1.Master Thread\nMaster Thread是一个非常核心的后台线程，主要负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓冲（INSERT BUFFER）、UNDO页的回收等。2.5节会详细地介绍各个版本中Master Thread的工作方式。\n2.IO Thread\n在InnoDB存储引擎中大量使用了AIO（Async IO）来处理写IO请求，这样可以极大提高数据库的性能。而IO Thread的工作主要是负责这些IO请求的回调（call back）处理。InnoDB 1.0版本之前共有4个IO Thread，分别是write、read、insert buffer和log IO thread。在Linux平台下，IO Thread的数量不能进行调整，但是在Windows平台下可以通过参数innodb_file_io_threads来增大IO Thread。从InnoDB 1.0.x版本开始，read thread和write thread分别增大到了4个，并且不再使用innodb_file_io_threads参数，而是分别使用innodb_read_io_threads和innodb_write_io_threads参数进行设置，如：\nmysql＞SHOW VARIABLES LIKE'innodb_version'\\G;\n***************************1.row***************************\nVariable_name:innodb_version\nValue:1.0.6\n1 row in set(0.00 sec)\nmysql＞SHOW VARIABLES LIKE'innodb_%io_threads'\\G;\n***************************1.row***************************\nVariable_name:innodb_read_io_threads\nValue:4\n***************************2.row***************************\nVariable_name:innodb_write_io_threads\nValue:4\n2 rows in set(0.00 sec)\n可以通过命令SHOW ENGINE INNODB STATUS来观察InnoDB中的IO Thread：\nmysql＞SHOW ENGINE INNODB STATUS\\G;\n***************************1.row***************************\nType:InnoDB\nName:\nStatus:\n=====================================\n100719 21:55:26 INNODB MONITOR OUTPUT\n=====================================\nPer second averages calculated from the last 36 seconds\n……\n--------\nFILE I/O\n--------\nI/O thread 0 state:waiting for i/o request(insert buffer thread)\nI/O thread 1 state:waiting for i/o request(log thread)\nI/O thread 2 state:waiting for i/o request(read thread)\nI/O thread 3 state:waiting for i/o request(read thread)\nI/O thread 4 state:waiting for i/o request(read thread)\nI/O thread 5 state:waiting for i/o request(read thread)\nI/O thread 6 state:waiting for i/o request(write thread)\nI/O thread 7 state:waiting for i/o request(write thread)\nI/O thread 8 state:waiting for i/o request(write thread)\nI/O thread 9 state:waiting for i/o request(write thread)\n……\n----------------------------\nEND OF INNODB MONITOR OUTPUT\n============================\n1 row in set(0.01 sec)\n可以看到IO Thread 0为insert buffer thread。IO Thread 1为log thread。之后就是根据参数innodb_read_io_threads及innodb_write_io_threads来设置的读写线程，并且读线程的ID总是小于写线程。\n3.Purge Thread\n事务被提交后，其所使用的undolog可能不再需要，因此需要PurgeThread来回收已经使用并分配的undo页。在InnoDB 1.1版本之前，purge操作仅在InnoDB存储引擎的Master Thread中完成。而从InnoDB 1.1版本开始，purge操作可以独立到单独的线程中进行，以此来减轻Master Thread的工作，从而提高CPU的使用率以及提升存储引擎的性能。用户可以在MySQL数据库的配置文件中添加如下命令来启用独立的Purge Thread：\n[mysqld]\ninnodb_purge_threads=1\n在InnoDB 1.1版本中，即使将innodb_purge_threads设为大于1，InnoDB存储引擎启动时也会将其设为1，并在错误文件中出现如下类似的提示：\n120529 22:54:16[Warning]option'innodb-purge-threads':unsigned value 4 adjusted to 1\n从InnoDB 1.2版本开始，InnoDB支持多个Purge Thread，这样做的目的是为了进一步加快undo页的回收。同时由于Purge Thread需要离散地读取undo页，这样也能更进一步利用磁盘的随机读取性能。如用户可以设置4个Purge Thread：\nmysql＞SELECT VERSION()\\G;\n***************************1.row***************************\nVERSION():5.6.6\n1 row in set(0.00 sec)\nmysql＞SHOW VARIABLES LIKE'innodb_purge_threads'\\G;\n***************************1.row***************************\nVariable_name:innodb_purge_threads\nValue:4\n1 row in set(0.00 sec)\n4.Page Cleaner Thread\nPage Cleaner Thread是在InnoDB 1.2.x版本中引入的。其作用是将之前版本中脏页的刷新操作都放入到单独的线程中来完成。而其目的是为了减轻原Master Thread的工作及对于用户查询线程的阻塞，进一步提高InnoDB存储引擎的性能。\n2.3.2　内存\n1.缓冲池\nInnoDB存储引擎是基于磁盘存储的，并将其中的记录按照页的方式进行管理。因此可将其视为基于磁盘的数据库系统（Disk-base Database）。在数据库系统中，由于CPU速度与磁盘速度之间的鸿沟，基于磁盘的数据库系统通常使用缓冲池技术来提高数据库的整体性能。\n缓冲池简单来说就是一块内存区域，通过内存的速度来弥补磁盘速度较慢对数据库性能的影响。在数据库中进行读取页的操作，首先将从磁盘读到的页存放在缓冲池中，这个过程称为将页“FIX”在缓冲池中。下一次再读相同的页时，首先判断该页是否在缓冲池中。若在缓冲池中，称该页在缓冲池中被命中，直接读取该页。否则，读取磁盘上的页。\n对于数据库中页的修改操作，则首先修改在缓冲池中的页，然后再以一定的频率刷新到磁盘上。这里需要注意的是，页从缓冲池刷新回磁盘的操作并不是在每次页发生更新时触发，而是通过一种称为Checkpoint的机制刷新回磁盘。同样，这也是为了提高数据库的整体性能。\n综上所述，缓冲池的大小直接影响着数据库的整体性能。由于32位操作系统的限制，在该系统下最多将该值设置为3G。此外用户可以打开操作系统的PAE选项来获得32位操作系统下最大64GB内存的支持。随着内存技术的不断成熟，其成本也在不断下降。单条8GB的内存变得非常普遍，而PC服务器已经能支持512GB的内存。因此为了让数据库使用更多的内存，强烈建议数据库服务器都采用64位的操作系统。\n对于InnoDB存储引擎而言，其缓冲池的配置通过参数innodb_buffer_pool_size来设置。下面显示一台MySQL数据库服务器，其将InnoDB存储引擎的缓冲池设置为15GB。\nmysql＞SHOW VARIABLES LIKE'innodb_buffer_pool_size'\\G;\n***************************1.row***************************\nVariable_name:innodb_buffer_pool_size\nValue:16106127360\n1 row in set(0.00 sec)\n具体来看，缓冲池中缓存的数据页类型有：索引页、数据页、undo页、插入缓冲（insert buffer）、自适应哈希索引（adaptive hash index）、InnoDB存储的锁信息（lock info）、数据字典信息（data dictionary）等。不能简单地认为，缓冲池只是缓存索引页和数据页，它们只是占缓冲池很大的一部分而已。图2-2很好地显示了InnoDB存储引擎中内存的结构情况。\n图　2-2　InnoDB内存数据对象\n从InnoDB 1.0.x版本开始，允许有多个缓冲池实例。每个页根据哈希值平均分配到不同缓冲池实例中。这样做的好处是减少数据库内部的资源竞争，增加数据库的并发处理能力。可以通过参数innodb_buffer_pool_instances来进行配置，该值默认为1。\nmysql＞SHOW VARIABLES LIKE'innodb_buffer_pool_instances'\\G;\n***************************1.row***************************\nVariable_name:innodb_buffer_pool_instances\nValue:1\n1 row in set(0.00 sec)\n在配置文件中将innodb_buffer_pool_instances设置为大于1的值就可以得到多个缓冲池实例。再通过命令SHOW ENGINE INNODB STATUS可以观察到如下的内容：\nmysql＞SHOW ENGINE INNODB STATUS\\G;\n***************************1.row***************************\nType:InnoDB\n……\n----------------------\nINDIVIDUAL BUFFER POOL INFO\n----------------------\n---BUFFER POOL 0\nBuffer pool size 65535\nFree buffers 65451\nDatabase pages 84\nOld database pages 0\nModified db pages 0\nPending reads 0\nPending writes:LRU 0,flush list 0 single page 0\nPages made young 0,not young 0\n0.00 youngs/s,0.00 non-youngs/s\nPages read 84,created 0,written 1\n9.33 reads/s,0.00 creates/s,0.11 writes/s\nBuffer pool hit rate 764/1000,young-making rate 0/1000 not 0/1000\nPages read ahead 0.00/s,evicted without access 0.00/s,Random read ahead 0.00/s\nLRU len:84,unzip_LRU len:0\nI/O sum[0]:cur[0],unzip sum[0]:cur[0]\n---BUFFER POOL 1\nBuffer pool size 65536\nFree buffers 65473\nDatabase pages 63\nOld database pages 0\nModified db pages 0\nPending reads 0\nPending writes:LRU 0,flush list 0 single page 0\nPages made young 0,not young 0\n0.00 youngs/s,0.00 non-youngs/s\nPages read 63,created 0,written 0\n7.00 reads/s,0.00 creates/s,0.00 writes/s\nBuffer pool hit rate 500/1000,young-making rate 0/1000 not 0/1000\nPages read ahead 0.00/s,evicted without access 0.00/s,Random read ahead 0.00/s\nLRU len:63,unzip_LRU len:0\nI/O sum[0]:cur[0],unzip sum[0]:cur[0]\n这里将参数innodb_buffer_pool_instances设置为2，即数据库用户拥有两个缓冲池实例。通过命令SHOW ENGINE INNODB STATUS可以观察到每个缓冲池实例对象运行的状态，并且通过类似---BUFFER POOL 0的注释来表明是哪个缓冲池实例。\n从MySQL 5.6版本开始，还可以通过information_schema架构下的表INNODB_BUFFER_POOL_STATS来观察缓冲的状态，如运行下列命令可以看到各个缓冲池的使用状态：\nmysql＞SELECT POOL_ID,POOL_SIZE,\n-＞FREE_BUFFERS,DATABASE_PAGES\n-＞FROM INNODB_BUFFER_POOL_STATS\\G;\n***************************1.row***************************\nPOOL_ID:0\nPOOL_SIZE:65535\nFREE_BUFFERS:65451\nDATABASE_PAGES:84\n***************************2.row***************************\nPOOL_ID:1\nPOOL_SIZE:65536\nFREE_BUFFERS:65473\nDATABASE_PAGES:63\n2.LRU List、Free List和Flush List\n在前一小节中我们知道了缓冲池是一个很大的内存区域，其中存放各种类型的页。那么InnoDB存储引擎是怎么对这么大的内存区域进行管理的呢？这就是本小节要告诉读者的。\n通常来说，数据库中的缓冲池是通过LRU（Latest Recent Used，最近最少使用）算法来进行管理的。即最频繁使用的页在LRU列表的前端，而最少使用的页在LRU列表的尾端。当缓冲池不能存放新读取到的页时，将首先释放LRU列表中尾端的页。\n在InnoDB存储引擎中，缓冲池中页的大小默认为16KB，同样使用LRU算法对缓冲池进行管理。稍有不同的是InnoDB存储引擎对传统的LRU算法做了一些优化。在InnoDB的存储引擎中，LRU列表中还加入了midpoint位置。新读取到的页，虽然是最新访问的页，但并不是直接放入到LRU列表的首部，而是放入到LRU列表的midpoint位置。这个算法在InnoDB存储引擎下称为midpoint insertion strategy。在默认配置下，该位置在LRU列表长度的5/8处。midpoint位置可由参数innodb_old_blocks_pct控制，如：\nmysql＞SHOW VARIABLES LIKE'innodb_old_blocks_pct'\\G;\n***************************1.row***************************\nVariable_name:innodb_old_blocks_pct\nValue:37\n1 row in set(0.00 sec)\n从上面的例子可以看到，参数innodb_old_blocks_pct默认值为37，表示新读取的页插入到LRU列表尾端的37%的位置（差不多3/8的位置）。在InnoDB存储引擎中，把midpoint之后的列表称为old列表，之前的列表称为new列表。可以简单地理解为new列表中的页都是最为活跃的热点数据。\n那为什么不采用朴素的LRU算法，直接将读取的页放入到LRU列表的首部呢？这是因为若直接将读取到的页放入到LRU的首部，那么某些SQL操作可能会使缓冲池中的页被刷新出，从而影响缓冲池的效率。常见的这类操作为索引或数据的扫描操作。这类操作需要访问表中的许多页，甚至是全部的页，而这些页通常来说又仅在这次查询操作中需要，并不是活跃的热点数据。如果页被放入LRU列表的首部，那么非常可能将所需要的热点数据页从LRU列表中移除，而在下一次需要读取该页时，InnoDB存储引擎需要再次访问磁盘。\n为了解决这个问题，InnoDB存储引擎引入了另一个参数来进一步管理LRU列表，这个参数是innodb_old_blocks_time，用于表示页读取到mid位置后需要等待多久才会被加入到LRU列表的热端。因此当需要执行上述所说的SQL操作时，可以通过下面的方法尽可能使LRU列表中热点数据不被刷出。\nmysql＞SET GLOBAL innodb_old_blocks_time=1000;\nQuery OK,0 rows affected(0.00 sec)\n#data or index scan operation\n……\nmysql＞SET GLOBAL innodb_old_blocks_time=0;\nQuery OK,0 rows affected(0.00 sec)\n如果用户预估自己活跃的热点数据不止63%，那么在执行SQL语句前，还可以通过下面的语句来减少热点页可能被刷出的概率。\nmysql＞SET GLOBAL innodb_old_blocks_pct=20;\nQuery OK,0 rows affected(0.00 sec)\nLRU列表用来管理已经读取的页，但当数据库刚启动时，LRU列表是空的，即没有任何的页。这时页都存放在Free列表中。当需要从缓冲池中分页时，首先从Free列表中查找是否有可用的空闲页，若有则将该页从Free列表中删除，放入到LRU列表中。否则，根据LRU算法，淘汰LRU列表末尾的页，将该内存空间分配给新的页。当页从LRU列表的old部分加入到new部分时，称此时发生的操作为page made young，而因为innodb_old_blocks_time的设置而导致页没有从old部分移动到new部分的操作称为page not made young。可以通过命令SHOW ENGINE INNODB STATUS来观察LRU列表及Free列表的使用情况和运行状态。\nmysql＞SHOW ENGINE INNODB STATUS\\G;\n***************************1.row***************************\nType:InnoDB\nName:\nStatus:\n=====================================\n120725 22:04:25 INNODB MONITOR OUTPUT\n=====================================\nPer second averages calculated from the last 24 seconds\n……\nBuffer pool size 327679\nFree buffers 0\nDatabase pages 307717\nOld database pages 113570\nModified db pages 24673\nPending reads 0\nPending writes:LRU 0,flush list 0,single page 0\nPages made young 6448526,not young 0\n48.75 youngs/s,0.00 non-youngs/s\nPages read 5354420,created 239625,written 3486063\n55.68 reads/s,81.74 creates/s,955.88 writes/s\nBuffer pool hit rate 1000/1000,young-making rate 0/1000 not 0/1000\n……\n通过命令SHOW ENGINE INNODB STATUS可以看到：当前Buffer pool size共有327 679个页，即327679*16K，总共5GB的缓冲池。Free buffers表示当前Free列表中页的数量，Database pages表示LRU列表中页的数量。可能的情况是Free buffers与Database pages的数量之和不等于Buffer pool size。正如图2-2所示的那样，因为缓冲池中的页还可能会被分配给自适应哈希索引、Lock信息、Insert Buffer等页，而这部分页不需要LRU算法进行维护，因此不存在于LRU列表中。\npages made young显示了LRU列表中页移动到前端的次数，因为该服务器在运行阶段没有改变innodb_old_blocks_time的值，因此not young为0。youngs/s、non-youngs/s表示每秒这两类操作的次数。这里还有一个重要的观察变量——Buffer pool hit rate，表示缓冲池的命中率，这个例子中为100%，说明缓冲池运行状态非常良好。通常该值不应该小于95%。若发生Buffer pool hit rate的值小于95%这种情况，用户需要观察是否是由于全表扫描引起的LRU列表被污染的问题。\n注意　执行命令SHOW ENGINE INNODB STATUS显示的不是当前的状态，而是过去某个时间范围内InnoDB存储引擎的状态。从上面的例子可以发现，Per second averages calculated from the last 24 seconds代表的信息为过去24秒内的数据库状态。\n从InnoDB 1.2版本开始，还可以通过表INNODB_BUFFER_POOL_STATS来观察缓冲池的运行状态，如：\nmysql＞SELECT POOL_ID,HIT_RATE,\n-＞PAGES_MADE_YOUNG,PAGES_NOT_MADE_YOUNG\n-＞FROM information_schema.INNODB_BUFFER_POOL_STATS\\G;\n***************************1.row***************************\nPOOL_ID:0\nHIT_RATE:980\nPAGES_MADE_YOUNG:450\nPAGES_NOT_MADE_YOUNG:0\n此外，还可以通过表INNODB_BUFFER_PAGE_LRU来观察每个LRU列表中每个页的具体信息，例如通过下面的语句可以看到缓冲池LRU列表中SPACE为1的表的页类型：\nmysql＞SELECT TABLE_NAME,SPACE,PAGE_NUMBER,PAGE_TYPE\n-＞FROM INNODB_BUFFER_PAGE_LRU WHERE SPACE=1;\n+------------+-------+-------------+-------------------+\n|TABLE_NAME|SPACE|PAGE_NUMBER|PAGE_TYPE|\n+------------+-------+-------------+-------------------+\n|NULL|1|0|FILE_SPACE_HEADER|\n|NULL|1|1|IBUF_BITMAP|\n|NULL|1|2|INODE|\n|test/t|1|3|INDEX|\n+------------+-------+-------------+-------------------+\n4 rows in set(0.00 sec)\nInnoDB存储引擎从1.0.x版本开始支持压缩页的功能，即将原本16KB的页压缩为1KB、2KB、4KB和8KB。而由于页的大小发生了变化，LRU列表也有了些许的改变。对于非16KB的页，是通过unzip_LRU列表进行管理的。通过命令SHOW ENGINE INNODB STATUS可以观察到如下内容：\nmysql＞SHOW ENGINE INNODB STATUS\\G;\n……\nBuffer pool hit rate 999/1000,young-making rate 0/1000 not 0/1000\nPages read ahead 0.00/s,evicted without access 0.00/s,Random read ahead 0.00/s\nLRU len:1539,unzip_LRU len:156\nI/O sum[0]:cur[0],unzip sum[0]:cur[0]\n……\n可以看到LRU列表中一共有1539个页，而unzip_LRU列表中有156个页。这里需要注意的是，LRU中的页包含了unzip_LRU列表中的页。\n对于压缩页的表，每个表的压缩比率可能各不相同。可能存在有的表页大小为8KB，有的表页大小为2KB的情况。unzip_LRU是怎样从缓冲池中分配内存的呢？\n首先，在unzip_LRU列表中对不同压缩页大小的页进行分别管理。其次，通过伙伴算法进行内存的分配。例如对需要从缓冲池中申请页为4KB的大小，其过程如下：\n1）检查4KB的unzip_LRU列表，检查是否有可用的空闲页；\n2）若有，则直接使用；\n3）否则，检查8KB的unzip_LRU列表；\n4）若能够得到空闲页，将页分成2个4KB页，存放到4KB的unzip_LRU列表；\n5）若不能得到空闲页，从LRU列表中申请一个16KB的页，将页分为1个8KB的页、2个4KB的页，分别存放到对应的unzip_LRU列表中。\n同样可以通过information_schema架构下的表INNODB_BUFFER_PAGE_LRU来观察unzip_LRU列表中的页，如：\nmysql＞SELECT\n-＞TABLE_NAME,SPACE,PAGE_NUMBER,COMPRESSED_SIZE\n-＞FROM INNODB_BUFFER_PAGE_LRU\n-＞WHERE COMPRESSED_SIZE＜＞0;\n+------------+-------+-------------+-----------------+\n|TABLE_NAME|SPACE|PAGE_NUMBER|COMPRESSED_SIZE|\n+------------+-------+-------------+-----------------+\n|sbtest/t|9|134|8192|\n|sbtest/t|9|135|8192|\n|sbtest/t|9|96|8192|\n|sbtest/t|9|136|8192|\n|sbtest/t|9|32|8192|\n|sbtest/t|9|97|8192|\n|sbtest/t|9|137|8192|\n|sbtest/t|9|98|8192|\n……\n在LRU列表中的页被修改后，称该页为脏页（dirty page），即缓冲池中的页和磁盘上的页的数据产生了不一致。这时数据库会通过CHECKPOINT机制将脏页刷新回磁盘，而Flush列表中的页即为脏页列表。需要注意的是，脏页既存在于LRU列表中，也存在于Flush列表中。LRU列表用来管理缓冲池中页的可用性，Flush列表用来管理将页刷新回磁盘，二者互不影响。\n同LRU列表一样，Flush列表也可以通过命令SHOW ENGINE INNODB STATUS来查看，前面例子中Modified db pages 24673就显示了脏页的数量。information_schema架构下并没有类似INNODB_BUFFER_PAGE_LRU的表来显示脏页的数量及脏页的类型，但正如前面所述的那样，脏页同样存在于LRU列表中，故用户可以通过元数据表INNODB_BUFFER_PAGE_LRU来查看，唯一不同的是需要加入OLDEST_MODIFICATION大于0的SQL查询条件，如：\nmysql＞SELECT TABLE_NAME,SPACE,PAGE_NUMBER,PAGE_TYPE\n-＞FROM INNODB_BUFFER_PAGE_LRU\n-＞WHERE OLDEST_MODIFICATION＞0;\n+------------+-------+-------------+-------------------+\n|TABLE_NAME|SPACE|PAGE_NUMBER|PAGE_TYPE|\n+------------+-------+-------------+-------------------+\n|NULL|0|56|SYSTEM|\n|NULL|0|0|FILE_SPACE_HEADER|\n|test/t|1|3|INDEX|\n|NULL|0|320|INODE|\n|NULL|0|325|UNDO_LOG|\n+------------+-------+-------------+-------------------+\n5 rows in set(0.00 sec)\n可以看到当前共有5个脏页及它们对应的表和页的类型。TABLE_NAME为NULL表示该页属于系统表空间。\n3.重做日志缓冲\n从图2-2可以看到，InnoDB存储引擎的内存区域除了有缓冲池外，还有重做日志缓冲（redo log buffer）。InnoDB存储引擎首先将重做日志信息先放入到这个缓冲区，然后按一定频率将其刷新到重做日志文件。重做日志缓冲一般不需要设置得很大，因为一般情况下每一秒钟会将重做日志缓冲刷新到日志文件，因此用户只需要保证每秒产生的事务量在这个缓冲大小之内即可。该值可由配置参数innodb_log_buffer_size控制，默认为8MB：\nmysql＞SHOW VARIABLES LIKE'innodb_log_buffer_size'\\G;\n***************************1.row***************************\nVariable_name:innodb_log_buffer_size\nValue:8388608\n1 row in set(0.00 sec)\n在通常情况下，8MB的重做日志缓冲池足以满足绝大部分的应用，因为重做日志在下列三种情况下会将重做日志缓冲中的内容刷新到外部磁盘的重做日志文件中。\n❑Master Thread每一秒将重做日志缓冲刷新到重做日志文件；\n❑每个事务提交时会将重做日志缓冲刷新到重做日志文件；\n❑当重做日志缓冲池剩余空间小于1/2时，重做日志缓冲刷新到重做日志文件。\n4.额外的内存池\n额外的内存池通常被DBA忽略，他们认为该值并不十分重要，事实恰恰相反，该值同样十分重要。在InnoDB存储引擎中，对内存的管理是通过一种称为内存堆（heap）的方式进行的。在对一些数据结构本身的内存进行分配时，需要从额外的内存池中进行申请，当该区域的内存不够时，会从缓冲池中进行申请。例如，分配了缓冲池（innodb_buffer_pool），但是每个缓冲池中的帧缓冲（frame buffer）还有对应的缓冲控制对象（buffer control block），这些对象记录了一些诸如LRU、锁、等待等信息，而这个对象的内存需要从额外内存池中申请。因此，在申请了很大的InnoDB缓冲池时，也应考虑相应地增加这个值。\n2.4　Checkpoint技术\n前面已经讲到了，缓冲池的设计目的为了协调CPU速度与磁盘速度的鸿沟。因此页的操作首先都是在缓冲池中完成的。如果一条DML语句，如Update或Delete改变了页中的记录，那么此时页是脏的，即缓冲池中的页的版本要比磁盘的新。数据库需要将新版本的页从缓冲池刷新到磁盘。\n倘若每次一个页发生变化，就将新页的版本刷新到磁盘，那么这个开销是非常大的。若热点数据集中在某几个页中，那么数据库的性能将变得非常差。同时，如果在从缓冲池将页的新版本刷新到磁盘时发生了宕机，那么数据就不能恢复了。为了避免发生数据丢失的问题，当前事务数据库系统普遍都采用了Write Ahead Log策略，即当事务提交时，先写重做日志，再修改页。当由于发生宕机而导致数据丢失时，通过重做日志来完成数据的恢复。这也是事务ACID中D（Durability持久性）的要求。\n思考下面的场景，如果重做日志可以无限地增大，同时缓冲池也足够大，能够缓冲所有数据库的数据，那么是不需要将缓冲池中页的新版本刷新回磁盘。因为当发生宕机时，完全可以通过重做日志来恢复整个数据库系统中的数据到宕机发生的时刻。但是这需要两个前提条件：\n❑缓冲池可以缓存数据库中所有的数据；\n❑重做日志可以无限增大。\n对于第一个前提条件，有经验的用户都知道，当数据库刚开始创建时，表中没有任何数据。缓冲池的确可以缓存所有的数据库文件。然而随着市场的推广，用户的增加，产品越来越受到关注，使用量也越来越大。这时负责后台存储的数据库的容量必定会不断增大。当前3TB的MySQL数据库已并不少见，但是3 TB的内存却非常少见。目前Oracle Exadata旗舰数据库一体机也就只有2 TB的内存。因此第一个假设对于生产环境应用中的数据库是很难得到保证的。\n再来看第二个前提条件：重做日志可以无限增大。也许是可以的，但是这对成本的要求太高，同时不便于运维。DBA或SA不能知道什么时候重做日志是否已经接近于磁盘可使用空间的阈值，并且要让存储设备支持可动态扩展也是需要一定的技巧和设备支持的。\n好的，即使上述两个条件都满足，那么还有一个情况需要考虑：宕机后数据库的恢复时间。当数据库运行了几个月甚至几年时，这时发生宕机，重新应用重做日志的时间会非常久，此时恢复的代价也会非常大。\n因此Checkpoint（检查点）技术的目的是解决以下几个问题：\n❑缩短数据库的恢复时间；\n❑缓冲池不够用时，将脏页刷新到磁盘；\n❑重做日志不可用时，刷新脏页。\n当数据库发生宕机时，数据库不需要重做所有的日志，因为Checkpoint之前的页都已经刷新回磁盘。故数据库只需对Checkpoint后的重做日志进行恢复。这样就大大缩短了恢复的时间。\n此外，当缓冲池不够用时，根据LRU算法会溢出最近最少使用的页，若此页为脏页，那么需要强制执行Checkpoint，将脏页也就是页的新版本刷回磁盘。\n重做日志出现不可用的情况是因为当前事务数据库系统对重做日志的设计都是循环使用的，并不是让其无限增大的，这从成本及管理上都是比较困难的。重做日志可以被重用的部分是指这些重做日志已经不再需要，即当数据库发生宕机时，数据库恢复操作不需要这部分的重做日志，因此这部分就可以被覆盖重用。若此时重做日志还需要使用，那么必须强制产生Checkpoint，将缓冲池中的页至少刷新到当前重做日志的位置。\n对于InnoDB存储引擎而言，其是通过LSN（Log Sequence Number）来标记版本的。而LSN是8字节的数字，其单位是字节。每个页有LSN，重做日志中也有LSN，Checkpoint也有LSN。可以通过命令SHOW ENGINE INNODB STATUS来观察：\nmysql＞SHOW ENGINE INNODB STATUS\\G;\n......\n---\nLOG\n---\nLog sequence number 92561351052\nLog flushed up to 92561351052\nLast checkpoint at 92561351052\n......\n在InnoDB存储引擎中，Checkpoint发生的时间、条件及脏页的选择等都非常复杂。而Checkpoint所做的事情无外乎是将缓冲池中的脏页刷回到磁盘。不同之处在于每次刷新多少页到磁盘，每次从哪里取脏页，以及什么时间触发Checkpoint。在InnoDB存储引擎内部，有两种Checkpoint，分别为：\n❑Sharp Checkpoint\n❑Fuzzy Checkpoint\nSharp Checkpoint发生在数据库关闭时将所有的脏页都刷新回磁盘，这是默认的工作方式，即参数innodb_fast_shutdown=1。\n但是若数据库在运行时也使用Sharp Checkpoint，那么数据库的可用性就会受到很大的影响。故在InnoDB存储引擎内部使用Fuzzy Checkpoint进行页的刷新，即只刷新一部分脏页，而不是刷新所有的脏页回磁盘。\n这里笔者进行了概括，在InnoDB存储引擎中可能发生如下几种情况的Fuzzy Checkpoint：\n❑Master Thread Checkpoint\n❑FLUSH_LRU_LIST Checkpoint\n❑Async/Sync Flush Checkpoint\n❑Dirty Page too much Checkpoint\n对于Master Thread（2.5节会详细介绍各个版本中Master Thread的实现）中发生的Checkpoint，差不多以每秒或每十秒的速度从缓冲池的脏页列表中刷新一定比例的页回磁盘。这个过程是异步的，即此时InnoDB存储引擎可以进行其他的操作，用户查询线程不会阻塞。\nFLUSH_LRU_LIST Checkpoint是因为InnoDB存储引擎需要保证LRU列表中需要有差不多100个空闲页可供使用。在InnoDB1.1.x版本之前，需要检查LRU列表中是否有足够的可用空间操作发生在用户查询线程中，显然这会阻塞用户的查询操作。倘若没有100个可用空闲页，那么InnoDB存储引擎会将LRU列表尾端的页移除。如果这些页中有脏页，那么需要进行Checkpoint，而这些页是来自LRU列表的，因此称为FLUSH_LRU_LIST Checkpoint。\n而从MySQL 5.6版本，也就是InnoDB1.2.x版本开始，这个检查被放在了一个单独的Page Cleaner线程中进行，并且用户可以通过参数innodb_lru_scan_depth控制LRU列表中可用页的数量，该值默认为1024，如：\nmysql＞SHOW VARIABLES LIKE'innodb_lru_scan_depth'\\G;\n***************************1.row***************************\nVariable_name:innodb_lru_scan_depth\nValue:1024\n1 row in set(0.00 sec)\nAsync/Sync Flush Checkpoint指的是重做日志文件不可用的情况，这时需要强制将一些页刷新回磁盘，而此时脏页是从脏页列表中选取的。若将已经写入到重做日志的LSN记为redo_lsn，将已经刷新回磁盘最新页的LSN记为checkpoint_lsn，则可定义：\ncheckpoint_age=redo_lsn-checkpoint_lsn\n再定义以下的变量：\nasync_water_mark=75%*total_redo_log_file_size\nsync_water_mark=90%*total_redo_log_file_size\n若每个重做日志文件的大小为1GB，并且定义了两个重做日志文件，则重做日志文件的总大小为2GB。那么async_water_mark=1.5GB，sync_water_mark=1.8GB。则：\n❑当checkpoint_age＜async_water_mark时，不需要刷新任何脏页到磁盘；\n❑当async_water_mark＜checkpoint_age＜sync_water_mark时触发Async Flush，从Flush列表中刷新足够的脏页回磁盘，使得刷新后满足checkpoint_age＜async_water_mark；\n❑checkpoint_age＞sync_water_mark这种情况一般很少发生，除非设置的重做日志文件太小，并且在进行类似LOAD DATA的BULK INSERT操作。此时触发Sync Flush操作，从Flush列表中刷新足够的脏页回磁盘，使得刷新后满足checkpoint_age＜async_water_mark。\n可见，Async/Sync Flush Checkpoint是为了保证重做日志的循环使用的可用性。在InnoDB 1.2.x版本之前，Async Flush Checkpoint会阻塞发现问题的用户查询线程，而Sync Flush Checkpoint会阻塞所有的用户查询线程，并且等待脏页刷新完成。从InnoDB 1.2.x版本开始——也就是MySQL 5.6版本，这部分的刷新操作同样放入到了单独的Page Cleaner Thread中，故不会阻塞用户查询线程。\nMySQL官方版本并不能查看刷新页是从Flush列表中还是从LRU列表中进行Checkpoint的，也不知道因为重做日志而产生的Async/Sync Flush的次数。但是InnoSQL版本提供了方法，可以通过命令SHOW ENGINE INNODB STATUS来观察，如：\nmysql＞SHOW ENGINE INNODB STATUS\\G;\n***************************1.row***************************\nType:InnoDB\n……\nLRU len:112902,unzip_LRU len:0\nI/O sum[0]:cur[0],unzip sum[0]:cur[0]\nAsync Flush:0,Sync Flush:0,LRU List Flush:0,Flush List Flush:111736\n……\n1 row in set(0.01 sec)\n根据上述的信息，还可以对InnoDB存储引擎做更为深入的调优，这部分将在第9章中讲述。\n最后一种Checkpoint的情况是Dirty Page too much，即脏页的数量太多，导致InnoDB存储引擎强制进行Checkpoint。其目的总的来说还是为了保证缓冲池中有足够可用的页。其可由参数innodb_max_dirty_pages_pct控制：\nmysql＞SHOW VARIABLES LIKE'innodb_max_dirty_pages_pct'\\G;\n***************************1.row***************************\nVariable_name:innodb_max_dirty_pages_pct\nValue:75\n1 row in set(0.00 sec)\ninnodb_max_dirty_pages_pct值为75表示，当缓冲池中脏页的数量占据75%时，强制进行Checkpoint，刷新一部分的脏页到磁盘。在InnoDB 1.0.x版本之前，该参数默认值为90，之后的版本都为75。\n2.5　Master Thread工作方式\n在2.3节中我们知道了，InnoDB存储引擎的主要工作都是在一个单独的后台线程Master Thread中完成的，这一节将具体解释该线程的具体实现及该线程可能存在的问题。\n2.5.1　InnoDB 1.0.x版本之前的Master Thread\nMaster Thread具有最高的线程优先级别。其内部由多个循环（loop）组成：主循环（loop）、后台循环（backgroup loop）、刷新循环（flush loop）、暂停循环（suspend loop）。Master Thread会根据数据库运行的状态在loop、background loop、flush loop和suspendloop中进行切换。\nLoop被称为主循环，因为大多数的操作是在这个循环中，其中有两大部分的操作——每秒钟的操作和每10秒的操作。伪代码如下：\nvoid master_thread(){\nloop：\nfor(int i=0;i＜10;i++){\ndo thing once per second\nsleep 1 second if necessary\n}\ndo things once per ten seconds\ngoto loop;\n}\n可以看到，loop循环通过thread sleep来实现，这意味着所谓的每秒一次或每10秒一次的操作是不精确的。在负载很大的情况下可能会有延迟（delay），只能说大概在这个频率下。当然，InnoDB源代码中还通过了其他的方法来尽量保证这个频率。\n每秒一次的操作包括：\n❑日志缓冲刷新到磁盘，即使这个事务还没有提交（总是）；\n❑合并插入缓冲（可能）；\n❑至多刷新100个InnoDB的缓冲池中的脏页到磁盘（可能）；\n❑如果当前没有用户活动，则切换到background loop（可能）。\n即使某个事务还没有提交，InnoDB存储引擎仍然每秒会将重做日志缓冲中的内容刷新到重做日志文件。这一点是必须要知道的，因为这可以很好地解释为什么再大的事务提交（commit）的时间也是很短的。\n合并插入缓冲（Insert Buffer）并不是每秒都会发生的。InnoDB存储引擎会判断当前一秒内发生的IO次数是否小于5次，如果小于5次，InnoDB认为当前的IO压力很小，可以执行合并插入缓冲的操作。\n同样，刷新100个脏页也不是每秒都会发生的。InnoDB存储引擎通过判断当前缓冲池中脏页的比例（buf_get_modified_ratio_pct）是否超过了配置文件中innodb_max_dirty_pages_pct这个参数（默认为90，代表90%），如果超过了这个阈值，InnoDB存储引擎认为需要做磁盘同步的操作，将100个脏页写入磁盘中。\n总结上述操作，伪代码可以进一步具体化，如下所示：\nvoid master_thread(){\ngoto loop;\nloop：\nfor(int i=0;i＜10;i++){\nthread_sleep(1)//sleep 1 second\ndo log buffer flush to disk\nif(last_one_second_ios＜5)\ndo merge at most 5 insert buffer\nif(buf_get_modified_ratio_pct＞innodb_max_dirty_pages_pct)\ndo buffer pool flush 100 dirty page\nif(no user activity)\ngoto backgroud loop\n}\ndo things once per ten seconds\nbackground loop:\ndo something\ngoto loop:\n}\n接着来看每10秒的操作，包括如下内容：\n❑刷新100个脏页到磁盘（可能的情况下）；\n❑合并至多5个插入缓冲（总是）；\n❑将日志缓冲刷新到磁盘（总是）；\n❑删除无用的Undo页（总是）；\n❑刷新100个或者10个脏页到磁盘（总是）。\n在以上的过程中，InnoDB存储引擎会先判断过去10秒之内磁盘的IO操作是否小于200次，如果是，InnoDB存储引擎认为当前有足够的磁盘IO操作能力，因此将100个脏页刷新到磁盘。接着，InnoDB存储引擎会合并插入缓冲。不同于每秒一次操作时可能发生的合并插入缓冲操作，这次的合并插入缓冲操作总会在这个阶段进行。之后，InnoDB存储引擎会再进行一次将日志缓冲刷新到磁盘的操作。这和每秒一次时发生的操作是一样的。\n接着InnoDB存储引擎会进行一步执行full purge操作，即删除无用的Undo页。对表进行update、delete这类操作时，原先的行被标记为删除，但是因为一致性读（consistent read）的关系，需要保留这些行版本的信息。但是在full purge过程中，InnoDB存储引擎会判断当前事务系统中已被删除的行是否可以删除，比如有时候可能还有查询操作需要读取之前版本的undo信息，如果可以删除，InnoDB会立即将其删除。从源代码中可以发现，InnoDB存储引擎在执行full purge操作时，每次最多尝试回收20个undo页。\n然后，InnoDB存储引擎会判断缓冲池中脏页的比例（buf_get_modified_ratio_pct），如果有超过70%的脏页，则刷新100个脏页到磁盘，如果脏页的比例小于70%，则只需刷新10%的脏页到磁盘。\n现在我们可以完整地把主循环（main loop）的伪代码写出来了，内容如下：\nvoid master_thread(){\ngoto loop;\nloop：\nfor(int i=0;i＜10;i++){\nthread_sleep(1)//sleep 1 second\ndo log buffer flush to disk\nif(last_one_second_ios＜5)\ndo merge at most 5 insert buffer\nif(buf_get_modified_ratio_pct＞innodb_max_dirty_pages_pct)\ndo buffer pool flush 100 dirty page\nif(no user activity)\ngoto backgroud loop\n}\nif(last_ten_second_ios＜200)\ndo buffer pool flush 100 dirty page\ndo merge at most 5 insert buffer\ndo log buffer flush to disk\ndo full purge\nif(buf_get_modified_ratio_pct＞70%)\ndo buffer pool flush 100 dirty page\nelse\nbuffer pool flush 10 dirty page\ngoto loop\nbackground loop:\ndo something\ngoto loop:\n}\n接着来看background loop，若当前没有用户活动（数据库空闲时）或者数据库关闭（shutdown），就会切换到这个循环。background loop会执行以下操作：\n❑删除无用的Undo页（总是）；\n❑合并20个插入缓冲（总是）；\n❑跳回到主循环（总是）；\n❑不断刷新100个页直到符合条件（可能，跳转到flush loop中完成）。\n若flush loop中也没有什么事情可以做了，InnoDB存储引擎会切换到suspend__loop，将Master Thread挂起，等待事件的发生。若用户启用（enable）了InnoDB存储引擎，却没有使用任何InnoDB存储引擎的表，那么Master Thread总是处于挂起的状态。\n最后，Master Thread完整的伪代码如下：\nvoid master_thread(){\ngoto loop;\nloop：\nfor(int i=0;i＜10;i++){\nthread_sleep(1)//sleep 1 second\ndo log buffer flush to disk\nif(last_one_second_ios＜5)\ndo merge at most 5 insert buffer\nif(buf_get_modified_ratio_pct＞innodb_max_dirty_pages_pct)\ndo buffer pool flush 100 dirty page\nif(no user activity)\ngoto backgroud loop\n}\nif(last_ten_second_ios＜200)\ndo buffer pool flush 100 dirty page\ndo merge at most 5 insert buffer\ndo log buffer flush to disk\ndo full purge\nif(buf_get_modified_ratio_pct＞70%)\ndo buffer pool flush 100 dirty page\nelse\nbuffer pool flush 10 dirty page\ngoto loop\nbackground loop:\ndo full purge\ndo merge 20 insert buffer\nif not idle:\ngoto loop:\nelse:\ngoto flush loop\nflush loop:\ndo buffer pool flush 100 dirty page\nif(buf_get_modified_ratio_pct＞innodb_max_dirty_pages_pct)\ngoto flush loop\ngoto suspend loop\nsuspend loop:\nsuspend_thread()\nwaiting event\ngoto loop;\n}\n2.5.2　InnoDB1.2.x版本之前的Master Thread\n在了解了1.0.x版本之前的Master Thread的具体实现过程后，细心的读者会发现InnoDB存储引擎对于IO其实是有限制的，在缓冲池向磁盘刷新时其实都做了一定的硬编码（hard coding）。在磁盘技术飞速发展的今天，当固态磁盘（SSD）出现时，这种规定在很大程度上限制了InnoDB存储引擎对磁盘IO的性能，尤其是写入性能。\n从前面的伪代码来看，无论何时，InnoDB存储引擎最大只会刷新100个脏页到磁盘，合并20个插入缓冲。如果是在写入密集的应用程序中，每秒可能会产生大于100个的脏页，如果是产生大于20个插入缓冲的情况，Master Thread似乎会“忙不过来”，或者说它总是做得很慢。即使磁盘能在1秒内处理多于100个页的写入和20个插入缓冲的合并，但是由于hard coding，Master Thread也只会选择刷新100个脏页和合并20个插入缓冲。同时，当发生宕机需要恢复时，由于很多数据还没有刷新回磁盘，会导致恢复的时间可能需要很久，尤其是对于insert buffer来说。\n这个问题最初由Google的工程师Mark Callaghan提出，之后InnoDB官方对其进行了修正并发布了补丁（patch）。InnoDB存储引擎的开发团队参考了Google的patch，提供了类似的方法来修正该问题。因此InnoDB Plugin（从InnoDB1.0.x版本开始）提供了参数innodb_io_capacity，用来表示磁盘IO的吞吐量，默认值为200。对于刷新到磁盘页的数量，会按照innodb_io_capacity的百分比来进行控制。规则如下：\n❑在合并插入缓冲时，合并插入缓冲的数量为innodb_io_capacity值的5%；\n❑在从缓冲区刷新脏页时，刷新脏页的数量为innodb_io_capacity。\n若用户使用了SSD类的磁盘，或者将几块磁盘做了RAID，当存储设备拥有更高的IO速度时，完全可以将innodb_io_capacity的值调得再高点，直到符合磁盘IO的吞吐量为止。\n另一个问题是，参数innodb_max_dirty_pages_pct默认值的问题，在InnoDB 1.0.x版本之前，该值的默认为90，意味着脏页占缓冲池的90%。但是该值“太大”了，因为InnoDB存储引擎在每秒刷新缓冲池和flush loop时会判断这个值，如果该值大于innodb_max_dirty_pages_pct，才刷新100个脏页，如果有很大的内存，或者数据库服务器的压力很大，这时刷新脏页的速度反而会降低。同样，在数据库的恢复阶段可能需要更多的时间。\n[1]\nInnoDB 1.0.x版本带来的另一个参数是innodb_adaptive_flushing（自适应地刷新），该值影响每秒刷新脏页的数量。原来的刷新规则是：脏页在缓冲池所占的比例小于innodb_max_dirty_pages_pct时，不刷新脏页；大于innodb_max_dirty_pages_pct时，刷新100个脏页。随着innodb_adaptive_flushing参数的引入，InnoDB存储引擎会通过一个名为buf_flush_get_desired_flush_rate的函数来判断需要刷新脏页最合适的数量。粗略地翻阅源代码后发现buf_flush_get_desired_flush_rate通过判断产生重做日志（redo log）的速度来决定最合适的刷新脏页数量。因此，当脏页的比例小于innodb_max_dirty_pages_pct时，也会刷新一定量的脏页。\n还有一个改变是：之前每次进行full purge操作时，最多回收20个Undo页，从InnoDB 1.0.x版本开始引入了参数innodb_purge_batch_size，该参数可以控制每次full purge回收的Undo页的数量。该参数的默认值为20，并可以动态地对其进行修改，具体如下：\nmysql＞SHOW VARIABLES LIKE'innodb_purge_batch_size'\\G;\n***************************1.row***************************\nVariable_name:innodb_purge_batch_size\nValue:20\nmysql＞SET GLOBAL innodb_purge_batch_size=50;\nQuery OK,0 rows affected(0.00 sec)\n通过上述的讨论和解释我们知道，从InnoDB 1.0.x版本开始，Master Thread的伪代码必将有所改变，最终变成：\nvoid master_thread(){\ngoto loop;\nloop：\nfor(int i=0;i＜10;i++){\nthread_sleep(1)//sleep 1 second\ndo log buffer flush to disk\nif(last_one_second_ios＜5%innodb_io_capacity)\ndo merge 5%innodb_io_capacity insert buffer\nif(buf_get_modified_ratio_pct＞innodb_max_dirty_pages_pct)\ndo buffer pool flush 100%innodb_io_capacity dirty page\nelse if enable adaptive flush\ndo buffer pool flush desired amount dirty page\nif(no user activity)\ngoto backgroud loop\n}\nif(last_ten_second_ios＜innodb_io_capacity)\ndo buffer pool flush 100%innodb_io_capacity dirty page\ndo merge 5%innodb_io_capacity insert buffer\ndo log buffer flush to disk\ndo full purge\nif(buf_get_modified_ratio_pct＞70%)\ndo buffer pool flush 100%innodb_io_capacity dirty page\nelse\ndobuffer pool flush 10%innodb_io_capacity dirty page\ngoto loop\nbackground loop:\ndo full purge\ndo merge 100%innodb_io_capacity insert buffer\nif not idle:\ngoto loop:\nelse:\ngoto flush loop\nflush loop:\ndo buffer pool flush 100%innodb_io_capacity dirty page\nif(buf_get_modified_ratio_pct＞innodb_max_dirty_pages_pct)\ngo to flush loop\ngoto suspend loop\nsuspend loop:\nsuspend_thread()\nwaiting event\ngoto loop;\n}\n很多测试都显示，InnoDB 1.0.x版本在性能方面取得了极大的提高，其实这和前面提到的Master Thread的改动是密不可分的，因为InnoDB存储引擎的核心操作大部分都集中在Master Thread后台线程中。\n从InnoDB 1.0.x开始，命令SHOW ENGINE INNODB STATUS可以查看当前Master Thread的状态信息，如下所示：\nmysql＞SHOW ENGINE INNODB STATUS\\G;\n***************************1.row***************************\nType:InnoDB\nName:\nStatus:\n=====================================\n090921 14:24:56 INNODB MONITOR OUTPUT\n=====================================\nPer second averages calculated from the last 6 seconds\n----------\nBACKGROUND THREAD\n----------\nsrv_master_thread loops:45 1_second,45 sleeps,4 10_second,6 background,6 flush\nsrv_master_thread log flush and writes:45 log writes only:69\n……\n这里可以看到主循环进行了45次，每秒挂起（sleep）的操作进行了45次（说明负载不是很大），10秒一次的活动进行了4次，符合1∶10。background loop进行了6次，flush loop也进行了6次。因为当前这台服务器的压力很小，所以能在理论值上运行。如果是在一台压力很大的MySQL数据库服务器上，看到的可能会是下面的情景：\nmysql＞show engine innodb status\\G;\n***************************1.row***************************\nType:InnoDB\nName:\nStatus:\n=====================================\n091009 10:14:34 INNODB MONITOR OUTPUT\n=====================================\nPer second averages calculated from the last 42 seconds\n----------\nBACKGROUND THREAD\n----------\nsrv_master_thread loops:2188 1_second,1537 sleeps,218 10_second,2 background,2 flush\nsrv_master_thread log flush and writes:1777 log writes only:5816\n……\n可以看到当前主循环运行了2188次，但是循环中的每秒挂起（sleep）的操作只运行了1537次。这是因为InnoDB对其内部进行了一些优化，当压力大时并不总是等待1秒。因此，并不能认为1_second和sleeps的值总是相等的。在某些情况下，可以通过两者之间差值的比较来反映当前数据库的负载压力。\n[1]\n2.5.3　InnoDB 1.2.x版本的Master Thread\n在InnoDB 1.2.x版本中再次对Master Thread进行了优化，由此也可以看出Master Thread对性能所起到的关键作用。在InnoDB 1.2.x版本中，Master Thread的伪代码如下：\nif InnoDB is idle\nsrv_master_do_idle_tasks();\nelse\nsrv_master_do_active_tasks();\n其中srv_master_do_idle_tasks()就是之前版本中每10秒的操作，srv_master_do_active_tasks()处理的是之前每秒中的操作。同时对于刷新脏页的操作，从Master Thread线程分离到一个单独的Page Cleaner Thread，从而减轻了Master Thread的工作，同时进一步提高了系统的并发性。\n2.6　InnoDB关键特性\nInnoDB存储引擎的关键特性包括：\n❑插入缓冲（Insert Buffer）\n❑两次写（Double Write）\n❑自适应哈希索引（Adaptive Hash Index）\n❑异步IO（Async IO）\n❑刷新邻接页（Flush Neighbor Page）\n上述这些特性为InnoDB存储引擎带来更好的性能以及更高的可靠性。\n2.6.1　插入缓冲\n1.Insert Buffer\nInsert Buffer可能是InnoDB存储引擎关键特性中最令人激动与兴奋的一个功能。不过这个名字可能会让人认为插入缓冲是缓冲池中的一个组成部分。其实不然，InnoDB缓冲池中有Insert Buffer信息固然不错，但是Insert Buffer和数据页一样，也是物理页的一个组成部分。\n在InnoDB存储引擎中，主键是行唯一的标识符。通常应用程序中行记录的插入顺序是按照主键递增的顺序进行插入的。因此，插入聚集索引（Primary Key）一般是顺序的，不需要磁盘的随机读取。比如按下列SQL定义表：\nCREATE TABLE t(\na INT AUTO_INCREMENT,\nb VARCHAR(30),\nPRIMARY KEY(a)\n);\n其中a列是自增长的，若对a列插入NULL值，则由于其具有AUTO_INCREMENT属性，其值会自动增长。同时页中的行记录按a的值进行顺序存放。在一般情况下，不需要随机读取另一个页中的记录。因此，对于这类情况下的插入操作，速度是非常快的。\n注意　并不是所有的主键插入都是顺序的。若主键类是UUID这样的类，那么插入和辅助索引一样，同样是随机的。即使主键是自增类型，但是插入的是指定的值，而不是NULL值，那么同样可能导致插入并非连续的情况。\n但是不可能每张表上只有一个聚集索引，更多情况下，一张表上有多个非聚集的辅助索引（secondary index）。比如，用户需要按照b这个字段进行查找，并且b这个字段不是唯一的，即表是按如下的SQL语句定义的：\nCREATE TABLE t(\na INT AUTO_INCREMENT,\nb VARCHAR(30),\nPRIMARY KEY(a),\nkey(b)\n);\n在这样的情况下产生了一个非聚集的且不是唯一的索引。在进行插入操作时，数据页的存放还是按主键a进行顺序存放的，但是对于非聚集索引叶子节点的插入不再是顺序的了，这时就需要离散地访问非聚集索引页，由于随机读取的存在而导致了插入操作性能下降。当然这并不是这个b字段上索引的错误，而是因为B+树的特性决定了非聚集索引插入的离散性。\n需要注意的是，在某些情况下，辅助索引的插入依然是顺序的，或者说是比较顺序的，比如用户购买表中的时间字段。在通常情况下，用户购买时间是一个辅助索引，用来根据时间条件进行查询。但是在插入时却是根据时间的递增而插入的，因此插入也是“较为”顺序的。\nInnoDB存储引擎开创性地设计了Insert Buffer，对于非聚集索引的插入或更新操作，不是每一次直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，若在，则直接插入；若不在，则先放入到一个Insert Buffer对象中，好似欺骗。数据库这个非聚集的索引已经插到叶子节点，而实际并没有，只是存放在另一个位置。然后再以一定的频率和情况进行Insert Buffer和辅助索引页子节点的merge（合并）操作，这时通常能将多个插入合并到一个操作中（因为在一个索引页中），这就大大提高了对于非聚集索引插入的性能。\n然而Insert Buffer的使用需要同时满足以下两个条件：\n❑索引是辅助索引（secondary index）；\n❑索引不是唯一（unique）的。\n当满足以上两个条件时，InnoDB存储引擎会使用Insert Buffer，这样就能提高插入操作的性能了。不过考虑这样一种情况：应用程序进行大量的插入操作，这些都涉及了不唯一的非聚集索引，也就是使用了Insert Buffer。若此时MySQL数据库发生了宕机，这时势必有大量的Insert Buffer并没有合并到实际的非聚集索引中去。因此这时恢复可能需要很长的时间，在极端情况下甚至需要几个小时。\n辅助索引不能是唯一的，因为在插入缓冲时，数据库并不去查找索引页来判断插入的记录的唯一性。如果去查找肯定又会有离散读取的情况发生，从而导致Insert Buffer失去了意义。\n用户可以通过命令SHOW ENGINE INNODB STATUS来查看插入缓冲的信息：\nmysql＞SHOW ENGINE INNODB STATUS\\G;\n***************************1.row***************************\nType:InnoDB\nName:\nStatus:\n=====================================\n100727 22:21:48 INNODB MONITOR OUTPUT\n=====================================\nPer second averages calculated from the last 44 seconds\n……\n-------------------------------------\nINSERT BUFFER AND ADAPTIVE HASH INDEX\n-------------------------------------\nIbuf:size 7545,free list len 3790,seg size 11336,\n8075308 inserts,7540969 merged recs,2246304 merges\n……\n----------------------------\nEND OF INNODB MONITOR OUTPUT\n============================\n1 row in set(0.00 sec)\nseg size显示了当前Insert Buffer的大小为11336×16KB，大约为177MB；free list len代表了空闲列表的长度；size代表了已经合并记录页的数量。而黑体部分的第2行可能是用户真正关心的，因为它显示了插入性能的提高。Inserts代表了插入的记录数；merged recs代表了合并的插入记录数量；merges代表合并的次数，也就是实际读取页的次数。merges:merged recs大约为1∶3，代表了插入缓冲将对于非聚集索引页的离散IO逻辑请求大约降低了2/3。\n正如前面所说的，目前Insert Buffer存在一个问题是：在写密集的情况下，插入缓冲会占用过多的缓冲池内存（innodb_buffer_pool），默认最大可以占用到1/2的缓冲池内存。以下是InnoDB存储引擎源代码中对于insert buffer的初始化操作：\n/**Buffer pool size per the maximum insert buffer size*/\n#define IBUF_POOL_SIZE_PER_MAX_SIZE 2\nibuf-＞max_size=buf_pool_get_curr_size()/UNIV_PAGE_SIZE\n/IBUF_POOL_SIZE_PER_MAX_SIZE;\n这对于其他的操作可能会带来一定的影响。Percona上发布一些patch来修正插入缓冲占用太多缓冲池内存的情况，具体可以到Percona官网进行查找。简单来说，修改IBUF_POOL_SIZE_PER_MAX_SIZE就可以对插入缓冲的大小进行控制。比如将IBUF_POOL_SIZE_PER_MAX_SIZE改为3，则最大只能使用1/3的缓冲池内存。\n2.Change Buffer\nInnoDB从1.0.x版本开始引入了Change Buffer，可将其视为Insert Buffer的升级。从这个版本开始，InnoDB存储引擎可以对DML操作——INSERT、DELETE、UPDATE都进行缓冲，他们分别是：Insert Buffer、Delete Buffer、Purge buffer。\n当然和之前Insert Buffer一样，Change Buffer适用的对象依然是非唯一的辅助索引。\n对一条记录进行UPDATE操作可能分为两个过程：\n❑将记录标记为已删除；\n❑真正将记录删除。\n因此Delete Buffer对应UPDATE操作的第一个过程，即将记录标记为删除。Purge Buffer对应UPDATE操作的第二个过程，即将记录真正的删除。同时，InnoDB存储引擎提供了参数innodb_change_buffering，用来开启各种Buffer的选项。该参数可选的值为：inserts、deletes、purges、changes、all、none。inserts、deletes、purges就是前面讨论过的三种情况。changes表示启用inserts和deletes，all表示启用所有，none表示都不启用。该参数默认值为all。\n从InnoDB 1.2.x版本开始，可以通过参数innodb_change_buffer_max_size来控制Change Buffer最大使用内存的数量：\nmysql＞SHOW VARIABLES LIKE'innodb_change_buffer_max_size'\\G;\n***************************1.row***************************\nVariable_name:innodb_change_buffer_max_size\nValue:25\n1 row in set(0.00 sec)\ninnodb_change_buffer_max_size值默认为25，表示最多使用1/4的缓冲池内存空间。而需要注意的是，该参数的最大有效值为50。\n在MySQL 5.5版本中通过命令SHOW ENGINE INNODB STATUS，可以观察到类似如下的内容：\nmysql＞SHOW ENGINE INNODB STATUS\\G;\n***************************1.row***************************\nType:InnoDB\n……\n-------------------------------------\nINSERT BUFFER AND ADAPTIVE HASH INDEX\n-------------------------------------\nIbuf:size 1,free list len 34397,seg size 34399,10875 merges\nmerged operations:\ninsert 20462,delete mark 20158,delete 4215\ndiscarded operations:\ninsert 0,delete mark 0,delete 0\n……\n可以看到这里显示了merged operations和discarded operation，并且下面具体显示Change Buffer中每个操作的次数。insert表示Insert Buffer；delete mark表示Delete Buffer；delete表示Purge Buffer；discarded operations表示当Change Buffer发生merge时，表已经被删除，此时就无需再将记录合并（merge）到辅助索引中了。\n3.Insert Buffer的内部实现\n通过前一个小节读者应该已经知道了Insert Buffer的使用场景，即非唯一辅助索引的插入操作。但是对于Insert Buffer具体是什么，以及内部怎么实现可能依然模糊，这正是本节所要阐述的内容。\n可能令绝大部分用户感到吃惊的是，Insert Buffer的数据结构是一棵B+树。在MySQL 4.1之前的版本中每张表有一棵Insert Buffer B+树。而在现在的版本中，全局只有一棵Insert Buffer B+树，负责对所有的表的辅助索引进行Insert Buffer。而这棵B+树存放在共享表空间中，默认也就是ibdata1中。因此，试图通过独立表空间ibd文件恢复表中数据时，往往会导致CHECK TABLE失败。这是因为表的辅助索引中的数据可能还在Insert Buffer中，也就是共享表空间中，所以通过ibd文件进行恢复后，还需要进行REPAIR TABLE操作来重建表上所有的辅助索引。\nInsert Buffer是一棵B+树，因此其也由叶节点和非叶节点组成。非叶节点存放的是查询的search key（键值），其构造如图2-3所示。\n图　2-3　Insert Buffer非叶节点中的search key\nsearch key一共占用9个字节，其中space表示待插入记录所在表的表空间id，在InnoDB存储引擎中，每个表有一个唯一的space id，可以通过space id查询得知是哪张表。space占用4字节。marker占用1字节，它是用来兼容老版本的Insert Buffer。offset表示页所在的偏移量，占用4字节。\n当一个辅助索引要插入到页（space，offset）时，如果这个页不在缓冲池中，那么InnoDB存储引擎首先根据上述规则构造一个search key，接下来查询Insert Buffer这棵B+树，然后再将这条记录插入到Insert Buffer B+树的叶子节点中。\n对于插入到Insert Buffer B+树叶子节点的记录（如图2-4所示），并不是直接将待插入的记录插入，而是需要根据如下的规则进行构造：\n图　2-4　Insert Buffer叶子节点中的记录\nspace、marker、page_no字段和之前非叶节点中的含义相同，一共占用9字节。第4个字段metadata占用4字节，其存储的内容如表2-2所示。\nIBUF_REC_OFFSET_COUNT是保存两个字节的整数，用来排序每个记录进入Insert Buffer的顺序。因为从InnoDB1.0.x开始支持Change Buffer，所以这个值同样记录进入Insert Buffer的顺序。通过这个顺序回放（replay）才能得到记录的正确值。\n从Insert Buffer叶子节点的第5列开始，就是实际插入记录的各个字段了。因此较之原插入记录，Insert Buffer B+树的叶子节点记录需要额外13字节的开销。\n因为启用Insert Buffer索引后，辅助索引页（space，page_no）中的记录可能被插入到Insert Buffer B+树中，所以为了保证每次Merge Insert Buffer页必须成功，还需要有一个特殊的页用来标记每个辅助索引页（space，page_no）的可用空间。这个页的类型为Insert Buffer Bitmap。\n每个Insert Buffer Bitmap页用来追踪16384个辅助索引页，也就是256个区（Extent）。每个Insert Buffer Bitmap页都在16384个页的第二个页中。关于Insert Buffer Bitmap页的作用会在下一小节中详细介绍。\n每个辅助索引页在Insert Buffer Bitmap页中占用4位（bit），由表2-3中的三个部分组成。\n4.Merge Insert Buffer\n通过前面的小节读者应该已经知道了Insert/Change Buffer是一棵B+树。若需要实现插入记录的辅助索引页不在缓冲池中，那么需要将辅助索引记录首先插入到这棵B+树中。但是Insert Buffer中的记录何时合并（merge）到真正的辅助索引中呢？这是本小节需要关注的重点。\n概括地说，Merge Insert Buffer的操作可能发生在以下几种情况下：\n❑辅助索引页被读取到缓冲池时；\n❑Insert Buffer Bitmap页追踪到该辅助索引页已无可用空间时；\n❑Master Thread。\n第一种情况为当辅助索引页被读取到缓冲池中时，例如这在执行正常的SELECT查询操作，这时需要检查Insert Buffer Bitmap页，然后确认该辅助索引页是否有记录存放于Insert Buffer B+树中。若有，则将Insert Buffer B+树中该页的记录插入到该辅助索引页中。可以看到对该页多次的记录操作通过一次操作合并到了原有的辅助索引页中，因此性能会有大幅提高。\nInsert Buffer Bitmap页用来追踪每个辅助索引页的可用空间，并至少有1/32页的空间。若插入辅助索引记录时检测到插入记录后可用空间会小于1/32页，则会强制进行一个合并操作，即强制读取辅助索引页，将Insert Buffer B+树中该页的记录及待插入的记录插入到辅助索引页中。这就是上述所说的第二种情况。\n还有一种情况，之前在分析Master Thread时曾讲到，在Master Thread线程中每秒或每10秒会进行一次Merge Insert Buffer的操作，不同之处在于每次进行merge操作的页的数量不同。\n在Master Thread中，执行merge操作的不止是一个页，而是根据srv_innodb_io_capactiy的百分比来决定真正要合并多少个辅助索引页。但InnoDB存储引擎又是根据怎样的算法来得知需要合并的辅助索引页呢？\n在Insert Buffer B+树中，辅助索引页根据（space，offset）都已排序好，故可以根据（space，offset）的排序顺序进行页的选择。然而，对于Insert Buffer页的选择，InnoDB存储引擎并非采用这个方式，它随机地选择Insert Buffer B+树的一个页，读取该页中的space及之后所需要数量的页。该算法在复杂情况下应有更好的公平性。同时，若进行merge时，要进行merge的表已经被删除，此时可以直接丢弃已经被Insert/Change Buffer的数据记录。\n2.6.2　两次写\n如果说Insert Buffer带给InnoDB存储引擎的是性能上的提升，那么doublewrite（两次写）带给InnoDB存储引擎的是数据页的可靠性。\n当发生数据库宕机时，可能InnoDB存储引擎正在写入某个页到表中，而这个页只写了一部分，比如16KB的页，只写了前4KB，之后就发生了宕机，这种情况被称为部分写失效（partial page write）。在InnoDB存储引擎未使用doublewrite技术前，曾经出现过因为部分写失效而导致数据丢失的情况。\n有经验的DBA也许会想，如果发生写失效，可以通过重做日志进行恢复。这是一个办法。但是必须清楚地认识到，重做日志中记录的是对页的物理操作，如偏移量800，写'aaaa'记录。如果这个页本身已经发生了损坏，再对其进行重做是没有意义的。这就是说，在应用（apply）重做日志前，用户需要一个页的副本，当写入失效发生时，先通过页的副本来还原该页，再进行重做，这就是doublewrite。在InnoDB存储引擎中doublewrite的体系架构如图2-5所示。\n图　2-5　InnoDB存储引擎doublewrite架构\ndoublewrite由两部分组成，一部分是内存中的doublewrite buffer，大小为2MB，另一部分是物理磁盘上共享表空间中连续的128个页，即2个区（extent），大小同样为2MB。在对缓冲池的脏页进行刷新时，并不直接写磁盘，而是会通过memcpy函数将脏页先复制到内存中的doublewrite buffer，之后通过doublewrite buffer再分两次，每次1MB顺序地写入共享表空间的物理磁盘上，然后马上调用fsync函数，同步磁盘，避免缓冲写带来的问题。在这个过程中，因为doublewrite页是连续的，因此这个过程是顺序写的，开销并不是很大。在完成doublewrite页的写入后，再将doublewrite buffer中的页写入各个表空间文件中，此时的写入则是离散的。可以通过以下命令观察到doublewrite运行的情况：\nmysql＞SHOW GLOBAL STATUS LIKE'innodb_dblwr%'\\G;\n***************************1.row***************************\nVariable_name:Innodb_dblwr_pages_written\nValue:6325194\n***************************2.row***************************\nVariable_name:Innodb_dblwr_writes\nValue:100399\n2 rows in set(0.00 sec)\n可以看到，doublewrite一共写了6 325 194个页，但实际的写入次数为100 399，基本上符合64∶1。如果发现系统在高峰时的Innodb_dblwr_pages_written:Innodb_dblwr_writes远小于64∶1，那么可以说明系统写入压力并不是很高。\n如果操作系统在将页写入磁盘的过程中发生了崩溃，在恢复过程中，InnoDB存储引擎可以从共享表空间中的doublewrite中找到该页的一个副本，将其复制到表空间文件，再应用重做日志。下面显示了一个由doublewrite进行恢复的情况：\n090924 11:36:32 mysqld restarted\n090924 11:36:33 InnoDB:Database was not shut down normally!\nInnoDB:Starting crash recovery.\nInnoDB:Reading tablespace information from the.ibd files...\nInnoDB:Crash recovery may have failed for some.ibd files!\nInnoDB:Restoring possible half-written data pages from the doublewrite\nInnoDB:buffer...\n若查看MySQL官方手册，会发现在命令SHOW GLOBAL STATUS中Innodb_buffer_pool_pages_flushed变量表示当前从缓冲池中刷新到磁盘页的数量。根据之前的介绍，用户应该了解到，在默认情况下所有页的刷新首先都需要放入到doublewrite中，因此该变量应该和Innodb_dblwr_pages_written一致。然而在MySQL 5.5.24版本之前，Innodb_buffer_pool_pages_flushed总是为Innodb_dblwr_pages_written的2倍，而此Bug直到MySQL5.5.24才被修复。因此用户若需要统计数据库在生产环境中写入的量，最安全的方法还是根据Innodb_dblwr_pages_written来进行统计，这在所有版本的MySQL数据库中都是正确的。\n参数skip_innodb_doublewrite可以禁止使用doublewrite功能，这时可能会发生前面提及的写失效问题。不过如果用户有多个从服务器（slave server），需要提供较快的性能（如在slaves erver上做的是RAID0），也许启用这个参数是一个办法。不过对于需要提供数据高可靠性的主服务器（master server），任何时候用户都应确保开启doublewrite功能。\n注意　有些文件系统本身就提供了部分写失效的防范机制，如ZFS文件系统。在这种情况下，用户就不要启用doublewrite了。\n2.6.3　自适应哈希索引\n哈希（hash）是一种非常快的查找方法，在一般情况下这种查找的时间复杂度为O(1)，即一般仅需要一次查找就能定位数据。而B+树的查找次数，取决于B+树的高度，在生产环境中，B+树的高度一般为3～4层，故需要3～4次的查询。\nInnoDB存储引擎会监控对表上各索引页的查询。如果观察到建立哈希索引可以带来速度提升，则建立哈希索引，称之为自适应哈希索引（Adaptive Hash Index，AHI）。AHI是通过缓冲池的B+树页构造而来，因此建立的速度很快，而且不需要对整张表构建哈希索引。InnoDB存储引擎会自动根据访问的频率和模式来自动地为某些热点页建立哈希索引。\nAHI有一个要求，即对这个页的连续访问模式必须是一样的。例如对于（a，b）这样的联合索引页，其访问模式可以是以下情况：\n❑WHERE a=xxx\n❑WHERE a=xxx and b=xxx\n访问模式一样指的是查询的条件一样，若交替进行上述两种查询，那么InonDB存储引擎不会对该页构造AHI。此外AHI还有如下的要求：\n❑以该模式访问了100次\n❑页通过该模式访问了N次，其中N=页中记录*1/16\n根据InnoDB存储引擎官方的文档显示，启用AHI后，读取和写入速度可以提高2倍，辅助索引的连接操作性能可以提高5倍。毫无疑问，AHI是非常好的优化模式，其设计思想是数据库自优化的（self-tuning），即无需DBA对数据库进行人为调整。\n通过命令SHOW ENGINE INNODB STATUS可以看到当前AHI的使用状况：\nmysql＞SHOW ENGINE INNODB STATUS\\G;\n***************************1.row***************************\nStatus:\n=====================================\n090922 11:52:51 INNODB MONITOR OUTPUT\n=====================================\nPer second averages calculated from the last 15 seconds\n……\n-------------------------------------\nINSERT BUFFER AND ADAPTIVE HASH INDEX\n-------------------------------------\nIbuf:size 2249,free list len 3346,seg size 5596,\n374650 inserts,51897 merged recs,14300 merges\nHash table size 4980499,node heap has 1246 buffer(s)\n1640.60 hash searches/s,3709.46 non-hash searches/s\n……\n现在可以看到AHI的使用信息了，包括AHI的大小、使用情况、每秒使用AHI搜索的情况。值得注意的是，哈希索引只能用来搜索等值的查询，如SELECT*FROM table WHERE index_col='xxx'。而对于其他查找类型，如范围查找，是不能使用哈希索引的，因此这里出现了non-hash searches/s的情况。通过hash searches:non-hash searches可以大概了解使用哈希索引后的效率。\n由于AHI是由InnoDB存储引擎控制的，因此这里的信息只供用户参考。不过用户可以通过观察SHOW ENGINE INNODB STATUS的结果及参数innodb_adaptive_hash_index来考虑是禁用或启动此特性，默认AHI为开启状态。\n2.6.4　异步IO\n为了提高磁盘操作性能，当前的数据库系统都采用异步IO（Asynchronous IO，AIO）的方式来处理磁盘操作。InnoDB存储引擎亦是如此。\n与AIO对应的是Sync IO，即每进行一次IO操作，需要等待此次操作结束才能继续接下来的操作。但是如果用户发出的是一条索引扫描的查询，那么这条SQL查询语句可能需要扫描多个索引页，也就是需要进行多次的IO操作。在每扫描一个页并等待其完成后再进行下一次的扫描，这是没有必要的。用户可以在发出一个IO请求后立即再发出另一个IO请求，当全部IO请求发送完毕后，等待所有IO操作的完成，这就是AIO。\nAIO的另一个优势是可以进行IO Merge操作，也就是将多个IO合并为1个IO，这样可以提高IOPS的性能。例如用户需要访问页的（space，page_no）为：\n（8，6）、（8，7），（8，8）\n每个页的大小为16KB，那么同步IO需要进行3次IO操作。而AIO会判断到这三个页是连续的（显然可以通过（space，page_no）得知）。因此AIO底层会发送一个IO请求，从（8，6）开始，读取48KB的页。\n若通过Linux操作系统下的iostat命令，可以通过观察rrqm/s和wrqm/s，例如：\navg-cpu:%user%nice%system%iowait%steal%idle\n4.70 0.00 1.60 13.20 0.00 80.50\nDevice:rrqm/s wrqm/s r/s w/s rMB/s wMB/s avgrq-sz avgqu-sz await svctm%util\nsdc 3905.67 172.00 6910.33 466.67 168.81 18.15 51.91 19.17 2.59 0.13 97.73\n在InnoDB1.1.x之前，AIO的实现通过InnoDB存储引擎中的代码来模拟实现。而从InnoDB 1.1.x开始（InnoDB Plugin不支持），提供了内核级别AIO的支持，称为Native AIO。因此在编译或者运行该版本MySQL时，需要libaio库的支持。若没有则会出现如下的提示：\n/usr/local/mysql/bin/mysqld:error while loading shared libraries:libaio.so.1:cannot open shared object file:No such file or directory\n需要注意的是，Native AIO需要操作系统提供支持。Windows系统和Linux系统都提供Native AIO支持，而Mac OSX系统则未提供。因此在这些系统下，依旧只能使用原模拟的方式。在选择MySQL数据库服务器的操作系统时，需要考虑这方面的因素。\n参数innodb_use_native_aio用来控制是否启用Native AIO，在Linux操作系统下，默认值为ON：\nmysql＞SHOW VARIABLES LIKE'innodb_use_native_aio'\\G;\n***************************1.row***************************\nVariable_name:innodb_use_native_aio\nValue:ON\n1 row in set(0.00 sec)\n用户可以通过开启和关闭Native AIO功能来比较InnoDB性能的提升。官方的测试显示，启用Native AIO，恢复速度可以提高75%。\n在InnoDB存储引擎中，read ahead方式的读取都是通过AIO完成，脏页的刷新，即磁盘的写入操作则全部由AIO完成。\n2.6.5　刷新邻接页\nInnoDB存储引擎还提供了Flush Neighbor Page（刷新邻接页）的特性。其工作原理为：当刷新一个脏页时，InnoDB存储引擎会检测该页所在区（extent）的所有页，如果是脏页，那么一起进行刷新。这样做的好处显而易见，通过AIO可以将多个IO写入操作合并为一个IO操作，故该工作机制在传统机械磁盘下有着显著的优势。但是需要考虑到下面两个问题：\n❑是不是可能将不怎么脏的页进行了写入，而该页之后又会很快变成脏页？\n❑固态硬盘有着较高的IOPS，是否还需要这个特性？\n为此，InnoDB存储引擎从1.2.x版本开始提供了参数innodb_flush_neighbors，用来控制是否启用该特性。对于传统机械硬盘建议启用该特性，而对于固态硬盘有着超高IOPS性能的磁盘，则建议将该参数设置为0，即关闭此特性。\n2.7　启动、关闭与恢复\nInnoDB是MySQL数据库的存储引擎之一，因此InnoDB存储引擎的启动和关闭，更准确的是指在MySQL实例的启动过程中对InnoDB存储引擎的处理过程。\n在关闭时，参数innodb_fast_shutdown影响着表的存储引擎为InnoDB的行为。该参数可取值为0、1、2，默认值为1。\n❑0表示在MySQL数据库关闭时，InnoDB需要完成所有的full purge和merge insert buffer，并且将所有的脏页刷新回磁盘。这需要一些时间，有时甚至需要几个小时来完成。如果在进行InnoDB升级时，必须将这个参数调为0，然后再关闭数据库。\n❑1是参数innodb_fast_shutdown的默认值，表示不需要完成上述的full purge和merge insert buffer操作，但是在缓冲池中的一些数据脏页还是会刷新回磁盘。\n❑2表示不完成full purge和merge insert buffer操作，也不将缓冲池中的数据脏页写回磁盘，而是将日志都写入日志文件。这样不会有任何事务的丢失，但是下次MySQL数据库启动时，会进行恢复操作（recovery）。\n当正常关闭MySQL数据库时，下次的启动应该会非常“正常”。但是如果没有正常地关闭数据库，如用kill命令关闭数据库，在MySQL数据库运行中重启了服务器，或者在关闭数据库时，将参数innodb_fast_shutdown设为了2时，下次MySQL数据库启动时都会对InnoDB存储引擎的表进行恢复操作。\n参数innodb_force_recovery影响了整个InnoDB存储引擎恢复的状况。该参数值默认为0，代表当发生需要恢复时，进行所有的恢复操作，当不能进行有效恢复时，如数据页发生了corruption，MySQL数据库可能发生宕机（crash），并把错误写入错误日志中去。\n但是，在某些情况下，可能并不需要进行完整的恢复操作，因为用户自己知道怎么进行恢复。比如在对一个表进行alter table操作时发生意外了，数据库重启时会对InnoDB表进行回滚操作，对于一个大表来说这需要很长时间，可能是几个小时。这时用户可以自行进行恢复，如可以把表删除，从备份中重新导入数据到表，可能这些操作的速度要远远快于回滚操作。\n参数innodb_force_recovery还可以设置为6个非零值：1～6。大的数字表示包含了前面所有小数字表示的影响。具体情况如下：\n❑1(SRV_FORCE_IGNORE_CORRUPT)：忽略检查到的corrupt页。\n❑2(SRV_FORCE_NO_BACKGROUND)：阻止Master Thread线程的运行，如Master Thread线程需要进行full purge操作，而这会导致crash。\n❑3(SRV_FORCE_NO_TRX_UNDO)：不进行事务的回滚操作。\n❑4(SRV_FORCE_NO_IBUF_MERGE)：不进行插入缓冲的合并操作。\n❑5(SRV_FORCE_NO_UNDO_LOG_SCAN)：不查看撤销日志（Undo Log），InnoDB存储引擎会将未提交的事务视为已提交。\n❑6(SRV_FORCE_NO_LOG_REDO)：不进行前滚的操作。\n需要注意的是，在设置了参数innodb_force_recovery大于0后，用户可以对表进行select、create和drop操作，但insert、update和delete这类DML操作是不允许的。\n现在来做一个实验，模拟故障的发生。在第一个会话中（session），对一张接近1 000万行的InnoDB存储引擎表进行更新操作，但是完成后不要马上提交：\nmysql＞START TRANSACTION;\nQuery OK,0 rows affected(0.00 sec)\nmysql＞UPDATE Profile SET password='';\nQuery OK,9587770 rows affected(7 min 55.73 sec)\nRows matched:9999248 Changed:9587770 Warnings:0\nSTART TRANSACTION语句开启了事务，同时防止了自动提交（auto commit）的发生，UPDATE操作则会产生大量的UNDO日志（undo log）。这时，人为通过kill命令杀掉MySQL数据库服务器：\n[root@nineyou0-43～]#ps-ef|grep mysqld\nroot 28007 1 0 13:40 pts/1 00:00:00/bin/sh./bin/mysqld_safe--datadir=/usr/local/mysql/data--pid-file=/usr/local/mysql/data/nineyou0-43.pid\nmysql 28045 28007 42 13:40 pts/1 00:04:23/usr/local/mysql/bin/mysqld--basedir=/usr/local/mysql--datadir=/usr/local/mysql/data--user=mysql--pid-file=/usr/local/mysql/data/nineyou0-43.pid--skip-external-locking--port=3306--socket=/tmp/mysql.sock\nroot 28110 26963 0 13:50 pts/11 00:00:00 grep mysqld\n[root@nineyou0-43～]#kill-9 28007\n[root@nineyou0-43～]#kill-9 28045\n通过kill命令可以模拟数据库的宕机操作。下次MySQL数据库启动时会对之前的UPDATE事务进行回滚操作，而这些信息都会记录在错误日志文件（默认后缀名为err）中。如果查看错误日志文件，可得如下结果：\n090922 13:40:20 InnoDB:Started;log sequence number 6 2530474615\nInnoDB:Starting in background the rollback of uncommitted transactions\n090922 13:40:20 InnoDB:Rolling back trx with id 0 5281035,8867280 rows to undo\nInnoDB:Progress in percents:1090922 13:40:20\n090922 13:40:20[Note]/usr/local/mysql/bin/mysqld:ready for connections.\nVersion:'5.0.45-log'socket:'/tmp/mysql.sock'port:3306 MySQL Community Server(GPL)\n2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100\nInnoDB:Rolling back of trx id 0 5281035 completed\n090922 13:49:21 InnoDB:Rollback of non-prepared transactions completed\n可以看到，采用默认的策略，即将innodb_force_recovery设为0，InnoDB会在每次启动后对发生问题的表进行恢复操作。通过错误日志文件，可知这次回滚操作需要回滚8867280行记录，差不多总共进行了9分钟。\n再做一次同样的测试，只不过这次在启动MySQL数据库前，将参数innodb_force_recovery设为3，然后观察InnoDB存储引擎是否还会进行回滚操作。查看错误日志文件，可得：\n090922 14:26:23 InnoDB:Started;log sequence number 7 2253251193\nInnoDB:!!!innodb_force_recovery is set to 3!!!\n090922 14:26:23[Note]/usr/local/mysql/bin/mysqld:ready for connections.\nVersion:'5.0.45-log'socket:'/tmp/mysql.sock'port:3306 MySQL Community Server(GPL)\n这里出现了“!!!”，InnoDB警告已经将innodb_force_recovery设置为3，不会进行回滚操作了，因此数据库很快启动完成了。但是用户应该小心当前数据库的状态，并仔细确认是否不需要回滚事务的操作。\n2.8　小结\n本章对InnoDB存储引擎及其体系结构进行了概述，先给出了InnoDB存储引擎的历史、InnoDB存储引擎的体系结构（包括后台线程和内存结构）；之后又详细介绍了InnoDB存储引擎的关键特性，这些特性使InnoDB存储引擎变得更具“魅力”；最后介绍了启动和关闭MySQL时一些配置文件参数对InnoDB存储引擎的影响。\n通过本章的铺垫，读者在学习后面的内容时就会对InnoDB引擎理解得更深入和更全面。第3章开始介绍MySQL的文件，包括MySQL本身的文件和与InnoDB存储引擎本身有关的文件。之后本书将介绍基于InnoDB存储引擎的表，并揭示内部的存储构造。\n第3章　文件\n本章将分析构成MySQL数据库和InnoDB存储引擎表的各种类型文件。这些文件有以下这些。\n❑参数文件：告诉MySQL实例启动时在哪里可以找到数据库文件，并且指定某些初始化参数，这些参数定义了某种内存结构的大小等设置，还会介绍各种参数的类型。\n❑日志文件：用来记录MySQL实例对某种条件做出响应时写入的文件，如错误日志文件、二进制日志文件、慢查询日志文件、查询日志文件等。\n❑socket文件：当用UNIX域套接字方式进行连接时需要的文件。\n❑pid文件：MySQL实例的进程ID文件。\n❑MySQL表结构文件：用来存放MySQL表结构定义文件。\n❑存储引擎文件：因为MySQL表存储引擎的关系，每个存储引擎都会有自己的文件来保存各种数据。这些存储引擎真正存储了记录和索引等数据。本章主要介绍与InnoDB有关的存储引擎文件。\n3.1　参数文件\n在第1章中已经介绍过了，当MySQL实例启动时，数据库会先去读一个配置参数文件，用来寻找数据库的各种文件所在位置以及指定某些初始化参数，这些参数通常定义了某种内存结构有多大等。在默认情况下，MySQL实例会按照一定的顺序在指定的位置进行读取，用户只需通过命令mysql--help|grep my.cnf来寻找即可。\nMySQL数据库参数文件的作用和Oracle数据库的参数文件极其类似，不同的是，Oracle实例在启动时若找不到参数文件，是不能进行装载（mount）操作的。MySQL稍微有所不同，MySQL实例可以不需要参数文件，这时所有的参数值取决于编译MySQL时指定的默认值和源代码中指定参数的默认值。但是，如果MySQL实例在默认的数据库目录下找不到mysql架构，则启动同样会失败，此时可能在错误日志文件中找到如下内容：\n090922 16:25:52 mysqld started\n090922 16:25:53 InnoDB:Started;log sequence number 8 2801063211\nInnoDB:!!!innodb_force_recovery is set to 1!!!\n090922 16:25:53[ERROR]Fatal error:Can't open and lock privilege tables:Table'mysql.host'doesn't exist\n090922 16:25:53 mysqld ended\nMySQL的mysql架构中记录了访问该实例的权限，当找不到这个架构时，MySQL实例不会成功启动。\nMySQL数据库的参数文件是以文本方式进行存储的。用户可以直接通过一些常用的文本编辑软件（如vi和emacs）进行参数的修改。\n3.1.1　什么是参数\n简单地说，可以把数据库参数看成一个键/值（key/value）对。第2章已经介绍了一个对于InnoDB存储引擎很重要的参数innodb_buffer_pool_size。如我们将这个参数设置为1G，即innodb_buffer_pool_size=1G。这里的“键”是innodb_buffer_pool_size，“值”是1G，这就是键值对。可以通过命令SHOW VARIABLES查看数据库中的所有参数，也可以通过LIKE来过滤参数名。从MySQL 5.1版本开始，还可以通过information_schema架构下的GLOBAL_VARIABLES视图来进行查找，如下所示。\nmysql＞SELECT*FROM\n-＞GLOBAL_VARIABLES\n-＞WHERE VARIABLE_NAME LIKE'innodb_buffer%'\\G;\n***************************1.row***************************\nVARIABLE_NAME:INNODB_BUFFER_POOL_SIZE\nVARIABLE_VALUE:1073741824\n1 row in set(0.00 sec)\nmysql＞SHOW VARIABLES LIKE'innodb_buffer%'\\G;\n***************************1.row***************************\nVariable_name:innodb_buffer_pool_size\nValue:1073741824\n1 row in set(0.00 sec)\n无论使用哪种方法，输出的信息基本上都一样的，只不过通过视图GLOBAL_VARIABLES需要指定视图的列名。推荐使用命令SHOW VARIABLES，因为这个命令使用更为简单，且各版本的MySQL数据库都支持。\nOracle数据库存在所谓的隐藏参数（undocumented parameter），以供Oracle“内部人士”使用，SQL Server也有类似的参数。有些DBA曾问我，MySQL中是否也有这类参数。我的回答是：没有，也不需要。即使Oracle和SQL Server中都有些所谓的隐藏参数，在绝大多数的情况下，这些数据库厂商也不建议用户在生产环境中对其进行很大的调整。\n3.1.2　参数类型\nMySQL数据库中的参数可以分为两类：\n❑动态（dynamic）参数\n❑静态（static）参数\n动态参数意味着可以在MySQL实例运行中进行更改，静态参数说明在整个实例生命周期内都不得进行更改，就好像是只读（read only）的。可以通过SET命令对动态的参数值进行修改，SET的语法如下：\nSET\n|[global|session]system_var_name=expr\n|[@@global.|@@session.|@@]system_var_name=expr\n这里可以看到global和session关键字，它们表明该参数的修改是基于当前会话还是整个实例的生命周期。有些动态参数只能在会话中进行修改，如autocommit；而有些参数修改完后，在整个实例生命周期中都会生效，如binlog_cache_size；而有些参数既可以在会话中又可以在整个实例的生命周期内生效，如read_buffer_size。举例如下：\nmysql＞SET read_buffer_size=524288;\nQuery OK,0 rows affected(0.00 sec)\nmysql＞SELECT@@session.read_buffer_size\\G;\n***************************1.row***************************\n@@session.read_buffer_size:524288\n1 row in set(0.00 sec)\nmysql＞SELECT@@global.read_buffer_size\\G;\n***************************1.row***************************\n@@global.read_buffer_size:2093056\n1 row in set(0.00 sec)\n上述示例中将当前会话的参数read_buffer_size从2MB调整为了512KB，而用户可以看到全局的read_buffer_size的值仍然是2MB，也就是说如果有另一个会话登录到MySQL实例，它的read_buffer_size的值是2MB，而不是512KB。这里使用了set global|session来改变动态变量的值。用户同样可以直接使用SET@@globl|@@session来更改，如下所示：\nmysql＞SET@@global.read_buffer_size=1048576;\nQuery OK,0 rows affected(0.00 sec)\nmysql＞SELECT@@session.read_buffer_size\\G;\n***************************1.row***************************\n@@session.read_buffer_size:524288\n1 row in set(0.00 sec)\nmysql＞SELECT@@global.read_buffer_size\\G;\n***************************1.row***************************\n@@global.read_buffer_size:1048576\n1 row in set(0.00 sec)\n这次把read_buffer_size全局值更改为1MB，而当前会话的read_buffer_size的值还是512KB。这里需要注意的是，对变量的全局值进行了修改，在这次的实例生命周期内都有效，但MySQL实例本身并不会对参数文件中的该值进行修改。也就是说，在下次启动时MySQL实例还是会读取参数文件。若想在数据库实例下一次启动时该参数还是保留为当前修改的值，那么用户必须去修改参数文件。要想知道MySQL所有动态变量的可修改范围，可以参考MySQL官方手册的Dynamic System Variables的相关内容。\n对于静态变量，若对其进行修改，会得到类似如下错误：\nmysql＞SET GLOBAL datadir='/db/mysql';\nERROR 1238(HY000):Variable'datadir'is a read only variable\n3.2　日志文件\n日志文件记录了影响MySQL数据库的各种类型活动。MySQL数据库中常见的日志文件有：\n❑错误日志（error log）\n❑二进制日志（binlog）\n❑慢查询日志（slow query log）\n❑查询日志（log）\n这些日志文件可以帮助DBA对MySQL数据库的运行状态进行诊断，从而更好地进行数据库层面的优化。\n3.2.1　错误日志\n错误日志文件对MySQL的启动、运行、关闭过程进行了记录。MySQL DBA在遇到问题时应该首先查看该文件以便定位问题。该文件不仅记录了所有的错误信息，也记录一些警告信息或正确的信息。用户可以通过命令SHOW VARIABLES LIKE'log_error'来定位该文件，如：\nmysql＞SHOW VARIABLES LIKE'log_error'\\G;\n***************************1.row***************************\nVariable_name:log_error\nValue:/mysql_data_2/stargazer.log\n1 row in set(0.00 sec)\nmysql＞system hostname\nstargazer\n可以看到错误文件的路径和文件名，在默认情况下错误文件的文件名为服务器的主机名。如上面看到的，该主机名为stargazer，所以错误文件名为startgazer.err。当出现MySQL数据库不能正常启动时，第一个必须查找的文件应该就是错误日志文件，该文件记录了错误信息，能很好地指导用户发现问题。当数据库不能重启时，通过查错误日志文件可以得到如下内容：\n[root@nineyou0-43 data]#tail-n 50 nineyou0-43.err\n090924 11:31:18 mysqld started\n090924 11:31:18 InnoDB:Started;log sequence number 8 2801063331\n090924 11:31:19[ERROR]Fatal error:Can't open and lock privilege tables:Table'mysql.host'doesn't exist\n090924 11:31:19 mysqld ended\n这里，错误日志文件提示了找不到权限库mysql，所以启动失败。有时用户可以直接在错误日志文件中得到优化的帮助，因为有些警告（warning）很好地说明了问题所在。而这时可以不需要通过查看数据库状态来得知，例如，下面的错误文件中的信息可能告诉用户需要增大InnoDB存储引擎的redo log：\n090924 11:39:44 InnoDB:ERROR:the age of the last checkpoint is 9433712,\nInnoDB:which exceeds the log group capacity 9433498.\nInnoDB:If you are using big BLOB or TEXT rows,you must set the\nInnoDB:combined size of log files at least 10 times bigger than the\nInnoDB:largest such row.\n090924 11:40:00 InnoDB:ERROR:the age of the last checkpoint is 9433823,\nInnoDB:which exceeds the log group capacity 9433498.\nInnoDB:If you are using big BLOB or TEXT rows,you must set the\nInnoDB:combined size of log files at least 10 times bigger than the\nInnoDB:largest such row.\n090924 11:40:16 InnoDB:ERROR:the age of the last checkpoint is 9433645,\nInnoDB:which exceeds the log group capacity 9433498.\nInnoDB:If you are using big BLOB or TEXT rows,you must set the\nInnoDB:combined size of log files at least 10 times bigger than the\nInnoDB:largest such row.\n",
  "factionName": "MySQL技术内幕：InnoDB存储引擎",
  "newest": 10,
  "comments": [],
  "source": [],
  "index": "5"
},{
  "_id": "ce62b12c-effe-48d2-9c49-e1bfbe8b234a",
  "headerImage": "https://wk-gulimall.oss-cn-beijing.aliyuncs.com/ProgramBook/ad434d96-6ec8-4bd9-b557-eefa60dbbc07.jpg",
  "updateTime": {
    "$date": "2023-01-23T16:59:37.852Z"
  },
  "author": "wizard",
  "des": "无",
  "factionName": "Node.js 设计模式",
  "newest": 10,
  "comments": [],
  "source": [],
  "index": "4"
},{
  "_id": "bf78ecab-9e92-49ae-90b5-079e96f907c5",
  "headerImage": "https://wk-gulimall.oss-cn-beijing.aliyuncs.com/ProgramBook/ec243b5e-7c38-4ffb-b71a-913b9a713ab8.jpg",
  "updateTime": {
    "$date": "2023-01-23T16:59:38.646Z"
  },
  "author": "萨默菲尔德,",
  "des": "前言\n在应用广泛的各种语言中，Python或许是最容易学习和最好使用的。Python代码很容易阅读和编写，并且非常清晰，而没有什么隐秘的。Python是一种表达能力非常强的语言，这意味着，在设计同样的应用程序时，使用Python进行编码所需要的代码量要远少于使用其他语言（比如C++或Java）的代码量。\nPython是一种跨平台的语言：一般来说，同样的Python程序可以同时在Windows平台与UNIX类平台（比如Linux、BSD与Mac OS X）上运行——只需要将构成Python程序的单个或多个文件复制到目标机器上，而不需要“构建”或编译（Python是解释型语言）。当然，Python程序使用特定平台功能也是可能的，但通常很少需要这样做，因为几乎所有Python标准库与大多数第三方库都是完全跨平台的，或至少对用户是透明的。\nhttp://pypi.python.org/pypi\n虽然本质上是一种面向对象语言，但是实际上Python可以用于进行过程型程序设计、面向对象设计，以及某种程度上的函数型程序设计。本书主要展示如何使用Python进行过程型程序设计与面向对象程序设计，也介绍了Python的函数型程序设计功能。\n本书的目标是展示如何使用良好的Python 3惯用风格编写Python程序，在阅读本书之后，你就可以发现，本书是一本非常有用的Python 3语言索引。虽然与Python 2相比，Python 3所做的改进和改变是渐进的，而非革新，但是在Python 3中，Python 2中的一些既有做法变得不再合适或不再必要，因此必须介绍和使用Python 3中的一些新做法，以便充分利用Python 3的功能。毋庸置疑，Python 3优于Python 2；它构建于Python 2多年的实践基础上，并添加了大量的新功能（还摒弃了Python 2的一些不良特性）。与Python 2相比，使用Python 3更富于乐趣，更便利、容易和具有一致性。\n本书旨在讲解Python语言本身，虽然中间也涉及很多标准Python库，但是没有全部介绍。不过这不是问题，因为在阅读本书之后，将具备充分的Python知识，读者可以自如地使用任意的标准库或任意第三方库，并可以创建自己的库模块。\n本书适用于多种不同类型的读者，包括自学者、程序设计爱好者、学生、科学家、工程师，以及工作中需要进行程序设计的人，当然，也包括计算专业工作者和计算机科学家。要面对这些不同类型的读者，既让已具备丰富知识的读者不厌烦，又让经验不足的读者可以理解，因此，本书假定读者至少具备一定的程序设计经验（任何程序语言）。特别是，本书需要读者了解数据类型（比如数与字符串）、集合数据类型（比如集合与列表）、控制结构（比如if与while语句）以及函数。此外，有些实例与练习需要读者具备HTML markup的相关知识，后面某些更专业化的章节需要读者具备一定领域的知识，比如，数据库那一章需要读者具备基本的SQL知识。\n在结构上，本书尽可能让读者阅读时最富有效率。在第1章结束时，读者应该就可以编写短小但有用的Python程序。后续的每一章都分别讲述一个新主题，在内容上通常都会比前一章更广、更深。这意味着，如果顺序阅读本书各章，在每一章结束后，都可以停止阅读，并利用该章讲解的知识编写完整的Python程序，当然，你也可以继续阅读以便学习更高级、更复杂的技术。出于这一考虑，有些主题在某一章中介绍，在后续的一章或几章中又进行了深入讲解。\n讲解一门新的程序设计语言时，有两个关键的问题。第一个问题是：有时候，需要讲解某个特定概念时，会发现该概念依赖于另外一个概念，而这个概念反过来又直接或间接地依赖于这个“特定概念”。第二个问题是：在最开始的时候，由于读者对该语言毫无所知，或者只具备极为有限的知识，因此要给出有趣的、有用的实例或练习非常困难。在本书中，我们力图解决这两个问题。对第一个问题，首先要求读者具备一定的程序设计经验，了解基本的概念；对第二个问题，我们在第1章中就讲解了Python的“beautiful heart”——Python的8个关键要素，足以用于编写良好的程序。这种做法也有一个不足的地方：在前几章中，有些实例在风格上会有一点刻意为之的痕迹，这是因为这些实例中只是使用了到该章为止所讲解的知识，不过这种副作用越到后面的章节越弱，到第7章结束时，所有实例都使用完全自然的Python 3惯用风格编写。\n本书所讲述的方法是完全实践型的，我们建议读者尝试书中讲述的每个实例，做好每一个练习，以便获取实际的动手经验。在可能的地方，本书都提供了虽然短小但是完整的程序，这些程序实例展现了真实的应用场景。本书所带实例、练习及其解决方案都可以在www.qtrac.eu/py3book.html处获取，并且都已经在Windows、Linux、Mac OS X等操作平台上的Python 3环境下进行了测试。\n本书的组织结构\n第1章，提出了Python的8个关键要素，这些要素足以用于编写完整的Python程序。本章描述了一些可用的Python程序设计环境，给出了两个小实例，这两个实例都是使用前面讲述的8个关键要素构建的。\n第2章～第5章介绍了Python的过程型程序设计功能，包括基本数据类型与集合数据类型、很多有用的内置函数与控制结构，以及比较简单的文本文件处理功能。第5章展示了如何创建自定义模块与包，并提供了Python标准库概览，以便读者对Python提供的功能有充分的了解，避免重复工作。\n第6章对使用Python进行面向对象程序设计进行了全面深入的讲解。由于面向对象程序设计是建立在过程型程序设计基础之上的，因此，此前几章讲述的过程型程序设计相关的知识仍然可以用于面向对象程序设计，比如，利用同样的数据类型、集合数据类型以及控制结构。\n第7章主要讲述文件的读、写。对于二进制文件，包括压缩、随机存取；对于文本文件，包括人工分析以及正则表达式的使用。本章也包括了如何读、写XML文件，包括使用元素树、DOM（文档对象模型）以及SAX（用于XML的简单API）。\n第8章回顾了前面一些章节中讲述的内容，探讨了数据类型、集合数据类型、控制结构、函数、面向对象程序设计等领域一些更高级的内容。本章还介绍了很多新功能、类以及高级技术，包括函数型程序设计——其中的内容有挑战性，但也很有用。\n第9章与其他章节的不同之处在于，它不是介绍新的Python特性，而是讨论了用于调试、测试和profiling程序的技术和库。\n余下的几章讲述了其他一些高级主题。第10章展示了如何将程序的工作负载分布在多个进程与线程上；第11章展示了如何使用Python的标准网络支持功能编写客户端/服务器应用程序；第12章讲解了数据库程序设计（包括键-值对DBM文件与SQL数据库）；第13章讲述了Python的正则表达式mini-language，介绍了正则表达式模块；第14章讲解使用正则表达式，以及使用两种第三方模块（PyParsing和PLY）的解析技术；第15章介绍了GUI（图形用户界面）程序设计。\n本书的大部分章都较长，这样是为了将所有相关资料放在一起，以便于查询引用，不过，各章都进一步划分为节、小节，因此，本书仍然是可以按照适合自己的节奏阅读的，比如，每次阅读一节或一个小节。\n获取并安装Python 3\n如果使用的是较新版本的Mac或UNIX类系统并及时更新，就应该已经安装了Python 3。要检查是否已经安装，可以在控制台（在Mac OS X上是Terminal.app）中输入命令python V（注意是大写的V），如果版本为3.X，就说明系统中已经安装了Python 3，而不需要自己再安装，如果不是，请继续阅读。\n对Windows与Mac OS X系统，存在易于使用的图形界面安装包，只需要按照提示就可以一步一步地完成安装过程。安装工具包可以从www.python.org/download处获取，该网站为Windows系统提供了3个独立的安装程序，一般需要下载的是普通的“Windows ×86 MSI Installer”，除非确认自己的机器使用的是AMD64或Itanium处理器，这种情况需要下载处理器特定的安装程序。下载安装程序后，只需要运行并按提示进行操作，就可以安装好Python 3。\n对Linux、BSD以及其他UNIX类系统，安装Python的最简单方法是使用该操作系统的软件包管理系统。大多数情况下，Python安装程序是以几个单独的软件包形式提供的。比如，在Fedora中，用于Python的安装包为python，用于IDLE（一个简单的开发环境）的安装包为python-tools。需要注意的是，只有在Fedora为更新的版本时（版本10或后续版本），这些安装包才是基于Python 3的。同样，对基于Debian的系统，比如Ubuntu，对应的安装包为python3与idle3。\n如果没有适合自己操作系统的安装包，就需要从www.python.org/download处下载源程序，并从头编译Python。你可以下载source tarballs中的任意一个，并根据其文件格式选择不同的工具进行解压：如果下载的是gzipped tarball，则需要使用tar xvfz Python-3.0.tgz；如果下载的是bzip2 tarball，则需要使用tar xvfj Python-3.0.tar.bz2。配置与构建过程是标准的，首先切换到新创建的Python-3.0目录，运行./configure（如果需要本地安装，可以使用--prefix选项），之后运行make。\n安装Python 3时，可能出现的一种情况是，在安装结束时弹出提示消息，声称不是所有的模块都已经安装，这通常意味着机器上缺少某些必要的库或头文件。这种情况可以通过单独安装相应程序包处理，比如，如果readline模块无法构建，可以使用包管理系统安装相应的开发库，如在基于Fedora的系统上安装readline-devel，在基于Debian的系统上安装readline-dev（遗憾的是，相关包的名字并不总是那么显而易见的）。安装了缺少的包之后，再次运行./configure与make。\n成功构建之后，可以运行make test，以便确认是否一切正常——尽管这并非必需，并且可能需要花费一些时间。\n如果使用了--prefix进行本地安装，那么只需要运行make install。你可能需要为python可执行程序添加软链接（如果使用的是--prefix=$HOME/local/python3，并且PATH中包含$HOME/bin目录，则需要ln -s ~/local/python3/bin/python3.0 ~/bin/py- thon3），为IDLE添加软链接也会带来不少方便（假定前提与上面的一样，则需要ln -s ~/local/python3/bin/idle ~/bin/idle3）。\n如果不使用--prefix并具备root权限，应该以root用户登录，并执行make install。在基于sudo的系统（比如Ubuntu）上，则执行sudo make install。如果系统上已经存在Python 2，/usr/bin/python并不会改变，同时Python 3将以python3的形式存在，同样地，Python 3的IDLE以idle3的形式存在。\n致谢\n首先感谢读者对本书第一版的反馈，他们在反馈中给出了修改意见和建议。\n其次要感谢的是本书的技术评审Jasmin Blanchette，他是一位计算机科学家、程序员，我们曾共同编写过两本C++/Qt书籍。Jasmin对章节布局的规划、对所有实例的建议与批评以及对本书的详细审阅，这一切都极大地提高了本书的质量。\nGeorg Brandl是一位一流的Python开发人员，也是一位负责创建Python的新文档工具链的文档编辑。Georg挑出了很多微妙的错误，并非常耐心、非常坚持地对其进行解释，直至可以被准确理解和纠正。他还对很多实例进行了改进。\nPhil Thompson是一位Python专家，也是PyQt（可能是可用的Python GUI库中最好的）的创建者。Phil的敏锐洞察力，有时候甚至是带有挑战性的反馈，都促使我对本书的很多内容进行了澄清和纠正。\nTrenton Schulz是Nokia的Qt Software（以前的Trolltech）部门的一位高级软件工程师，也是我以前撰写的所有书籍的有见地的评审，在本书的评审编辑中又一次给予了我宝贵的帮助。Trenton对本书的细致阅读与提出的大量宝贵建议，帮助我澄清了很多问题，在很大程度上提高了本书质量。\n除上面提及的各位评审人员之外（他们都读完了整本书），David Boddie，Nokia的Qt Software的一位高级技术作者，也是一位经验丰富的Python老手和开源软件开发者，阅读了本书的部分章节并给出了有价值的回馈。\n同时也要感谢Guido van Rossum，Python的创建者，感谢大量的Python社区，是他们的努力，使得Python（尤其是库文件）变得如此有用而好用。\n还要感谢Jeff Kingston，Lout typesetting语言（我使用这种语言的时间超过10年）的创建者。\n特别感谢本书的编辑Debra Williams Cauley，感谢她给予的支持，并再一次使得本书的整个编辑、出版过程尽可能顺畅；感谢Anna Popick，他将本书的生产过程管理得非常好；感谢校对人员Audrey Doyle再一次做了良好的工作。\n最后也是最重要的是，感谢我的妻子Andrea，感谢她对我在凌晨4点起床，记录下编写本书的灵感，以及对代码进行纠正和测试时，所表现出来的忍耐，以及她的爱、忠诚和一如既往的支持。\n",
  "factionName": "Python 3程序开发指南",
  "newest": 10,
  "comments": [],
  "source": [],
  "index": "3"
},{
  "_id": "d94b2f56-392e-4839-9d6b-48e3d9592a46",
  "headerImage": "https://wk-gulimall.oss-cn-beijing.aliyuncs.com/ProgramBook/92f523e4-5b6c-4d9a-8faf-1733306cab8a.jpg",
  "updateTime": {
    "$date": "2023-01-23T16:59:40.676Z"
  },
  "author": "Walls）",
  "des": "本书由北京图灵文化发展有限公司发行数字版。版权所有，侵权必究。\n您购买的图灵电子书仅供您个人使用，未经授权，不得以任何方式复制和传播本书内容。\n我们愿意相信读者具有这样的良知和觉悟，与我们共同保护知识产权。\n如果购买者有侵权行为，我们可能对该用户实施包括但不限于关闭该帐号等维权措施，并可能追究法律责任。\n图灵社区会员 人民邮电出版社（zhanghaichuan@ptpress.com.cn） 专享 尊重版权\n版权声明\n译者序\n序\n前言\n关于本书\n章节安排\n编码规范及代码下载\n作者在线\n关于封面图\n电子书\n致谢\n第 1 章　入门\n1.1　Spring风云再起\n1.1.1　重新认识Spring\n1.1.2　Spring Boot精要\n1.1.3　Spring Boot不是什么\n1.2　Spring Boot入门\n1.2.1　安装Spring Boot CLI\n1.2.2　使用Spring Initializr初始化Spring Boot项目\n1.3　小结\n第 2 章　开发第一个应用程序\n2.1　运用Spring Boot\n2.1.1　查看初始化的Spring Boot新项目\n2.1.2　Spring Boot项目构建过程解析\n2.2　使用起步依赖\n2.2.1　指定基于功能的依赖\n2.2.2　覆盖起步依赖引入的传递依赖\n2.3　使用自动配置\n2.3.1　专注于应用程序功能\n2.3.2　运行应用程序\n2.3.3　刚刚发生了什么\n2.4　小结\n第 3 章　自定义配置\n3.1　覆盖Spring Boot自动配置\n3.1.1　保护应用程序\n3.1.2　创建自定义的安全配置\n3.1.3　掀开自动配置的神秘面纱\n3.2　通过属性文件外置配置\n3.2.1　自动配置微调\n3.2.2　应用程序Bean的配置外置\n3.2.3　使用Profile进行配置\n3.3　定制应用程序错误页面\n3.4　小结\n第 4 章　测试\n4.1　集成测试自动配置\n4.2　测试Web应用程序\n4.2.1　模拟Spring MVC\n4.2.2　测试Web安全\n4.3　测试运行中的应用程序\n4.3.1　用随机端口启动服务器\n4.3.2　使用Selenium测试HTML页面\n4.4　小结\n第 5 章　Groovy与Spring Boot CLI\n5.1　开发Spring Boot CLI应用程序\n5.1.1　设置CLI项目\n5.1.2　通过Groovy消除代码噪声\n5.1.3　发生了什么\n5.2　获取依赖\n5.2.1　覆盖默认依赖版本\n5.2.2　添加依赖仓库\n5.3　用CLI运行测试\n5.4　创建可部署的产物\n5.5　小结\n第 6 章　在Spring Boot中使用Grails\n6.1　使用GORM进行数据持久化\n6.2　使用Groovy Server Pages定义视图\n6.3　结合Spring Boot与Grails 3\n6.3.1　创建新的Grails项目\n6.3.2　定义领域模型\n6.3.3　开发Grails控制器\n6.3.4　创建视图\n6.4　小结\n第 7 章　深入Actuator\n7.1　揭秘Actuator的端点\n7.1.1　查看配置明细\n7.1.2　运行时度量\n7.1.3　关闭应用程序\n7.1.4　获取应用信息\n7.2　连接Actuator的远程shell\n7.2.1　查看autoconfig报告\n7.2.2　列出应用程序的Bean\n7.2.3　查看应用程序的度量信息\n7.2.4　调用Actuator端点\n7.3　通过JMX监控应用程序\n7.4　定制Actuator\n7.4.1　修改端点ID\n7.4.2　启用和禁用端点\n7.4.3　添加自定义度量信息\n7.4.4　创建自定义跟踪仓库\n7.4.5　插入自定义健康指示器\n7.5　保护Actuator端点\n7.6　小结\n第 8 章　部署Spring Boot应用程序\n8.1　衡量多种部署方式\n8.2　部署到应用服务器\n8.2.1　构建WAR文件\n8.2.2　创建生产Profile\n8.2.3　开启数据库迁移\n8.3　推上云端\n8.3.1　部署到Cloud Foundry\n8.3.2　部署到Heroku\n8.4　小结\n附录 A　Spring Boot开发者工具\nA.1　自动重启\nA.2　LiveReload\nA.3　远程开发\nA.4　默认的开发时属性\nA.5　全局配置开发者工具\n附录 B　Spring Boot起步依赖\n附录 C　配置属性\n附录 D　Spring Boot依赖\n版权声明\nSpring Boot in Action\nSimplified Chinese language edition, copyright © 2016 by Posts & Telecom Press, All rights reserved.\n　\n本书中文简体字版由Manning Publications授权人民邮电出版社独家出版。未经出版者书面许可，不得以任何方式复制或抄袭本书内容。\n版权所有，侵权必究。\n译者序\nExpert one-on-one J2EE Development without EJB\n刚才打开Spring的官网，已经能看到Spring Framework 5.0.0 SNAPSHOT的身影了，而Spring的家族也早就不再是Spring Framework一枝独秀，Spring Data、Spring Batch、Spring Security等一大堆名字让人看得眼花缭乱。其中最引人瞩目的无疑就是Spring Boot了，它正是本书的主角。\nSpring Boot从无数知名企业的实践中吸取经验，总结并落实到框架中。如果说Spring Framework的目标是帮助开发者写出好的系统，那Spring Boot的目标就是帮助开发者用更少的代码，更快地写出好的生产系统。\nSpring Boot为开发者带来了更好的开发体验，但写完代码只是万里长征路上的一小步，后续的运维工作才是让很多人真正感到无助的。Spring Boot在运维方面做了很多工作，部署、监控、度量，无一不在其涉猎范围之内，结合Spring Cloud后还可以轻松地实现服务发现、服务降级等功能。\n2014年，Spring Source的Josh Long在向我介绍Spring Boot时，我不断重复一句话：“这个功能我们也做了。”的确，国内的百度、阿里、腾讯，国外的Amazon、Facebook、Twitter、Netflix等一票大公司都在框架和系统建设上有大量投入，为了提升性能和可用性，大家做了很多卓有成效的工作。现在，Spring Boot让人人都能享受业内顶级公司的“福利”，站在巨人的肩膀之上，想想都让人觉得兴奋。\n说起为何想要翻译本书，那只能说是缘分使然。笔者当年在机缘巧合之下与Spring结缘，也因它结识了很多朋友。毫不夸张地说，是Spring开启了我的作译者生涯，先后参与了Spring官方文档、《Spring专业开发指南》和《Spring攻略》的翻译。\n本以为在完成了30岁前每年翻译一本书的目标后，我应该不会再去翻译什么东西了，甚至在向图灵的编辑推荐本书时，我都没有想到最后会是自己来翻译这本书。不得不感叹一声，缘分就是如此妙不可言的东西。相信后续Spring Boot会有更好地发展，因为它牢牢抓住了开发者的需求。Craig的《Spring实战》已经到了第4版，本书应该也会有第2版，此时此刻正捧着本书的您会成为它的译者吗？至少让我们一起来为自己喜欢的技术贡献一份力量吧。\n　\n丁雪丰\n2016年7月于上海\n序\n2014年春天，Netflix的交付工程团队开始着手实现一个伟大的目标——通过一个软件平台来实现端到端的全局持续交付，该平台有利于系统的可扩展性及弹性。为了满足Netflix的交付与部署需要，我的团队曾构建了两套不同的应用程序，但这两套应用程序都有演变成庞然大物的趋势，而且都没能满足灵活性和弹性的目标。更重要的是，这些庞大的应用程序最终还拖了我们的后腿，让我们跟不上合作伙伴的创新步伐。用户开始回避我们的工具，而不是使用它们。\n很明显，如果想要向公司证明自己的真正价值并快速创新，我们需要把庞然大物分解成小的独立服务，这些服务要能随时发布。拥抱微服务架构给我们带来了希望，让我们能实现灵活性与弹性的双重目标。但是我们需要在一个可靠的基础上实现这一架构，它要能实现真正的并发、合理的监控、可靠易用的服务发现，运行时还要有极好的性能。\n我们要在JVM上寻找一款框架，它要直接提供快速开发的能力和强大的运维能力。最终，我们找到了Spring Boot。\nSpring Boot能用寥寥数行代码构建一套基于Spring并满足生产要求的服务，不费吹灰之力！实际上，一个简单的Spring Boot Hello World应用程序能放进一条推文里，这在短短几年之前还是完全不可能的事情。它还自带了不少非功能性的特性，比如安全、度量、健康检查、内嵌服务器和外置配置，这些都让选择Spring Boot成为了一件顺理成章的事情。\n然而，踏上Spring Boot之旅后，我们却发现手头没有好的文档。要搞明白怎么利用好框架的特性，只能依靠源码，这可不是个让人愉快的办法。\nManning那本著名的《Spring实战》的作者再度接受挑战，将Spring Boot的核心用法写成了另一本好书，对此我一点都不吃惊。毫无疑问，Craig和Manning的团队又做成了一件了不起的大事！正如我们所料，《Spring Boot实战》是一本通俗易懂的好书。\n从第1章引人入胜的介绍以及富有传奇色彩的90字符推文应用程序，一直到第7章对Spring Boot的Actuator（提供了很多生产应用程序所需的神奇的运维特性）的深度分析，《Spring Boot实战》做到了知无不言，言无不尽。实际上，对我而言，第7章对Actuator的深度分析解答了不少问题，这些问题自一年多以前我开始使用Spring Boot后，就一直萦绕在我的脑海里。第8章对部署选项的透彻研究让我大开眼界，了解到Cloud Foundry在云部署方面是如此简便。第4章是我最喜欢的章节之一，Craig揭示了很多强大的选项，它们能很方便地测试Spring Boot应用程序。从一开始我就惊喜于Spring的测试特性，而Spring Boot将它们发挥得淋漓尽致。\n正如上文中我所说的那样，Spring Boot正是十几年来Java社区所探寻的那种框架。它那简单易用的开发特性和开箱即用的运维能力，让Java开发再度趣味横生。我欣然向大家宣布，Spring和Spring Boot已经成为了Netflix新持续交付平台的基础。而且，Netflix的其他团队也参考了我们的做法，因为他们也看到了Spring Boot的巨大益处。\n我怀着兴奋与激动的心情，向大家强烈推荐Craig的书。作为Spring Boot的文档，本书可谓通俗易懂、趣味横生，是Spring Boot征服Java社区后，大家翘首以盼的佳作。Craig浅显易懂的写作风格，对Spring Boot核心特性与功能的全面分析，一定能让读者对Spring Boot有个彻底的认识（而且在满心欢喜的同时还肃然起敬）。\nCraig加油！Manning出版社加油！那些开发出Spring Boot的天才开发者们加油！请你们一定坚持下去！正是你们确保了JVM的光明未来。\nAndrew Glover\nNetflix交付工程团队经理\n前言\n1\n1\n关于这届世博会里迪士尼相关的信息，详见\nhttp://www.dwz.cn/2Hrvyh\n中的Disney influence部分。——译者注\n2\n2\n关于这个游乐设施，详见\nhttp://www.yesterland.com/progress.html\n的介绍。——译者注\n在每幕表演中，父亲（也是演出的叙述者）都会讲述最新的发明，并带上一句“这玩意儿不能更好了”，到头来却发现随着技术的进步，它的确变得更好了。\n比起这场舞台演出，Spring的历史要短得多。但是对于Spring，我的感受和“演进老爹”（Progress Dad）对20世纪的体会相似。似乎每个Spring应用程序都让开发者的生活更上一个台阶，仅从Spring组件的声明和织入方式就能看出端倪。让我们来看看Spring历史中的一些演化历程。\nSpring 1.0的出现彻底改变了我们开发企业级Java应用程序的方式。Spring的依赖注入与声明式事务意味着组件之间再也不存在紧耦合，再也不用重量级的EJB了。这玩意儿不能更好了。\n到了Spring 2.0，我们可以在配置里使用自定义的XML命名空间，更小、更简单易懂的配置文件让Spring本身更便于使用。这玩意儿不能更好了。\n@Component\n@Autowired\n@Enable\nSpring 4.0对条件化配置提供了支持，根据应用程序的Classpath、环境和其他因素，运行时决策将决定使用哪些配置，忽略哪些配置。那些决策不需要在构建时通过编写脚本确定了；以前会把选好的配置放在部署的包里，现在情况不同了。这玩意儿不能更好了。\n现在轮到Spring Boot了。虽然Spring的每个版本都让我们觉得一切都不能更好了，但Spring Boot还是向我们证明了Spring仍然有巨大的潜力。事实上，我相信Spring Boot是长久以来Java开发历程里最意义深刻、激动人心的东西。\n以历代Spring Framework的进步为基础，Spring Boot实现了自动配置，这让Spring能够智能探测正在构建何种应用程序，自动配置必要的组件以满足应用程序的需要。对于那些常见的配置场景，不再需要显式地编写配置了，Spring会替你料理好一切。\n选择在构建时和运行时要包含在应用程序里的库，往往要花费不少工夫，而Spring Boot的起步依赖（starter dependency）将常用依赖聚合在一起，借此简化一切。它不仅简化了你的构建说明，还让你不必苦思冥想特定库和版本。\npublic\nprivate\nreturn\nimport\nSpring Boot的Actuator让你能一窥应用程序运行时的内部工作细节，看看Spring应用程序上下文里都有哪些Bean，Spring MVC控制器是怎么与路径映射的，应用程序都能取到哪些配置属性，诸如此类。\nSpring Boot为我们带来了这么多奇妙的特性，这玩意儿当然不能更好了！\n本书中你将看到，Spring Boot着实让Spring比以前更好了。我们将一同去了解自动配置、Spring Boot起步依赖、Spring Boot CLI和Actuator。我们还会去摆弄一下Grails的最新版本，它就是基于Spring Boot的。临近末尾，你也许会觉得Spring不可能更好了。\n如果说迪士尼的“文明演进之旋转木马”告诉了我们什么事情，那就是当我们觉得什么东西不可能更好了的时候，它一定会变得更好。Spring Boot的进步正在带来越来越大的益处。真的难以想象Spring还能变得更好，但它肯定会更好。毫无疑问，Spring的前景总是美好的。\n关于本书\nSpring Boot旨在简化Spring的开发，就这点而论，Spring Boot涉及了Spring的方方面面。用一本书讲清楚Spring Boot的所有用法是不可能的，因为这必须涵盖Spring本身所支持的各种技术。所以《Spring Boot实战》把Spring Boot大致分为4个主题：自动配置、起步依赖、命令行界面和Actuator。书中还会讲到一些必要的Spring特性，但重点还是在Spring Boot上。\n《Spring Boot实战》面向的是全体Java开发者。虽然读者需要有一些Spring背景，但Spring Boot让那些新接触Spring的人也更容易上手。然而，因为本书的重点是Spring Boot，不会深入Spring本身，所以手边再准备一本Spring读物也许效果会更好，比如说《Spring实战（第4版）》。\n章节安排\n《Spring Boot实战》全书分为8章。\n第1章会对Spring Boot进行概述，内容涵盖最基本的自动配置、起步依赖、命令行界面和Actuator。\n第2章会进一步深入Spring Boot，重点介绍自动配置和起步依赖。在这一章里，你将用很少的显式配置来构建一个完整的Spring应用程序。\n第3章是对第2章的补充，演示了如何通过设置应用程序属性来改变自动配置，或者在自动配置无法满足需要时彻底覆盖它。\n在第4章里我们会看到如何为Spring Boot应用程序编写自动化集成测试。\n在第5章里你将看到一种有别于传统Java开发方式的做法，Spring Boot CLI能让你通过命令行来运行应用程序，这个应用程序完全是由Groovy脚本构成的。\n讲到Groovy，第6章会介绍Grails 3，这是Grails框架的最新版本，它基于Spring Boot。\n在第7章里你将看到如何通过Spring Boot的Actuator了解运行中的应用程序，以及它是如何工作的。你还会看到如何使用Actuator的Web端点、远程shell和JMX MBean对应用程序一窥究竟。\n第8章讨论了各种部署Spring Boot应用程序的方法，包括传统的应用程序服务器部署和云部署。\n编码规范及代码下载\nDispatcherServlet\nwww.manning.com/books/spring-boot-in-action\n作者在线\nwww.manning.com/books/spring-boot-in-action\nManning向读者承诺，为读者与读者之间以及读者与作者之间的沟通建立桥梁。但Manning并不保证作者在论坛中的参与程度，他们在论坛上投入多少精力是全凭自愿的（并且是无偿的）。我们强烈建议你向作者问些有挑战性的问题，让他有兴趣留在论坛里。\n只要本书仍在销售，你就能在出版商的网站上查找作者在线论坛及其讨论归档。\n关于封面图\nA Collection of the Dresses of Different Nations, Ancient and Modern\n着迷于远方的大陆，为了消遣而去旅行，这在18世纪晚期还是相对新鲜的现象，而像这套服饰集这样的合集在当时非常流行，向观光客和足不出户的“游客”介绍其他国家的居民。Jefferys著作中异彩纷呈的图画生动地描绘了200年前世界各国的特色。自那以后，服饰文化发生了变化，各个国家与地区之间一度非常丰富的多样性已逐渐消失。现在，不同大洲的居民往往很难通过服饰来分辨了。也许，我们该乐观一点儿，我们用文化和视觉上的多样性换来了更多样的人生，或者说是更多样、更有趣、更智能的科技人生。\n在很难从外观上分辨不同计算机读物的年代里，Manning出版社脱颖而出，在图书封面上采用了两个世纪以前各地居民丰富多样的形象，以此体现了计算机行业别出心裁、独具创新的特性。这些都得归功于Jeffreys的绘画。\n电子书\n扫描如下二维码，即可购买本书电子版。\n致谢\n本书将告诉你Spring Boot如何自动处理应用程序幕后的各种杂事，让你专注于做那些使应用程序独特的工作。从很多方面来说，这和本书的诞生经历非常类似。很多人帮我操心了不少事情，让我能专心撰写本书的内容。我要感谢Manning出版社的Cynthia Kane、Robert Casazza、Andy Carroll、Corbin Collins、Kevin Sullivan、Mary Piergies、Janet Vail、Ozren Harlovic以及Candace Gillhoolley，他们做了很多幕后工作。\n编写测试能让你知道自己的软件是否实现了目标。同样，很多人在本书撰写过程中就审稿并提供了反馈意见，他们让我确信本书没有偏离方向。为此，我要感谢Aykut Acikel、Bachir Chihani、Eric Kramer、Francesco Persico、Furkan Kamaci、Gregor Zurowski、Mario Arias、Michael A. Angelo、Mykel Alvis、Norbert Kuchenmeister、Phil Whiles、Raphael Villela、Sam Kreter、Travis Nelson、Wilfredo R. Ronsini Jr.以及William Fly。还要特别感谢John Guthrie在原稿即将付印前的最终技术审校，也感谢Andrew Glover为本书作序。\n当然，如果没有Spring团队中各位天才成员的杰出工作，本书就不可能也不必问世。你们太棒了！能成为改变软件开发方式的团队的成员，我十分激动。\n1\n1\n这是一个面向JVM软件开发者的活动，详见\nhttps://nofluffjuststuff.com\n。——译者注\n没有那些组成文字的字母，像这样的书也不可能出现。因此，就和我之前的书一样，我想借此机会感谢发明第一个字母表的腓尼基人。\n最后，我要隆重感谢我的挚爱，我美丽的妻子Raymie，还有我了不起的女儿Maisy和Madi。你们又一次忍受我从事一个写作项目。现在，书写完了，我们该去迪士尼世界了，你们说呢？\n第 1 章　入门\n本章内容\nSpring Boot简化Spring应用程序开发\nSpring Boot的基本特性\nSpring Boot工作区的设置\nSpring Framework已有十余年的历史了，已成为Java应用程序开发框架的事实标准。在如此悠久的历史背景下，有人可能会认为Spring放慢了脚步，躺在了自己的荣誉簿上，再也做不出什么新鲜的东西，或者是让人激动的东西。甚至有人说，Spring是遗留项目，是时候去看看其他创新的东西了。\n这些人说得不对。\nSpring的生态圈里正在出现很多让人激动的新鲜事物，涉及的领域涵盖云计算、大数据、无模式的数据持久化、响应式编程以及客户端应用程序开发。\n在过去的一年多时间里，最让人兴奋、回头率最高、最能改变游戏规则的东西，大概就是Spring Boot了。Spring Boot提供了一种新的编程范式，能在最小的阻力下开发Spring应用程序。有了它，你可以更加敏捷地开发Spring应用程序，专注于应用程序的功能，不用在Spring的配置上多花功夫，甚至完全不用配置。实际上，Spring Boot的一项重要工作就是让Spring不再成为你成功路上的绊脚石。\n本书将探索Spring Boot开发的诸多方面，但在开始前，我们先大概了解一下Spring Boot的功能。\n1.1　Spring风云再起\nSpring诞生时是Java企业版（Java Enterprise Edition，JEE，也称J2EE）的轻量级代替品。无需开发重量级的Enterprise JavaBean（EJB），Spring为企业级Java开发提供了一种相对简单的方法，通过依赖注入和面向切面编程，用简单的Java对象（Plain Old Java Object，POJO）实现了EJB的功能。\n虽然Spring的组件代码是轻量级的，但它的配置却是重量级的。一开始，Spring用XML配置，而且是很多XML配置。Spring 2.5引入了基于注解的组件扫描，这消除了大量针对应用程序自身组件的显式XML配置。Spring 3.0引入了基于Java的配置，这是一种类型安全的可重构配置方式，可以代替XML。\nDispatcherServlet\n所有这些配置都代表了开发时的损耗。因为在思考Spring特性配置和解决业务问题之间需要进行思维切换，所以写配置挤占了写应用程序逻辑的时间。和所有框架一样，Spring实用，但与此同时它要求的回报也不少。\n除此之外，项目的依赖管理也是件吃力不讨好的事情。决定项目里要用哪些库就已经够让人头痛的了，你还要知道这些库的哪个版本和其他库不会有冲突，这难题实在太棘手。\n并且，依赖管理也是一种损耗，添加依赖不是写应用程序代码。一旦选错了依赖的版本，随之而来的不兼容问题毫无疑问会是生产力杀手。\nSpring Boot让这一切成为了过去。\n1.1.1　重新认识Spring\n假设你受命用Spring开发一个简单的Hello World Web应用程序。你该做什么？我能想到一些基本的需要。\n一个项目结构，其中有一个包含必要依赖的Maven或者Gradle构建文件，最起码要有Spring MVC和Servlet API这些依赖。\nWebApplicationInitializer\nDispatcherServlet\n一个启用了Spring MVC的Spring配置。\n一个控制器类，以“Hello World”响应HTTP请求。\n一个用于部署应用程序的Web应用服务器，比如Tomcat。\n最让人难以接受的是，这份清单里只有一个东西是和Hello World功能相关的，即控制器，剩下的都是Spring开发的Web应用程序必需的通用样板。既然所有Spring Web应用程序都要用到它们，那为什么还要你来提供这些东西呢？\n假设这里只需要控制器。代码清单1-1所示基于Groovy的控制器类就是一个简单而完整的Spring应用程序。\n代码清单1-1\n这里没有配置，没有web.xml，没有构建说明，甚至没有应用服务器，但这就是整个应用程序了。Spring Boot会搞定执行应用程序所需的各种后勤工作，你只要搞定应用程序的代码就好。\nHelloController\n想必你已经注意到了，这里甚至没有编译代码，Spring Boot CLI可以运行未经编译的代码。\n之所以选择用Groovy来写这个控制器示例，是因为Groovy语言的简洁与Spring Boot的简洁有异曲同工之妙。但Spring Boot并不强制要求使用Groovy。实际上，本书中的很多代码都是用Java写的，但在恰当的时候，偶尔也会出现一些Groovy代码。\n不要客气，直接跳到1.2.1节吧，看看如何安装Spring Boot CLI，这样你就能试着编写这个小小的Web应用程序了。现在，你将看到Spring Boot的关键部分，看到它是如何改变Spring应用程序的开发方式的。\n1.1.2　Spring Boot精要\nSpring Boot将很多魔法带入了Spring应用程序的开发之中，其中最重要的是以下四个核心。\n自动配置\n起步依赖\n命令行界面\nActuator\n每一个特性都在通过自己的方式简化Spring应用程序的开发。本书会探寻如何将它们发挥到极致，但就目前而言，先简单看看它们都提供了哪些功能吧。\n1. 自动配置\nJdbcTemplate\nJdbcTemplate\nDataSource\nDataSource\nDataSource\nbuild()\nJdbcTemplate\n既然它如此常见，那为什么还要你去写呢？\nJdbcTemplate\nJdbcTemplate\nJdbcTemplate\n2. 起步依赖\n向项目中添加依赖是件富有挑战的事。你需要什么库？它的Group和Artifact是什么？你需要哪个版本？哪个版本不会和项目中的其他依赖发生冲突？\nSpring Boot通过起步依赖为项目的依赖管理提供帮助。起步依赖其实就是特殊的Maven依赖和Gradle依赖，利用了传递依赖解析，把常用库聚合在一起，组成了几个为特定功能而定制的依赖。\n举个例子，假设你正在用Spring MVC构造一个REST API，并将JSON（JavaScript Object Notation）作为资源表述。此外，你还想运用遵循JSR-303规范的声明式校验，并使用嵌入式的Tomcat服务器来提供服务。要实现以上目标，你在Maven或Gradle里至少需要以下8个依赖：\norg.springframework:spring-core\norg.springframework:spring-web\norg.springframework:spring-webmvc\ncom.fasterxml.jackson.core:jackson-databind\norg.hibernate:hibernate-validator\norg.apache.tomcat.embed:tomcat-embed-core\norg.apache.tomcat.embed:tomcat-embed-el\norg.apache.tomcat.embed:tomcat-embed-logging-juli\norg.springframework.boot:spring-boot-starter-web\n1\n1\nSpring Boot起步依赖基本都以\nspring-boot-starter\n打头，随后是直接代表其功能的名字，比如\nweb\n、\ntest\n，下文出现起步依赖的名字时，可能就直接用其前缀后的单词来表示了。——译者注\n比起减少依赖数量，起步依赖还引入了一些微妙的变化。向项目中添加了Web起步依赖，实际上指定了应用程序所需的一类功能。因为应用是个Web应用程序，所以加入了Web起步依赖。与之类似，如果应用程序要用到JPA持久化，那么就可以加入jpa起步依赖。如果需要安全功能，那就加入security起步依赖。简而言之，你不再需要考虑支持某种功能要用什么库了，引入相关起步依赖就行。\n此外，Spring Boot的起步依赖还把你从“需要这些库的哪些版本”这个问题里解放了出来。起步依赖引入的库的版本都是经过测试的，因此你可以完全放心，它们之间不会出现不兼容的情况。\n和自动配置一样，第2章就会深入讨论起步依赖。\n3. 命令行界面\n除了自动配置和起步依赖，Spring Boot还提供了一种很有意思的新方法，可以快速开发Spring应用程序。正如之前在1.1节里看到的那样，Spring Boot CLI让只写代码即可实现应用程序成为可能。\nimport\nRequestMapping\nRestController\nDispatcherServlet\nSpring Boot CLI是Spring Boot的非必要组成部分。虽然它为Spring带来了惊人的力量，大大简化了开发，但也引入了一套不太常规的开发模型。要是这种开发模型与你的口味相去甚远，那也没关系，抛开CLI，你还是可以利用Spring Boot提供的其他东西。不过如果喜欢CLI，你一定想看看第5章，其中深入探讨了Spring Boot CLI。\n4. Actuator\nSpring Boot的最后一块“拼图”是Actuator，其他几个部分旨在简化Spring开发，而Actuator则要提供在运行时检视应用程序内部情况的能力。安装了Actuator就能窥探应用程序的内部情况了，包括如下细节：\nSpring应用程序上下文里配置的Bean\nSpring Boot的自动配置做的决策\n应用程序取到的环境变量、系统属性、配置属性和命令行参数\n应用程序里线程的当前状态\n应用程序最近处理过的HTTP请求的追踪情况\n各种和内存用量、垃圾回收、Web请求以及数据源用量相关的指标\nActuator通过Web端点和shell界面向外界提供信息。如果要借助shell界面，你可以打开SSH（Secure Shell），登入运行中的应用程序，发送指令查看它的情况。\n第7章会详细探索Actuator的功能。\n1.1.3　Spring Boot不是什么\n因为Spring Boot实在是太惊艳了，所以过去一年多的时间里有不少和它相关的言论。原先听到或看到的东西可能给你造成了一些误解，继续学习本书前应该先澄清这些误会。\n首先，Spring Boot不是应用服务器。这个误解是这样产生的：Spring Boot可以把Web应用程序变为可自执行的JAR文件，不用部署到传统Java应用服务器里就能在命令行里运行。Spring Boot在应用程序里嵌入了一个Servlet容器（Tomcat、Jetty或Undertow），以此实现这一功能。但这是内嵌的Servlet容器提供的功能，不是Spring Boot实现的。\n与之类似，Spring Boot也没有实现诸如JPA或JMS（Java Message Service，Java消息服务）之类的企业级Java规范。它的确支持不少企业级Java规范，但是要在Spring里自动配置支持那些特性的Bean。例如，Spring Boot没有实现JPA，不过它自动配置了某个JPA实现（比如Hibernate）的Bean，以此支持JPA。\n最后，Spring Boot没有引入任何形式的代码生成，而是利用了Spring 4的条件化配置特性，以及Maven和Gradle提供的传递依赖解析，以此实现Spring应用程序上下文里的自动配置。\n简而言之，从本质上来说，Spring Boot就是Spring，它做了那些没有它你自己也会去做的Spring Bean配置。谢天谢地，幸好有Spring，你不用再写这些样板配置了，可以专注于应用程序的逻辑，这些才是应用程序独一无二的东西。\n现在，你应该对Spring Boot有了大概的认识，是时候构建你的第一个Spring Boot应用程序了。先从重要的事情开始，该怎么入手呢？\n1.2　Spring Boot入门\n从根本上来说，Spring Boot的项目只是普通的Spring项目，只是它们正好用到了Spring Boot的起步依赖和自动配置而已。因此，那些你早已熟悉的从头创建Spring项目的技术或工具，都能用于Spring Boot项目。然而，还是有一些简便的途径可以用来开启一个新的Spring Boot项目。\n最快的方法就是安装Spring Boot CLI，安装后就可以开始写代码，如代码清单1-1，接着通过CLI来运行就好。\n1.2.1　安装Spring Boot CLI\n如前文所述，Spring Boot CLI提供了一种有趣的、不同寻常的Spring应用程序开发方式。第5章里会详细解释CLI提供的功能。这里先来看看如何安装Spring Boot CLI，这样才能运行代码清单1-1。\nSpring Boot CLI有好几种安装方式。\n用下载的分发包进行安装。\n用Groovy Environment Manager进行安装。\n通过OS X Homebrew进行安装。\n使用MacPorts进行安装。\n我们分别看一下这几种方式。除此之外，还要了解如何安装Spring Boot CLI的命令行补全支持，如果你在BASH或zsh shell里使用CLI，这会非常有用（抱歉了，各位Windows用户）。先来看看如何用分发包手工安装Spring Boot CLI吧。\n1. 手工安装Spring Boot CLI\n安装Spring Boot CLI最直接的方法大约是下载、解压，随后将它的bin目录添加到系统路径里。你可以从以下两个地址下载分发包：\nhttp://repo.spring.io/release/org/springframework/boot/spring-boot-cli/1.3.0.RELEASE/spring-boot-cli-1.3.0.RELEASE-bin.zip\nhttp://repo.spring.io/release/org/springframework/boot/spring-boot-cli/1.3.0.RELEASE/spring-boot-cli-1.3.0.RELEASE-bin.tar.gz\n下载完成之后，把它解压到文件系统的任意目录里。在解压后的目录里，你会找到一个bin目录，其中包含了一个spring.bat脚本（用于Windows环境）和一个spring脚本（用于Unix环境）。把这个bin目录添加到系统路径里，然后就能使用Spring Boot CLI了。\n为Spring Boot建立符号链接\n你可以先浅尝辄止，看看你所安装的CLI版本号：\n如果一切正常，你会看到安装好的Spring Boot CLI的版本号。\n虽然这是手工安装，但一切都很容易，而且不要求你安装任何附加的东西。如果你是Windows用户，也别无选择，这是唯一的安装方式。但如果你使用的是Unix机器，而且想要稍微自动化一点的方式，那么可以试试Software Development Kit Manager。\n2. 使用Software Development Kit Manager进行安装\nhttp://sdkman.io\n跟随输出的指示就能完成SDKMAN的安装。在我的机器上，我在命令行里执行了如下命令：\n注意，用户不同，这条命令也会有所不同。我的用户目录是/Users/habuma，因此这也是shell脚本的根路径。你需要根据实际情况稍作调整。一旦安装好了SDKMAN，就可以用下面的方式来安装Spring Boot CLI了：\n假设一切正常，你将看到Spring Boot的当前版本号。\nlist\nlist\ninstall\nuse\ndefault\n使用SDKMAN来管理Spring Boot CLI有一个好处，你可以便捷地在Spring Boot的不同版本之间切换。这样你可以在正式发布前试用快照版本（snapshot）、里程碑版本（milestone）和尚未正式发布的候选版本（release candidate），试用后再切回稳定版本进行其他工作。\n3. 使用Homebrew进行安装\n如果要在OS X的机器上进行开发，你还可以用Homebrew来安装Spring Boot CLI。Homebrew是OS X的包管理器，用于安装多种不同应用程序和工具。要安装Homebrew，最简单的方法就是运行安装用的Ruby脚本：\nhttp://brew.sh\n2\n2\ntap是向Homebrew添加额外仓库的一种途径。Pivotal是Spring及Spring Boot背后的公司，通过它的tap可以安装Spring Boot。\n在有了Pivotal的tap后，就可以像下面这样安装Spring Boot CLI了：\nHomebrew会把Spring Boot CLI安装到/usr/local/bin，之后可以直接使用。可以通过检查版本号来验证安装是否成功：\n这条命令应该会返回刚才安装的Spring Boot版本号。你也可以运行代码清单1-1看看。\n4. 使用MacPorts进行安装\nhttps://www.macports.org/install.php\n一旦安装好了MacPorts，就可以用以下命令来安装Spring Boot CLI了：\nMacPorts会把Spring Boot CLI安装到/opt/local/share/java/spring-boot-cli，并在/opt/local/bin里放一个指向其可执行文件的符号链接。在安装MacPorts后，/opt/local/bin这个目录应该就在系统路径里了。你可以检查版本号来验证安装是否成功：\n这条命令应该会返回刚才安装的Spring Boot的版本号。你也可以运行代码清单1-1，看看效果如何。\n5. 开启命令行补全\nSpring Boot CLI为基于CLI的应用程序的运行、打包和测试提供了一套好用的命令。而且，每个命令都有好多选项。要记住这些东西实属不易，命令行补全能帮助记忆怎么使用Spring Boot CLI。\n如果用Homebrew安装Spring Boot CLI，那么命令行补全已经安装完毕。但如果是手工安装或者用SDKMAN安装的，那就需要执行脚本或者手工安装。（如果是通过MacPorts安装的Spring Boot CLI，那么你不必考虑命令行补全。）\n你可以在Spring Boot CLI安装目录的shell-completion子目录里找到补全脚本。有两个不同的脚本，一个是针对BASH的，另一个是针对zsh的。要使用BASH的补全脚本，可以在命令行里键入以下命令（假设安装时用的是SDKMAN）：\n这样，在当前的shell里就可以使用Spring Boot CLI的补全功能了，但每次开启一个新的shell都要重新执行一次上面的命令才行。你也可以把这个脚本复制到你的个人或系统脚本目录里，这个目录的位置在不同的Unix里也会有所不同，可以参考系统文档（或Google）了解细节。\nspring\n--\n如果你在Windows上进行开发，或者没有用BASH或zsh，那就无缘使用这些命令行补全脚本了。尽管如此，如果你用的是Spring Boot CLI的shell，那一样也有命令补全：\n和BASH、zsh的命令补全脚本（在BASH/zsh shell里执行的）不同，Spring Boot CLI shell会新开一个特别针对Spring Boot的shell，在里面可以执行各种CLI命令，Tab键也能有命令补全。\nSpring Boot CLI为Spring Boot提供了快速上手和构建简单原型应用程序的途径。稍后将在第8章中讲到，在正确的生产运行时环境下，它也能用于开发生产应用程序。\n3\n3\n只是要放弃那些用到Groovy语言灵活性的特性，比如自动依赖和\nimport\n解析。\n1.2.2　使用Spring Initializr初始化Spring Boot项目\n万事开头难，你需要设置一个目录结构存放各种项目内容，创建构建文件，并在其中加入各种依赖。Spring Boot CLI消除了不少设置工作，但如果你更倾向于传统Java项目结构，那你应该看看Spring Initializr。\nSpring Initializr从本质上来说就是一个Web应用程序，它能为你生成Spring Boot项目结构。虽然不能生成应用程序代码，但它能为你提供一个基本的项目结构，以及一个用于构建代码的Maven或Gradle构建说明文件。你只需要写应用程序的代码就好了。\nSpring Initializr有几种用法。\n通过Web界面使用。\n通过Spring Tool Suite使用。\n通过IntelliJ IDEA使用。\n使用Spring Boot CLI使用。\n下面分别看看这几种用法，先从Web界面开始。\n1. 使用Spring Initializr的Web界面\nhttp://start.spring.io\n表单的头两个问题是，你想用Maven还是Gradle来构建项目，以及使用Spring Boot的哪个版本。程序默认生成Maven项目，并使用Spring Boot的最新版本（非里程碑和快照版本），但你也可以自由选择其他选项。\n表单左侧要你指定项目的一些基本信息。最起码你要提供项目的Group和Artifact，但如果你点击了“Switch to the full version”链接，还可以指定额外的信息，比如版本号和基础包名。这些信息是用来生成Maven的pom.xml文件（或者Gradle的build.gradle文件）的。\n图 1-1　Spring Initializr是生成空Spring项目的Web应用程序，可以视为开发过程的第一步\n表单右侧要你指定项目依赖，最简单的方法就是在文本框里键入依赖的名称。随着你的输入会出现匹配依赖的列表，选中一个（或多个）依赖，选中的依赖就会加入项目。如果找不到你要的依赖，点击“Switch to the full version”就能看到可用依赖的完整列表。\n要是你瞄过一眼附录B，就会发现这里的依赖和Spring Boot起步依赖是对应的。实际上，在这里选中依赖，就相当于告诉Initializr把对应的起步依赖加到项目的构建文件里。（第2章会进一步讨论Spring Boot起步依赖。）\n填完表单，选好依赖，点击“Generate Project”按钮，Spring Initializr就会为你生成一个项目。浏览器将会以ZIP文件的形式（文件名取决于Artifact字段的内容）把这个项目下载下来。根据你的选择，ZIP文件的内容也会略有不同。不管怎样，ZIP文件都会包含一个极其基础的项目，让你能着手使用Spring Boot开发应用程序。\n举例来说，假设你在Spring Initializr里指定了如下信息。\nArtifact：myapp\n包名：myapp\n类型：Gradle项目\n依赖：Web和JPA\n点击“Generate Project”，就能获得一个名为myapp.zip的ZIP文件。解压后的项目结构同图1-2类似。\n图 1-2　Initializr创建的项目，提供了构建Spring Boot应用程序所需的基本内容\n如你所见，项目里基本没有代码，除了几个空目录外，还包含了如下几样东西。\nbuild.gradle：Gradle构建说明文件。如果选择Maven项目，这就会换成pom.xml。\nApplication.java\nmain()\nApplicationTests.java\napplication.properties：一个空的properties文件，你可以根据需要添加配置属性。\n在Spring Boot应用程序中，就连空目录都有自己的意义。static目录放置的是Web应用程序的静态内容（JavaScript、样式表、图片，等等）。还有，稍后你将看到，用于呈现模型数据的模板会放在templates目录里。\n你很可能会把Initializr生成的项目导入IDE。如果你用的IDE是Spring Tool Suite，则可以直接在IDE里创建项目。下面来看看Spring Tool Suite是怎么创建Spring Boot项目的。\n2. 在Spring Tool Suite里创建Spring Boot项目\n4\n4\nSpring Tool Suite是Eclipse IDE的一个发行版，增加了诸多能辅助Spring开发的特性。你可以从\nhttp://spring.io/tools/sts\n下载Spring Tool Suite。\n要在Spring Tool Suite里创建新的Spring Boot应用程序，在File菜单里选中New > Spring Starter Project菜单项，随后Spring Tool Suite会显示一个与图1-3相仿的对话框。\n图 1-3　Spring Tool Suite集成了Spring Initializr，可以在IDE里创建并直接导入Spring Boot项目\n如你所见，这个对话框要求填写的信息和Spring Initializr的Web界面里是一样的。事实上，你在这里提供的数据会被发送给Spring Initializr，用于创建项目ZIP文件，这和使用Web表单是一样的。\n如果你想在文件系统上指定项目创建的位置，或者把它加入IDE里的特定工作集，就点击Next按钮。你会看到第二个对话框，如图1-4所示。\n图 1-4　Spring Starter Project对话框的第2页可以让你指定在哪里创建项目\nLocation指定了文件系统上项目的存放位置。如果你使用Eclipse的工作集来组织项目，那么也可以勾上Add Project to Working Sets这个复选框，选择一个工作集，这样就能把项目加入指定的工作集了。\nhttps://github.com/spring-io/initializr\nhttp://start.spring.io\n一旦把项目导入工作空间，应用程序就可以开发了。在开发的过程中，你会发现Spring Tool Suite针对Spring Boot还有一些锦上添花的功能。比如，可以在Run菜单里选中Run As > Spring Boot Application，在嵌入式服务器里运行你的应用程序。\n注意，Spring Tool Suite是通过REST API与Initializr交互的，因此只有连上Initializr它才能正常工作。如果你的开发机离线，或者Initializr被防火墙阻断了，那么Spring Tool Suite的Spring Starter Project向导是无法使用的。\n3. 在IntelliJ IDEA里创建Spring Boot项目\n5\n5\n你可以从\nhttps://www.jetbrains.com/idea/\n获取IntelliJ IDEA。它是一款商业IDE，这意味着你需要付费使用。但是你可以下载试用版，它对开源项目免费。\n要在IntelliJ IDEA里创建新的Spring Boot应用程序，在File菜单里选择New > Project。你会看到几屏内容（图1-5是第一屏），问的问题和Initializr的Web应用程序以及Spring Tool Suite类似。\n图 1-5　IntelliJ IDEA里Spring Boot初始化向导的第一屏\n在首先显示的这一屏中，在左侧项目选择里选中Spring Initializr，随后会提示你选择一个Project SDK（基本上就是这个项目要用的Java SDK），同时选择Initializr Web服务的位置。除非你在使用自己的Initializr，否则应该不做任何修改直接点Next按钮，之后就到了图1-6。\n图 1-6　在IntelliJ IDEA的Spring Boot初始化向导里指定项目信息\nSpring Boot初始化向导的第二屏要求你提供项目的一些基本信息，比如项目名称、Maven Group和Artifact、Java版本，以及你是想用Maven还是Gradle来构建项目。描述好项目信息之后，点击Next按钮就能看到第三屏了，如图1-7所示。\n图 1-7　在IntelliJ IDEA的Spring Boot初始化向导里选择项目依赖\n第二屏向你询问项目的基本信息，第三屏就开始问你要往项目里添加什么依赖了。和之前一样，屏幕里的复选框和Spring Boot起步依赖是对应的。选完之后点击Next就到了向导的最后一屏，如图1-8所示。\n图 1-8　IntelliJ IDEA的Spring Boot初始化向导的最后一屏\n最后一屏问你项目叫什么名字，还有要在哪里创建项目。一切准备就绪之后，点击Finish按钮，就能在IDE里得到一个空的Spring Boot项目了。\n4. 在Spring Boot CLI里使用Initializr\n如前文所述，如果你想仅仅写代码就完成Spring应用程序的开发，那么Spring Boot CLI是个不错的选择。然而，Spring Boot CLI的功能还不限于此，它有一些命令可以帮你使用Initializr，通过它上手开发更传统的Java项目。\ninit\ninit\ninit\n--dependencies\n-d\n-d\n--build\n--packaging\n-p\ninit\n此处的最后一个参数说明你希望把项目解压到myapp目录里去。\n--extract\n-x\ninit\nhelp\ninit\n--list\n-l\nspring init -l\ninit\nspring help init\ninit\n无论你是用Initializr的Web界面，在Spring Tool Suite里创建项目，还是用Spring Boot CLI来初始化项目，Spring Boot Initializr创建出来的项目都有相似的项目布局，和你之前开发过的Java项目没什么不同。\n1.3　小结\nSpring Boot为Spring应用程序的开发提供了一种激动人心的新方式，框架本身带来的阻力很小。自动配置消除了传统Spring应用程序里的很多样板配置；Spring Boot起步依赖让你能通过库所提供的功能而非名称与版本号来指定构建依赖；Spring Boot CLI将Spring Boot的无阻碍开发模型提升到了一个崭新的高度，在命令行里就能简单快速地用Groovy进行开发；Actuator让你能深入运行中的应用程序，了解Spring Boot做了什么，是怎么做的。\n本章大致概括了Spring Boot的功能。你大概已经跃跃欲试，想用Spring Boot来写个真实的应用程序了吧。这正是我们在下一章里要做的事情。有了Spring Boot提供的诸多功能，最困难的不过是把书翻到第2章。\n第 2 章　开发第一个应用程序\n本章内容\n使用Spring Boot起步依赖\n自动进行Spring配置\n你上次在超市或大型零售商店自己推开门是什么时候？大多数大型商店都安装了带感应功能的自动门，虽然所有门都能让你进入建筑物内，但自动门不用你动手推拉。\n与之类似，很多公共场所的卫生间里都装有自动感应水龙头和自动感应纸巾机。虽然没有超市自动门这么普及，但这些设施同样对你没有太多要求，可以很方便地出水和纸巾。\n说实话，我已经不记得上次看到制冰盒是什么时候了，更不记得自己往里面倒水制冰或者取冰的事了。我的冰箱就是这么神奇，总是有冰，让我随时都能喝上冰水。\n我敢打赌你也能想出无数例子，证明设备让现代生活更加自动化，而不是增加障碍。有了这些自动化的便利设施，你会认为在开发任务里也会出现更多的自动化。但是很奇怪，事实并非如此。\n直到最近，要用Spring创建应用程序，你还需要为框架做很多事情。当然，Spring提供了很多优秀的特性，用于开发令人惊讶的应用程序。但是，你需要自己往项目的构建说明文件里添加各种库依赖，还要自己写配置文件，告诉Spring要做什么。\nSpring Boot将Spring开发的自动化程度提升到了一个新的高度，在本章我们会看到两种新方法：起步依赖和自动配置。在项目中启用Spring不仅枯燥乏味，还让人分神，你将看到这些基础的Spring Boot特性是如何将你解放出来，让你集中精力开发应用程序的。与此同时，你会写一个很小的Spring应用程序，麻雀虽小，五脏俱全，其中会用上Spring Boot。\n2.1　运用Spring Boot\n你正在阅读本书，说明你是一位读书人。也许你是一个书虫，博览群书；也许你只读自己需要的东西，拿起本书只是为了知道怎么用Spring开发应用程序。\n1\n1\n如果你不是一个读书人，就把书换成想看的电影、想去的餐厅，只要合适自己就好。\n在本书中，我们会构建一个简单的阅读列表应用程序。在这个程序里，用户可以输入想读的图书信息，查看列表，删除已经读过的书。我们将使用Spring Boot来辅助快速开发，各种繁文缛节越少越好。\n开始前，我们需要先初始化一个项目。在第1章里，我们看到了好几种从Spring Initializr开始Spring Boot开发的方法。因为选择哪种方法都行，所以要选个最合适的，着手用Spring Boot开发就好了。\n从技术角度来看，我们要用Spring MVC来处理Web请求，用Thymeleaf来定义Web视图，用Spring Data JPA来把阅读列表持久化到数据库里，姑且先用嵌入式的H2数据库。虽然也可以用Groovy，但是我们还是先用Java来开发这个应用程序吧。此外，我们使用Gradle作为构建工具。\n无论是用Web界面、Spring Tool Suite还是IntelliJ IDEA，只要用了Initializr，你就要确保勾选了Web、Thymeleaf和JPA这几个复选框。还要记得勾上H2复选框，这样才能在开发应用程序时使用这个内嵌式数据库。\n至于项目元信息，就随便你写了。以阅读列表为例，我创建项目时使用了图2-1中的信息。\n图 2-1　通过Initializr的Web界面初始化阅读列表应用程序\n如果你创建项目时用的是Spring Tool Suite或者IntelliJ IDEA，那么把图2-1的内容适配成IDE需要的东西就好了。\n另一方面，如果用Spring Boot CLI来初始化应用程序，可以在命令行里键入以下内容：\ninit\n项目创建完毕后，你应该能看到一个类似图2-2的项目结构。\n图 2-2　初始化后的readinglist项目结构\n这个项目结构基本上和第1章里Initializr生成的结构是一样的，只不过你现在真的要去开发应用程序了，所以让我们先放慢脚步，仔细看看初始化的项目里都有什么东西。\n2.1.1　查看初始化的Spring Boot新项目\n图2-2中值得注意的第一件事是，整个项目结构遵循传统Maven或Gradle项目的布局，即主要应用程序代码位于src/main/java目录里，资源都在src/main/resources目录里，测试代码则在src/test/java目录里。此刻还没有测试资源，但如果有的话，要放在src/test/resources里。\n再进一步，你会看到项目里还有不少文件。\nbuild.gradle：Gradle构建说明文件。\nReadingListApplication.java\napplication.properties\nReadingListApplicationTests.java\nReadingListApplication.java\n1. 启动引导Spring\nReadingListApplication\n代码清单2-1\nReadingListApplication.java\n@SpringBootApplication\n@SpringBootApplication\n@Configuration\n@ComponentScan\n@Controller\n@EnableAutoConfiguration\n@Abracadabra\n2\n2\nabracadabra的意思是咒语。——译者注\nReadingListApplication\n@SpringBootApplication\nReadingListApplication\nmain()\nSpringApplication.run()\nReadingListApplication\nbootRun\nbootRun\njava\nhttp://localhost:8080\nReadingListApplication.java\n@Configuration\nReadingListApplication.java\n2. 测试Spring Boot应用程序\nReadingListApplicationTests\n代码清单2-2\n@SpringApplicationConfiguration\n@ContextConfiguration\n@SpringApplicationConfiguration\nReadingListApplicationTests\n@SpringApplicationConfiguration\nReadingListApplication\nReadingListApplicationTests\ncontextLoads()\nReadingListApplication\ncontextLoads()\n3. 配置应用程序属性\nInitializr为你生成的application.properties文件是一个空文件。实际上，这个文件完全是可选的，你大可以删掉它，这不会对应用程序有任何影响，但留着也没什么问题。\n稍后，我们肯定有机会向application.properties里添加几个条目。但现在，如果你想小试牛刀，可以加一行看看：\n加上这一行，嵌入式Tomcat的监听端口就变成了8000，而不是默认的8080。你可以重新运行应用程序，看看是不是这样。\napplication.properties\napplication.properties\n我们差不多已经把初始化的项目介绍完了，还剩最后一样东西，让我们来看看Spring Boot应用程序是如何构建的。\n2.1.2　Spring Boot项目构建过程解析\nSpring Boot应用程序的大部分内容都与其他Spring应用程序没有什么区别，与其他Java应用程序也没什么两样，因此构建一个Spring Boot应用程序和构建其他Java应用程序的过程类似。你可以选择Gradle或Maven作为构建工具，描述构建说明文件的方法和描述非Spring Boot应用程序的方法相似。但是，Spring Boot在构建过程中耍了些小把戏，在此需要做个小小的说明。\nSpring Boot为Gradle和Maven提供了构建插件，以便辅助构建Spring Boot项目。代码清单2-3是Initializr创建的build.gradle文件，其中应用了Spring Boot的Gradle插件。\n代码清单2-3\n另一方面，要是选择用Maven来构建应用程序，Initializr会替你生成一个pom.xml文件，其中使用了Spring Boot的Maven插件，如代码清单2-4所示。\n代码清单2-4\nbootRun\nspring-boot:run\njava -jar\n<dependency>\n遗憾的是，Gradle并没有Maven这样的依赖管理功能，为此Spring Boot Gradle插件提供了第三个特性，它为很多常用的Spring及其相关依赖模拟了依赖管理功能。其结果就是，代码清单2-3的build.gradle里也没有为各项依赖指定版本。\nspring-boot-starter-\n2.2　使用起步依赖\n要理解Spring Boot起步依赖带来的好处，先让我们假设它们尚不存在。如果没用Spring Boot的话，你会向项目里添加哪些依赖呢？要用Spring MVC的话，你需要哪个Spring依赖？你还记得Thymeleaf的Group和Artifact ID吗？你应该用哪个版本的Spring Data JPA呢？它们放在一起兼容吗？\n看来如果没有Spring Boot起步依赖，你就有不少功课要做。而你想要做的只不过是开发一个Spring Web应用程序，使用Thymeleaf视图，通过JPA进行数据持久化。但在开始编写第一行代码之前，你得搞明白，要支持你的计划，需要往构建说明里加入哪些东西。\n考虑再三之后（也许你还从其他有相似依赖的应用程序构建说明中复制粘贴了不少内容），你的Gradle构建说明里大概会有下面这些东西：\n这段依赖列表不错，应该能正常工作，但你是怎么知道的？你怎么保证你选的这些版本能相互兼容？也许可以，但构建并运行应用程序之前你是不知道的。再说了，你怎么知道这个列表是完整的？在一行代码都没写的情况下，你离开始构建还有很长的路要走。\n让我们退一步再想想，我们要做什么。我们要构建一个拥有如下功能的应用程序。\n这是一个Web应用程序。\n它用了Thymeleaf。\n它通过Spring Data JPA在关系型数据库里持久化数据。\n如果我们只在构建文件里指定这些功能，让构建过程自己搞明白我们要什么东西，岂不是更简单？这正是Spring Boot起步依赖的功能。\n2.2.1　指定基于功能的依赖\nSpring Boot通过提供众多起步依赖降低项目依赖的复杂度。起步依赖本质上是一个Maven项目对象模型（Project Object Model，POM），定义了对其他库的传递依赖，这些东西加在一起即支持某项功能。很多起步依赖的命名都暗示了它们提供的某种或某类功能。\n举例来说，你打算把这个阅读列表应用程序做成一个Web应用程序。与其向项目的构建文件里添加一堆单独的库依赖，还不如声明这是一个Web应用程序来得简单。你只要添加Spring Boot的Web起步依赖就好了。\n我们还想以Thymeleaf为Web视图，用JPA来实现数据持久化，因此在构建文件里还需要Thymeleaf和Spring Data JPA的起步依赖。\n为了能进行测试，我们还需要能在Spring Boot上下文里运行集成测试的库，因此要添加Spring Boot的test起步依赖，这是一个测试时依赖。\n统统放在一起，就有了这五个依赖，也就是Initializr在Gradle的构建文件里提供的：\n正如先前所见，添加这些依赖的最简单方法就是在Initializr里选中Web、Thymeleaf和JPA复选框。但如果在初始化项目时没有这么做，当然也可以稍后再编辑生成的build.gradle或pom.xml。\n通过传递依赖，添加这四个依赖就等价于加了一大把独立的库。这些传递依赖涵盖了Spring MVC、Spring Data JPA、Thymeleaf等内容，它们声明的依赖也会被传递依赖进来。\n最值得注意的是，这四个起步依赖的具体程度恰到好处。我们并没有说想要Spring MVC，只是说想要构建一个Web应用程序。我们并没有指定JUnit或其他测试工具，只是说我们想要测试自己的代码。Thymeleaf和Spring Data JPA的起步依赖稍微具体一点，但这也只是由于没有更模糊的方法声明这种需要。\n这四个起步依赖只是Spring Boot众多起步依赖中的沧海一粟。附录B罗列出了全部起步依赖，并简要描述了一下它们向项目构建引入了什么。\n我们并不需要指定版本号，起步依赖本身的版本是由正在使用的Spring Boot的版本来决定的，而起步依赖则会决定它们引入的传递依赖的版本。\n不知道自己所用依赖的版本，你多少会有些不安。你要有信心，相信Spring Boot经过了足够的测试，确保引入的全部依赖都能相互兼容。这是一种解脱，只需指定起步依赖，不用担心自己需要维护哪些库，也不必担心它们的版本。\ndependencies\ndependency\ntree\n大部分情况下，你都无需关心每个Spring Boot起步依赖分别声明了些什么东西。Web起步依赖能让你构建Web应用程序，Thymeleaf起步依赖能让你用Thymeleaf模板，Spring Data JPA起步依赖能让你用Spring Data JPA将数据持久化到数据库里，通常只要知道这些就足够了。\n但是，即使经过了Spring Boot团队的测试，起步依赖里所选的库仍有问题该怎么办？如何覆盖起步依赖呢？\n2.2.2　覆盖起步依赖引入的传递依赖\n说到底，起步依赖和你项目里的其他依赖没什么区别。也就是说，你可以通过构建工具中的功能，选择性地覆盖它们引入的传递依赖的版本号，排除传递依赖，当然还可以为那些Spring Boot起步依赖没有涵盖的库指定依赖。\n以Spring Boot的Web起步依赖为例，它传递依赖了Jackson JSON库。如果你正在构建一个生产或消费JSON资源表述的REST服务，那它会很有用。但是，要构建传统的面向人类用户的Web应用程序，你可能用不上Jackson。虽然把它加进来也不会有什么坏处，但排除掉它的传递依赖，可以为你的项目瘦身。\n如果在用Gradle，你可以这样排除传递依赖：\n<exclusions>\n<dependency>\n<exclusions>\n3\n3\n此处提到的版本仅作演示之用，Spring Boot的Web起步依赖所引用的实际Jackson版本由你使用的Spring Boot版本决定。\nMaven总是会用最近的依赖，也就是说，你在项目的构建说明文件里增加的这个依赖，会覆盖传递依赖引入的另一个依赖。\n与之类似，如果你用的是Gradle，可以在build.gradle文件里指明你要的Jackson的版本：\n因为这个依赖的版本比Spring Boot的Web起步依赖引入的要新，所以在Gradle里是生效的。但假如你要的不是新版本的Jackson，而是一个较早的版本呢？Gradle和Maven不太一样，Gradle倾向于使用库的最新版本。因此，如果你要使用老版本的Jackon，则不得不把老版本的依赖加入构建，并把Web起步依赖传递依赖的那个版本排除掉：\n不管什么情况，在覆盖Spring Boot起步依赖引入的传递依赖时都要多加小心。虽然不同的版本放在一起也许没什么问题，但你要知道，起步依赖中各个依赖版本之间的兼容性都经过了精心的测试。应该只在特殊的情况下覆盖这些传递依赖（比如新版本修复了一个bug）。\n现在我们有了一个空的项目结构，构建说明文件也准备好了，是时候开发应用程序了。我们会让Spring Boot来处理配置细节，而我们自己则专注于编写阅读列表功能相关的代码。\n2.3　使用自动配置\n简而言之，Spring Boot的自动配置是一个运行时（更准确地说，是应用程序启动时）的过程，考虑了众多因素，才决定Spring配置应该用哪个，不该用哪个。举几个例子，下面这些情况都是Spring Boot的自动配置要考虑的。\nJdbcTemplate\nDataSource\nJdbcTemplate\nThymeleaf是不是在Classpath里？如果是，则配置Thymeleaf的模板解析器、视图解析器以及模板引擎。\nSpring Security是不是在Classpath里？如果是，则进行一个非常基本的Web安全设置。\n每当应用程序启动的时候，Spring Boot的自动配置都要做将近200个这样的决定，涵盖安全、集成、持久化、Web开发等诸多方面。所有这些自动配置就是为了尽量不让你自己写配置。\n有意思的是，自动配置的东西很难写在书本里。如果不能写出配置，那又该怎么描述并讨论它们呢？\n2.3.1　专注于应用程序功能\n要为Spring Boot的自动配置博得好感，我可以在接下来的几页里向你演示没有Spring Boot的情况下需要写哪些配置。但眼下已经有不少好书写过这些内容了，再写一次并不能让我们更快地写好阅读列表应用程序。\n既然知道Spring Boot会替我们料理这些事情，那么与其浪费时间讨论这些Spring配置，还不如看看如何利用Spring Boot的自动配置，让我们专注于应用程序代码。除了开始写代码，我想不到更好的办法了。\n1. 定义领域模型\n我们应用程序里的核心领域概念是读者阅读列表上的书。因此我们需要定义一个实体类来表示这个概念。代码清单2-5演示了如何定义一本书。\n代码清单2-5\nBook\nBook\n@Entity\nid\n@Id\n@GeneratedValue\n2. 定义仓库接口\nBook\n4\nJpaRepository\n4\n原文这里写的是\nReadingList\n对象，但文中并没有定义这个对象，看代码应该是\nBook\n对象。——译者注\nJpaRepository\nReadingListRepository\nJpaRepository\nfindByReader()\nReadingListRepository\n3. 创建Web界面\n现在，我们定义好了应用程序的领域模型，还有把领域对象持久化到数据库里的仓库接口，剩下的就是创建Web前端了。代码清单2-6的Spring MVC控制器就能为应用程序处理HTTP请求。\n代码清单2-6\nReadingListController\n@Controller\n@RequestMapping\n该控制器有两个方法。\nreadersBooks()\nGET\nBook\nbooks\nreadingList\naddToReadingList()\nPOST\nBook\nBook\nreader\nsave()\nBook\nreadersBooks()\nreadingList\n代码清单2-7\n这个模板定义了一个HTML页面，该页面概念上分为两个部分：页面上方是读者的阅读列表中的图书清单；下方是是一个表单，读者可以从这里添加新书。\n为了美观，Thymeleaf模板引用了一个名为style.css的样式文件，该文件位于src/main/resources/ static目录中，看起来是这样的：\n这个样式表并不复杂，也没有过分追求让应用程序变漂亮，但已经能满足我们的需求了。很快你就会看到，它能用来演示Spring Boot的自动配置功能。\n不管你相不相信，以上就是一个完整的应用程序了——本章已经向你呈现了所有的代码。等一下，回顾一下前几页的内容，你看到什么配置了吗？实际上，除了代码清单2-1里的三行配置（这是开启自动配置所必需的），你不用再写任何Spring配置了。\n虽然没什么Spring配置，但这已经是一个可以运行的完整Spring应用程序了。让我们把它运行起来，看看会怎样。\n2.3.2　运行应用程序\n运行Spring Boot应用程序有几种方法。先前在2.5节里，我们讨论了如何通过Maven和Gradle来运行应用程序，以及如何构建并运行可执行JAR。稍后，在第8章里你将看到如何构建WAR文件，并用传统的方式部署到Java Web应用服务器里，比如Tomcat。\n假设你正使用Spring Tool Suite开发应用程序，可以在IDE里选中项目，在Run菜单里选择Run As > Spring Boot App，通过这种方式来运行应用程序，如图2-3所示。\n图 2-3　在Spring Tool Suite里运行Spring Boot应用程序\n如果一切正常，你的浏览器应该会展现一个空白的阅读列表，下方有一个用于向列表添加新书的表单，如图2-4所示。\n图 2-4　初始状态下的空阅读列表\n接下来，通过表单添加一些图书吧。随后你的阅读列表看起来就会像图2-5这样。\n图 2-5　添加了一些图书后的阅读列表\n再多用用这个应用程序吧。你准备好之后，我们就来看一下Spring Boot是如何做到不写Spring配置代码就能开发整个Spring应用程序的。\n2.3.3　刚刚发生了什么\n如我所说，在没有配置代码的情况下，很难描述自动配置。与其花时间讨论那些你不用做的事情，不如在这一节里关注一下你要做的事——写代码。\n当然，某处肯定是有些配置的。配置是Spring Framework的核心元素，必须要有东西告诉Spring如何运行应用程序。\n在向应用程序加入Spring Boot时，有个名为spring-boot-autoconfigure的JAR文件，其中包含了很多配置类。每个配置类都在应用程序的Classpath里，都有机会为应用程序的配置添砖加瓦。这些配置类里有用于Thymeleaf的配置，有用于Spring Data JPA的配置，有用于Spiring MVC的配置，还有很多其他东西的配置，你可以自己选择是否在Spring应用程序里使用它们。\n所有这些配置如此与众不同，原因在于它们利用了Spring的条件化配置，这是Spring 4.0引入的新特性。条件化配置允许配置存在于应用程序中，但在满足某些特定条件之前都忽略这个配置。\nCondition\nmatches()\nJdbcTemplate\n当你用Java来声明Bean的时候，可以使用这个自定义条件类：\nJdbcTemplateCondition\nMyService\nMyService\nJdbcTemplate\n虽然本例中的条件相当简单，但Spring Boot定义了很多更有趣的条件，并把它们运用到了配置类上，这些配置类构成了Spring Boot的自动配置。Spring Boot运用条件化配置的方法是，定义多个特殊的条件化注解，并将它们用到配置类上。表2-1列出了Spring Boot提供的条件化注解。\n表2-1　自动配置中使用的条件化注解\n条件化注解\n配置生效条件\n@ConditionalOnBean\n配置了某个特定Bean\n@ConditionalOnMissingBean\n没有配置特定的Bean\n@ConditionalOnClass\nClasspath里有指定的类\n@ConditionalOnMissingClass\nClasspath里缺少指定的类\n@ConditionalOnExpression\n给定的Spring Expression Language（SpEL）表达式计算结果为\ntrue\n@ConditionalOnJava\nJava的版本匹配特定值或者一个范围值\n@ConditionalOnJndi\n参数中给定的JNDI位置必须存在一个，如果没有给参数，则要有JNDI\nInitialContext\n@ConditionalOnProperty\n指定的配置属性要有一个明确的值\n@ConditionalOnResource\nClasspath里有指定的资源\n@ConditionalOnWebApplication\n这是一个Web应用程序\n@ConditionalOnNotWebApplication\n这不是一个Web应用程序\nDataSourceAutoConfiguration\nDataSourceAutoConfiguration\n@Configuration\nDataSourceAutoConfiguration\n@ConditionalOnClass\nDataSource\nEmbeddedDatabaseType\nDataSourceAutoConfiguration\nDataSourceAutoConfiguration\nJdbcTemplateConfiguration\nJdbcTemplate Bean\nJdbcTemplateConfiguration\n@Conditional\nDataSourceAvailableCondition\nDataSource\nDataSource\n@Bean\njdbcTemplate()\nJdbcTemplate\n@ConditionalOnMissingBean\nJdbcOperations\nJdbcTemplate\nJdbcTemplate\nDataSourceAutoConfiguration\n自动配置会做出以下配置决策，它们和之前的例子息息相关。\njavax.sql.DataSource\nLocalContainerEntityManagerFactoryBean\nJpaVendorAdapter\n因为Classpath里有Spring Data JPA，所以它会自动配置为根据仓库的接口创建仓库实现。\n因为Classpath里有Thymeleaf，所以Thymeleaf会配置为Spring MVC的视图，包括一个Thymeleaf的模板解析器、模板引擎及视图解析器。视图解析器会解析相对于Classpath根目录的/templates目录里的模板。\nDispatcherServlet\n因为这是一个Spring MVC Web应用程序，所以会注册一个资源处理器，把相对于Classpath根目录的/static目录里的静态内容提供出来。（这个资源处理器还能处理/public、/resources和/META-INF/resources的静态内容。）\n因为Classpath里有Tomcat（通过Web起步依赖传递引用），所以会启动一个嵌入式的Tomcat容器，监听8080端口。\n由此可见，Spring Boot自动配置承担起了配置Spring的重任，因此你能专注于编写自己的应用程序。\n2.4　小结\n通过Spring Boot的起步依赖和自动配置，你可以更加快速、便捷地开发Spring应用程序。起步依赖帮助你专注于应用程序需要的功能类型，而非提供该功能的具体库和版本。与此同时，自动配置把你从样板式的配置中解放了出来。这些配置在没有Spring Boot的Spring应用程序里非常常见。\n虽然自动配置很方便，但在开发Spring应用程序时其中的一些用法也有点武断。要是你在配置Spring时希望或者需要有所不同，该怎么办？在第3章，我们将会看到如何覆盖Spring Boot自动配置，借此达成应用程序的一些目标，还有如何运用类似的技术来配置自己的应用程序组件。\n第 3 章　自定义配置\n本章内容\n覆盖自动配置的Bean\n用外置属性进行配置\n自定义错误页\n能自由选择真是太棒了。如果你订过比萨（有没订过的吗？）就会知道，你完全可以掌控薄饼上放哪些辅料。选定腊肠、意大利辣香肠、青辣椒和额外芝士的时候，你就是在按照自己的要求配置比萨。\n另一方面，大部分比萨店也提供某种形式的自动配置。你可以点荤比萨、素比萨、香辣意大利比萨，或者是自动配置比萨中的极品——至尊比萨。在下单时，你并没有指定具体的辅料，你所点的比萨种类决定了所用的辅料。\n但如果你想要至尊比萨上的全部辅料，还想要加墨西哥胡椒，又不想放蘑菇该怎么办？你偏爱辣食又不喜欢吃菌类，自动配置不适合你的口味，你就只能自己配置比萨了吗？当然不是，大部分比萨店会让你以菜单上已有的选项为基础进行定制。\n使用传统Spring配置的过程，就如同订比萨的时候自己指定全部的辅料。你可以完全掌控Spring配置的内容，可是显式声明应用程序里全部的Bean并不是明智之举。而Spring Boot自动配置就像是从菜单上选一份特色比萨，让Spring Boot处理各种细节比自己声明上下文里全部的Bean要容易很多。\n幸运的是，Spring Boot自动配置非常灵活。就像比萨厨师可以不在你的比萨里放蘑菇，而是加墨西哥胡椒一样，Spring Boot能让你参与进来，影响自动配置的实施。\n本章我们将看到两种影响自动配置的方式——使用显式配置进行覆盖和使用属性进行精细化配置。我们还会看到如何使用Spring Boot提供的钩子引入自定义的错误页。\n3.1　覆盖Spring Boot自动配置\n一般来说，如果不用配置就能得到和显式配置一样的结果，那么不写配置是最直接的选择。既然如此，那干嘛还要多做额外的工作呢？如果不用编写和维护额外的配置代码也行，那何必还要它们呢？\n大多数情况下，自动配置的Bean刚好能满足你的需要，不需要去覆盖它们。但某些情况下，Spring Boot在自动配置时还不能很好地进行推断。\n这里有个不错的例子：当你在应用程序里添加安全特性时，自动配置做得还不够好。安全配置并不是放之四海而皆准的，围绕应用程序安全有很多决策要做，Spring Boot不能替你做决定。虽然Spring Boot为安全提供了一些基本的自动配置，但是你还是需要自己覆盖一些配置以满足特定的安全要求。\n想知道如何用显式的配置来覆盖自动配置，我们先从为阅读列表应用程序添加Spring Security入手。在了解自动配置提供了什么之后，我们再来覆盖基础的安全配置，以满足特定的场景需求。\n3.1.1　保护应用程序\nSpring Boot自动配置让应用程序的安全工作变得易如反掌，你要做的只是添加Security起步依赖。以Gradle为例，应添加如下依赖：\n<dependencies>\n<dependency>\n这样就搞定了！重新构建应用程序后运行即可，现在这就是一个安全的Web应用程序了！Security起步依赖在应用程序的Classpath里添加了Spring Secuirty（和其他一些东西）。Classpath里有Spring Security后，自动配置就能介入其中创建一个基本的Spring Security配置。\n试着在浏览器里打开该应用程序，你马上就会看到HTTP基础身份验证对话框。此处的用户名是user，密码就有点麻烦了。密码是在应用程序每次运行时随机生成后写入日志的，你需要查找日志消息（默认写入标准输出），找到此类内容：\n我不能肯定，但我猜这个特定的安全配置并不是你的理想选择。首先，HTTP基础身份验证对话框有点粗糙，对用户并不友好。而且，我敢打赌你一般不会开发这种只有一个用户的应用程序，而且他还要从日志文件里找到自己的密码。因此，你会希望修改Spring Security的一些配置，至少要有一个好看一些的登录页，还要有一个基于数据库或LDAP（Lightweight Directory Access Protocol）用户存储的身份验证服务。\n让我们看看如何写出Spring Secuirty配置，覆盖自动配置的安全设置吧。\n3.1.2　创建自定义的安全配置\n覆盖自动配置很简单，就当自动配置不存在，直接显式地写一段配置。这段显式配置的形式不限，Spring支持的XML和Groovy形式配置都可以。\nWebSecurityConfigurerAdapter\nSecurityConfig\n代码清单3-1\nSecurityConfig\nWebSecurityConfigurerAdapter\nconfigure()\nSecurityConfig\nconfigure()\n/\nReadingListController\nerror\nconfigure()\nUserDetailsService\nUserDetailsService\nReaderRepository\nfindOne()\n代码清单3-2\nBookRepository\nReaderRepository\nJpaRepository\nReader\nReader\nReader\n代码清单3-3\nReader\nReader\n@Entity\nusername\n@Id\nusername\nReader\nReader\nUserDetails\nReader\ngetAuthorities()\nisAccountNonExpired()\nisAccountNonLocked()\nisCredentialsNonExpired()\nisEnabled()\ntrue\n重新构建并重启应用程序后，你应该就能以读者身份登录应用程序了。\n保持简单\n1\n1\n想要深入了解Spring Security，可以参考《Spring实战（第4版）》中的第9章和第14章。\n再重申一次，想要覆盖Spring Boot的自动配置，你所要做的仅仅是编写一个显式的配置。Spring Boot会发现你的配置，随后降低自动配置的优先级，以你的配置为准。想弄明白这是如何实现的，让我们揭开Spring Boot自动配置的神秘面纱，看看它是如何运作的，以及它是怎么允许自己被覆盖的。\n3.1.3　掀开自动配置的神秘面纱\n正如我们在2.3.3节里讨论的那样，Spring Boot自动配置自带了很多配置类，每一个都能运用在你的应用程序里。它们都使用了Spring 4.0的条件化配置，可以在运行时判断这个配置是该被运用，还是该被忽略。\n@ConditionalOnMissingBean\nDataSourceAutoConfiguration\nJdbcTemplate\n@ConditionalOnMissingBean\njdbcTemplate()\n@Bean\nJdbcTemplate\n@ConditionalOnMissingBean\nJdbcOperations\nJdbcTemplate\nJdbcOperations Bean\njdbcTemplate()\nJdbcOperations\nJdbcTemplate\nJdbcOperations\nJdbcTemplate\nSpringBootWebSecurityConfiguration\nSpringBootWebSecurityConfiguration\n@ConditionalOnClass\n@EnableWebSecurity\n@ConditionalOnWebApplication\n@ConditionalOnMissingBean\nSpringBootWebSecurityConfiguration\n@ConditionalOnMissingBean\nWebSecurityConfiguration\nSecurityConfig\n@EnableWebSecurity\nWebSecurityConfiguration\n@ConditionalOnMissingBean\nSpringBootWebSecurityConfiguration\n@ConditionalOnMissingBean\n3.2　通过属性文件外置配置\n在处理应用安全时，你当然会希望完全掌控所有配置。不过，为了微调一些细节，比如改改端口号和日志级别，便放弃自动配置，这是一件让人羞愧的事。为了设置数据库URL，是配置一个属性简单，还是完整地声明一个数据源的Bean简单？答案不言自明，不是吗？\n事实上，Spring Boot自动配置的Bean提供了300多个用于微调的属性。当你调整设置时，只要在环境变量、Java系统属性、JNDI（Java Naming and Directory Interface）、命令行参数或者属性文件里进行指定就好了。\nspring.main.show-banner\nfalse\n另一种方式是创建一个名为application.properties的文件，包含如下内容：\n或者，如果你喜欢的话，也可以创建名为application.yml的YAML文件，内容如下：\nexport\n请注意，这里用的是下划线而不是点和横杠，这是对环境变量名称的要求。\n实际上，Spring Boot应用程序有多种设置途径。Spring Boot能从多种属性源获得属性，包括如下几处。\n(1) 命令行参数\njava:comp/env\n(3) JVM系统属性\n(4) 操作系统环境变量\nrandom.*\n${random.long}\n(6) 应用程序以外的application.properties或者appliaction.yml文件\n(7) 打包在应用程序内的application.properties或者appliaction.yml文件\n@PropertySource\n(9) 默认属性\n这个列表按照优先级排序，也就是说，任何在高优先级属性源里设置的属性都会覆盖低优先级的相同属性。例如，命令行参数会覆盖其他属性源里的属性。\napplication.properties和application.yml文件能放在以下四个位置。\n(1) 外置，在相对于应用程序运行目录的/config子目录里。\n(2) 外置，在应用程序运行的目录里。\n(3) 内置，在config包内。\n(4) 内置，在Classpath根目录。\n同样，这个列表按照优先级排序。也就是说，/config子目录里的application.properties会覆盖应用程序Classpath里的application.properties中的相同属性。\n此外，如果你在同一优先级位置同时有application.properties和application.yml，那么application.yml里的属性会覆盖application.properties里的属性。\n禁用ascii-art Banner只是使用属性的一个小例子。让我们再看几个例子，看看如何通过常用途径微调自动配置的Bean。\n3.2.1　自动配置微调\n如上所说，有300多个属性可以用来微调Spring Boot应用程序里的Bean。附录C有一个详尽的列表。此处无法逐一描述它们的细节，因此我们就通过几个例子来了解一些Spring Boot暴露的实用属性。\n1. 禁用模板缓存\n如果阅读列表应用程序经过了几番修改，你一定已经注意到了，除非重启应用程序，否则对Thymeleaf模板的变更是不会生效的。这是因为Thymeleaf模板默认缓存。这有助于改善应用程序的性能，因为模板只需编译一次，但在开发过程中就不能实时看到变更的效果了。\nspring.thymeleaf.cache\nfalse\n或者，如果你希望每次运行时都禁用缓存，可以创建一个application.yml，包含以下内容：\n你一定要确保这个文件不会发布到生产环境，否则生产环境里的应用程序就无法享受模板缓存带来的性能提升了。\n作为开发者，在修改模板时始终关闭缓存实在太方便了。为此，可以通过环境变量来禁用Thymeleaf缓存：\n此处使用Thymeleaf作为应用程序的视图，Spring Boot支持的其他模板也能关闭模板缓存，设置这些属性就好了：\nspring.freemarker.cache\nspring.groovy.template.cache\nspring.velocity.cache\ntrue\nfalse\n2. 配置嵌入式服务器\n从命令行（或者Spring Tool Suite）运行Spring Boot应用程序时，应用程序会启动一个嵌入式的服务器（默认是Tomcat），监听8080端口。大部分情况下这样挺好，但同时运行多个应用程序可能会有问题。要是所有应用程序都试着让Tomcat服务器监听同一个端口，在启动第二个应用程序时就会有冲突。\nserver.port\nserver.port\nkeytool\n该工具会询问几个与名字和组织相关的问题，大部分都无关紧要。但在被问到密码时，一定要记住你的选择。在本例中，我选择letmein作为密码。\n现在只需要设置几个属性就能开启嵌入式服务器的HTTPS服务了。可以把它们都配置在命令行里，但这样太不方便了。可以把它们放在application.properties或application.yml里。在application.yml中，它们可能是这样的：\nserver.port\nserver.ssl.key-store\nclasspath: URL\nserver.ssl.key-store-password\nserver.ssl.key-password\n有了这些属性，应用程序就能在8443端口上监听HTTPS请求了。（根据你所用的浏览器，可能会出现警告框提示该服务器无法验证其身份。在开发时，访问的是localhost，这没什么好担心的。）\n3. 配置日志\n大多数应用程序都提供了某种形式的日志。即使你的应用程序不会直接记录日志，你所用的库也会记录它们的活动。\nhttp://logback.qos.ch\nINFO\nINFO\n用其他日志实现替换Logback\n一般来说，你不需要切换日志实现；Logback能很好地满足你的需要。但是，如果决定使用Log4j或者Log4j2，那么你只需要修改依赖，引入对应该日志实现的起步依赖，同时排除掉Logback。\n以Maven为例，应排除掉根起步依赖传递引入的默认日志起步依赖，这样就能排除Logback了：\nconfigurations\n排除默认日志的起步依赖后，就可以引入你想用的日志实现的起步依赖了。在Maven里可以这样添加Log4j：\n在Gradle里可以这样添加Log4j：\n如果你想用Log4j2，可以把spring-boot-starter-log4j改成spring-boot-starter-log4j2。\n要完全掌握日志配置，可以在Classpath的根目录（src/main/resources）里创建logback.xml文件。下面是一个logback.xml的简单例子：\n除了日志格式之外，这个Logback配置和不加logback.xml文件的默认配置差不多。但是，通过编辑logback.xml，你可以完全掌控应用程序的日志文件。哪些配置应该放进logback.xml这个话题不在本书的讨论范围内，请参考Logback的文档以了解更多信息。\n即使如此，你对日志配置最常做的改动就是修改日志级别和指定日志输出的文件。使用了Spring Boot的配置属性后，你可以在不创建logback.xml文件的情况下修改那些配置。\nlogging.level\nWARN\nDEBUG\n另外，你也可以把Spring Security的包名写成一行：\nlogging.path\nloggin.file\n假设应用程序有/var/logs/的写权限，日志就能被写入/var/logs/BookWorm.log。默认情况下，日志文件的大小达到10MB时会切分一次。\n与之类似，这些属性也能在application.properties里设置：\nlogging.config\n虽然一般并不需要改变配置文件的名字，但是如果你想针对不同运行时Profile使用不同的日志配置（见3.2.3节），这个功能会很有用。\n4. 配置数据源\n此时，我们还在开发阅读列表应用程序，嵌入式的H2数据库能很好地满足我们的需要。可是一旦要投放到生产环境，我们可能要考虑更持久的数据库解决方案。\nDataSource\nspring.datasource.driver-class-name\nDataSource\nDataSource\nDataSource\nHikariCP\nCommons DBCP\nCommons DBCP 2\nDataSource\nspring.datasource.jndi-name\nDataSource\nspring.datasource.jndi-name\n有很多影响Spring Boot自动配置组件的方法，只需设置一两个属性即可。但这种配置外置的方法并不局限于Spring Boot配置的Bean。让我们看看如何使用这种属性配置机制来微调自己的应用程序组件。\n3.2.2　应用程序Bean的配置外置\n假设我们在某人的阅读列表里不止想要展示图书标题，还要提供该书的Amazon链接。我们不仅想提供该书的链接，还要标记该书，以便利用Amazon的Associate Program，这样如果有人用我们应用程序里的链接买了书，我们还能收到一笔推荐费。\n这很简单，只需修改Thymeleaf模板，以链接的形式来呈现每本书的标题就可以了：\ntag\n虽然在模板里修改这个值很简单，但这毕竟也是硬编码。现在只在一个模板里链接到Amazon，但后续可能会有更多页面链接到Amazon，于是需要为应用程序添加功能。那样的话，修改Amazon Associate ID就要改动好几个地方。因此，这种细节最好不要放在代码里，要把它们集中在一个地方维护。\n我们可以不在模板里硬编码Amazon Associate ID，而是把它变成模型中的一个值：\nReadingListController\namazonID\nReadingListController\n代码清单3-4\nReadingListController\nReadingListController\nassociateId\nsetAssociateId()\nreadersBooks()\namazonID\nassociateId\nassociateId\nReadingListController\n@ConfigurationProperties\nprefix\nReadingListController\namazon\nReadingListController\namazon\nReadingListController\nassociateId\namazon.associateId\n例如，我们可以在application.properties里设置该属性：\n或者在application.yml里设置：\n或者，我们可以将其设置为环境变量，把它作为命令行参数，或把它加到任何能够设置配置属性的地方。\n开启配置属性\n@ConfigurationProperties\n@EnableConfigurationProperties\n@EnableConfigurationProperties\n@EnableConfigurationProperties\namazon.associateId\namazon.associate_id\namazon.associate-id\n在一个类里收集属性\nReadingListController\n@ConfigurationProperties\nReadingListController\namazon\nReadingListController\nReadingListController\n@ConfigurationProperties\nAmazonProperties\n代码清单3-5\namazon.associateId\nAmazonProperties\nReadingListController\nAmazonProperties\n代码清单3-6\nAmazonProperties\nReadingListController\nReadingListController\nAmazonProperties Bean\n如你所见，配置属性在调优方面十分有用，这里说的调优不仅涵盖了自动配置的组件，还包括注入自有应用程序Bean的细节。但如果我们想为不同的部署环境配置不同的属性又该怎么办？让我们看看如何使用Spring的Profile来设置特定环境的配置。\n3.2.3　使用Profile进行配置\n当应用程序需要部署到不同的运行环境时，一些配置细节通常会有所不同。比如，数据库连接的细节在开发环境下和测试环境下就会不一样，在生产环境下又不一样。Spring Framework从Spring 3.1开始支持基于Profile的配置。Profile是一种条件化配置，基于运行时激活的Profile，会使用或者忽略不同的Bean或配置类。\nSecurityConfig\n@Profile\n@Profile\nproduction\nproduction\nspring.profiles.active\nproduction\nspring.profiles.active\n还可以设置环境变量，将其放入application.properties，或者使用3.2节开头提到的各种方法。\n@Profile\nWARN\nDEBUG\n而你所要做的就是为每个环境分别创建配置。那要怎么做呢？这取决于你用的是属性文件配置还是YAML配置。\n1. 使用特定于Profile的属性文件\n如果你正在使用application.properties，可以创建额外的属性文件，遵循application-{profile}.properties这种命名格式，这样就能提供特定于Profile的属性了。\n在日志这个例子里，开发环境的配置可以放在名为application-development.properties的文件里，配置包含日志级别和输出到控制台：\nWARN\n与此同时，那些并不特定于哪个Profile或者保持默认值（以防万一有哪个特定于Profile的配置不指定这个值）的属性，可以继续放在application.properties里：\n2. 使用多Profile YAML文件进行配置\n如果使用YAML来配置属性，则可以遵循与配置文件相同的命名规范，即创建application{profile}.yml这样的YAML文件，并将与Profile无关的属性继续放在application.yml里。\n但既然用了YAML，你就可以把所有Profile的配置属性都放在一个application.yml文件里。举例来说，我们可以像下面这样声明日志配置：\n---\nspring.profiles\nspring.profiles\ndevelopment\nspring.profile\nproduction\nproduction\nspring.profiles\n除了自动配置和外置配置属性，Spring Boot还有其他简化常用开发任务的绝招：它自动配置了一个错误页面，在应用程序遇到错误时显示。3.3节，我们会介绍Spring Boot的错误页，以及如何定制这个错误页来适应我们的应用程序。\n3.3　定制应用程序错误页面\n错误总是会发生的，那些在生产环境里最健壮的应用程序偶尔也会遇到麻烦。虽然减小用户遇到错误的概率很重要，但让应用程序展现一个好的错误页面也同样重要。\n近年来，富有创意的错误页已经成为了一种艺术。如果你曾见到过GitHub.com的星球大战错误页，或者是DropBox.com的Escher立方体错误页的话，你就能明白我在说什么了。\n我不知道你在使用阅读列表应用程序时有没有碰到错误，如果有的话，你看到的页面应该和图3-1里的很像。\nSpring Boot默认提供这个“白标”（whitelabel）错误页，这是自动配置的一部分。虽然这比Stacktrace页面要好一点，但和网上那些伟大的错误页艺术品却不可同日而语。为了让你的应用程序故障页变成大师级作品，你需要为应用程序创建一个自定义的错误页。\nSpring Boot自动配置的默认错误处理器会查找名为error的视图，如果找不到就用默认的白标错误视图，如图3-1所示。因此，最简单的方法就是创建一个自定义视图，让解析出的视图名为error。\n图 3-1　Spring Boot的默认白标错误页面\n这一点归根到底取决于错误视图解析时的视图解析器。\nView\nerror\nBeanNameViewResolver\n如果配置了Thymeleaf，则有名为error.html的Thymeleaf模板。\n如果配置了FreeMarker，则有名为error.ftl的FreeMarker模板。\n如果配置了Velocity，则有名为error.vm的Velocity模板。\n如果是用JSP视图，则有名为error.jsp的JSP模板。\n因为我们的阅读列表应用程序使用了Thymeleaf，所以我们要做的就是创建一个名为error.html的文件，把它和其他的应用程序模板一起放在模板文件夹里。代码清单3-7是一个简单有效的错误页，可以用来代替默认的白标错误页。\n代码清单3-7\n这个自定义的错误模板应该命名为error.html，放在模板目录里，这样Thymeleaf模板解析器才能找到它。在典型的Maven或Gradle项目里，这就意味着要把该文件放在src/main/resources/ templates中，运行时它就在Classpath的根目录里。\n基本上，这个简单的Thymeleaf模板就是显示一张图片和一些提示错误的文字。其中有两处特别的信息需要呈现：错误的请求路径和异常消息。但这还不是错误页上的全部细节。默认情况下，Spring Boot会为错误视图提供如下错误属性。\ntimestamp\nstatus\nerror\nexception\nmessage\nerrors\nBindingResult\ntrace\npath\npath\ntrace\n请注意，模板里还引用了一张名为MissingPage.png的图片。图片的实际内容并不重要，所以尽情挑选适合你的图片就好了，但请一定将它放在src/main/resources/static或src/main/resources/public里，这样应用程序运行时才能找到它。\n图3-2是发生错误时用户会看到的页面。虽然它算不上一件艺术品，但还是把应用程序错误页的艺术水准稍微提高了那么一点。\n图 3-2　遇到错误时展现的自定义错误页\n3.4　小结\nSpring Boot消除了Spring应用程序中经常要用到的很多样板式配置。让Spring Boot处理全部配置，你可以仰仗它来配置那些适合你的应用程序的组件。当自动配置无法满足需求时，Spring Boot允许你覆盖并微调它提供的配置。\n覆盖自动配置其实很简单，就是显式地编写那些没有Spring Boot时你要做的Spring配置。Spring Boot的自动配置被设计为优先使用应用程序提供的配置，然后才轮到自己的自动配置。\n即使自动配置合适，你仍然需要调整一些细节。Spring Boot会开启多个属性解析器，让你通过环境变量、属性文件、YAML文件等多种方式来设置属性，以此微调配置。这套基于属性的配置模型也能用于应用程序自己定义的组件，可以从外部配置源加载属性并注入到Bean里。\nSpring Boot还自动配置了一个简单的白标错误页，虽然它比异常跟踪信息友好一点，但在艺术性方面还有很大的提升空间。幸运的是，Spring Boot提供了好几种选项来自定义或完全替换这个白标错误页，以满足应用程序的特定风格。\n现在我们已经用Spring Boot写了一个完整的应用程序，我们会验证它能否满足预期。除了自己在浏览器里手工点点之外，我们还应该要写一些自动化、可重复运行的测试来检查这个应用程序，证明它能正确运作。这也是我们在第4章里要做的事。\n第 4 章　测试\n本章内容\n集成测试\n在服务器里测试应用程序\nSpring Boot的测试辅助工具\n有人说，如果你不知道要去哪，走就是了。但在软件开发领域，如果你没有目标，那结果往往是开发出一个满是bug的应用程序，没人用得了。\n在编写应用程序时，明确目标的最佳方法就是写测试，确定应用程序的行为是否符合预期。如果测试失败了，你就有活要干了。如果测试通过了，那你就成功了（至少在你觉得还有其他测试要写之前，是这样的）。\n究竟是在编写业务代码之前还是之后写测试，这并不重要。重要的是，写测试不仅仅是为了验证代码的准确性，还要确认它符合预期。测试也是一道保障，确认应用程序在改进的同时不会破坏已有的东西。\n在编写单元测试的时候，Spring通常不需要介入。Spring鼓励松耦合、接口驱动的设计，这些都能让你很轻松地编写单元测试。但是在写单元测试时并不需要用到Spring。\n但是，集成测试要用到Spring。如果生产应用程序使用Spring来配置并组装组件，那么测试就需要用它来配置并组装那些组件。\nSpringJUnit4ClassRunner\n在本章中，我们会看到Spring Boot的各种集成测试支持。让我们先来看看如何在Spring Boot应用程序上下文里做测试。\n4.1　集成测试自动配置\nSpring Framework的核心工作是将所有组件编织在一起，构成一个应用程序。整个过程就是读取配置说明（可以是XML、基于Java的配置、基于Groovy的配置或其他类型的配置），在应用程序上下文里初始化Bean，将Bean注入依赖它们的其他Bean中。\n对Spring应用程序进行集成测试时，让Spring遵照生产环境来组装测试目标Bean是非常重要的一点。当然，你也可以手动初始化组件，并将它们注入其他组件，但对那些大型应用程序来说，这是项费时费力的工作。而且，Spring提供了额外的辅助功能，比如组件扫描、自动织入和声明性切面（缓存、事务和安全，等等）。你要把这些活都干了，基本也就是把Spring再造了一次，最好还是让Spring替你把重活都做了吧，哪怕是在集成测试里。\nSpringJUnit4ClassRunner\n举例来说，看一下代码清单4-1，这是一个非常基本的Spring集成测试。\n代码清单4-1\nSpringJUnit4ClassRunner\nAddressServiceTests\n@RunWith\n@ContextConfiguration\n@RunWith\nSpringJUnit4ClassRunner.class\n1\n@ContextConfiguration\nAddressBookConfiguration\n1\n在Spring 4.2里，你可以选择基于规则的\nSpringClassRule\n和\nSpringMethodRule\n来代替\nSpringJUnit4ClassRunner\n。\nSpringJUnit4ClassRunner\nAddressService Bean\ntestService()\n@ContextConfiguration\nSpringApplication\nSpringBootServletInitializer\nSpringApplication\n@ContextConfiguration\n@ContextConfiguration\n@SpringApplicationConfiguration\n@SpringApplicationConfiguration\n@ContextConfiguration\n@SpringApplicationConfiguration\nSpringApplication\n@SpringApplicationConfiguration\n@ContextConfiguration\n@SpringApplicationConfiguration\n说到Web测试，这正是我们接下来要做的。\n",
  "factionName": "Spring Boot实战 ",
  "newest": 10,
  "comments": [],
  "source": [],
  "index": "2"
},{
  "_id": "bee41747-cd68-4f24-b03d-6ae57df56553",
  "headerImage": "https://wk-gulimall.oss-cn-beijing.aliyuncs.com/ProgramBook/910d0a7f-f937-4faf-967e-7b1c9b9811ef.jpg",
  "updateTime": {
    "$date": "2023-01-23T16:59:42.470Z"
  },
  "author": "杨保华, ",
  "des": "第1版前言\n在一台服务器上同时运行一百个虚拟机，肯定会被认为是痴人说梦。而在一台服务器上同时运行一千个Docker容器，这已经成为现实。在计算机技术高速发展的今天，昔日的天方夜谭正在一个个变成现实。\n多年的研发和运维（DevOps）经历中，笔者时常会碰到这样一个困境：用户的需求越来越多样，系统的规模越来越庞大，运行的软件越来越复杂，环境配置问题所造成的麻烦层出不穷……为了解决这些问题，开源社区推出过不少优秀的工具。这些方案虽然在某些程度上确能解决部分“燃眉之急”，但是始终没有一种方案能带来“一劳永逸”的效果。\n让作为企业最核心资源的工程师们花费大量的时间，去解决各种环境和配置引发的Bug，这真的正常吗？\n回顾计算机的发展历程，最初，程序设计人员需要直接操作各种枯燥的机器指令，编程效率之低可想而知。高级语言的诞生，将机器指令的具体实现成功抽象出来，从此揭开了计算机编程效率突飞猛进的大时代。那么，为什么不能把类似的理念（抽象与分层）也引入到现代的研发和运维领域呢？\nDocker无疑在这一方向上迈出了具有革新意义的一步。笔者在刚接触Docker时，就为它所能带来的敏捷工作流程而深深吸引，也为它能充分挖掘云计算资源的效能而兴奋不已。我们深信，Docker的出现，必将给DevOps技术，甚至整个信息技术产业的发展带来深远的影响。\n笔者曾尝试编写了介绍Docker技术的中文开源文档。短短一个月的时间，竟收到了来自全球各个地区超过20万次的阅读量和全五星的好评。这让我们看到国内技术界对于新兴开源技术的敏锐嗅觉和迫切需求，同时也倍感压力，生怕其中有不妥之处，影响了大家学习和推广Docker技术的热情。在开源文档撰写过程中，我们一直在不断思考，在生产实践中到底怎么用Docker才是合理的？在“华章图书”的帮助下，终于有了现在读者手中的这本书。\n与很多技术类书籍不同，本书中避免一上来就讲述冗长的故事，而是试图深入浅出、直奔主题，在最短时间内让读者理解和掌握最关键的技术点，并且配合实际操作案例和精炼的点评，给读者提供真正可以上手的实战指南。\n本书在结构上分为三大部分。第一部分是Docker技术的基础知识介绍，这部分将让读者对Docker技术能做什么有个全局的认识；第二部分将具体讲解各种典型场景的应用案例，供读者体会Docker在实际应用中的高效秘诀；第三部分将讨论一些偏技术环节的高级话题，试图让读者理解Docker在设计上的工程美学。最后的附录归纳了应用Docker的常见问题和一些常用的参考资料。读者可根据自身需求选择阅读重点。全书主要由杨保华和戴王剑主笔，曹亚仑写作了编程开发和实践之道章节。\n本书在写作过程中参考了官方网站上的部分文档，并得到了DockerPool技术社区网友们的积极反馈和支持，在此一并感谢！\n成稿之际，Docker已经发布了增强安全特性的1.3.2版本。衷心祝愿Docker及相关技术能够快速成长和成熟，让众多IT从业人员的工作和生活都更加健康、更加美好！\n作者于2014年11月\n",
  "factionName": "Docker技术入门与实战",
  "newest": 10,
  "comments": [],
  "source": [],
  "index": "5"
},{
  "_id": "52508a02-3a9c-431a-99f3-10e2d4807530",
  "headerImage": "https://wk-gulimall.oss-cn-beijing.aliyuncs.com/ProgramBook/fea9e0f9-01dc-4780-986a-022b4366f51c.jpg",
  "updateTime": {
    "$date": "2023-01-23T16:59:43.278Z"
  },
  "author": "Gajdos",
  "des": "Docker是基础设施的新成员。很少有新兴技术能像它这样，在DevOps和基础设施领域中快速风靡起来。在不到两年的时间内，Google、亚马逊、微软、IBM以及几乎所有云供应商都宣布支持运行Docker容器。大量与Docker相关的创业公司在2014年和2015年年初都获得了风险资本的投资。Docker开源技术背后的同名公司——Docker公司，在2015年第一季度的D轮融资中估值为10亿美元左右。\n大大小小的公司都在转换其应用，使之运行于容器内，以此实现面向服务架构（SOA）和微服务。不论是参加从旧金山到柏林的任何DevOps聚会，还是阅读最热门的公司工程博客，都可以看出全世界的运维领导者们如今都在云上运行Docker。\n毫无疑问，容器已经成为应用程序打包和基础设施自动化的重要组成部分。但有一个棘手的问题，促使本书作者和同僚们创作了另一本Docker图书。\n本书面向的读者\n具有中高级DevOps和运维背景的读者将从本书获益最多。因而，强烈建议读者应具备在生产环境中运行服务器以及创建和管理容器这两方面的基本经验。\n很多图书和博客文章已经涵盖了与Docker安装及运行相关的话题，但能把在生产环境中运行Docker时产生的大量甚至是令人挠头的关注点结合在一起的材料则少之又少。不用担心，如果你很喜欢《盗梦空间》（Inception）这部电影，在云服务器的虚拟机中运行容器会让你感觉很自然。\n本书将带读者深入理解生产环境中架构的组成部分、关注点，以及如何运行基于Docker的基础设施。\n谁真的在生产环境中使用Docker\n换个更深刻的说法，对于在真实生产环境中使用Docker遇到的问题，如何找到解决之道？本书综合了访谈、真实公司端到端的生产环境实例，以及来自DevOps杰出专家的参考文献，以此来解答这些问题。虽然本书包含了一些有用的示例，但它并不是一本复制粘贴的“教程式”参考书。相反，本书侧重于生产环境中对前沿技术进行评估、风险抵御及运维所需的实践理论和经验。\n作为作者，我们希望这本书所包含的内容能够为那些正在评估如何及何时将Docker相关技术引入其DevOps栈的团队提供一个可靠的决策指南，这远比代码片段要来得长久。\n生产环境中运行的Docker为企业提供了多个新的运行和管理服务器端软件的方式。很多现成的用例讲解了如何使用Docker，但很少有公司公开分享过他们的全栈生产环境经验。本书汇集了作者在生产环境中运行Docker的多个实例和一组选定的友好公司分享的使用经验。\n为什么使用Docker\ndotCloud\nHeroku\nIron.io\n既然这项技术并不新鲜，为什么Docker能获得如此巨大的成功呢？主要是因为它的易用性。Docker创造了一种统一的方式，通过简便的命令行及HTTP API工具来打包、运行和维护容器。这种简化降低了将应用程序及其运行时环境打包成一个自包含镜像的入门门槛，使之变得可行且有趣，而不需要类似Chef、Puppet及Capistrano之类的配置管理和发布系统。\nDocker提供了一种统一手段，将应用程序及其运行时环境打包到一个简单的Dockerfile里，这从根本上改变了开发人员与DevOps团队之间的交互界面。从而极大简化了开发团队与DevOps之间的沟通需求与责任边界。\n在Docker出现之前，各个公司的开发与运维团队之间经常会爆发史诗般的战争。开发团队想要快速前进，整合最新版的软件及依赖，以及持续部署。运维团队则以保证稳定为己任，他们负责把关可以运行于生产环境中的内容。如果运维团队对新的依赖或需求感到不适，他们通常会站在保守的立场上，要求开发人员使用旧版软件以确保糟糕的代码不会搞垮整台服务器。\nDocker一下子改变了DevOps的决策思维，从“基本上说不”变成了“好的，只要运行在Docker中就可以”，因为糟糕的代码只会让容器崩溃，而不会影响到同一服务器上的其他服务。在这种泛型中，DevOps有效地负责为开发人员提供PaaS，而开发人员负责保证其代码能正常运行。如今，很多团队将开发人员加入到PagerDuty中，以监控他们在生产环境中的代码，让DevOps和运维人员专注于平台的稳定运行及安全。\n开发环境与生产环境\n对大多数团队而言，采用Docker是受开发人员更快的迭代和发布周期需求推动的。这对于开发环境是非常有益的，但对于生产环境，在单台宿主机上运行多个Docker容器可能会导致安全漏洞，这一点我们将在第6章“安全”中讲述。事实上，几乎所有关于在生产环境中运行Docker的话题都是围绕着将开发环境与生产环境区分开的两个关注点进行的：一是编排，二是安全。\n有些团队试图让开发环境和生产环境尽可能保持一致。这种方法看起来很好，但是限于开发环境这样做所需定制工具的数量又或者说模拟云服务（如AWS）的复杂度，这种方法并不实际。\n为了简化这本书的范畴，我们将介绍一些部署代码的用例，但判定最佳开发环境设置的实践机会将留给读者。作为基本原则之一，尽量保持生产环境和开发环境的相似性，并使用一个持续集成/持续交付（CI/CD）系统以获取最佳结果。\n我们所说的“生产环境”\n对于不同的团队，生产环境意味着不同的东西。在本书中，我们所说的生产环境是指真实客户用于运行代码的环境。这是相对于开发环境、预演环境及测试环境而言的，后者的停机时间不会被客户感知到。\n在生产环境中，Docker有时是用于接收公共网络流量的容器，有时则是用于处理来自队列负荷的异步的后台作业。不管哪种用途，在生产环境中运行Docker与在其他环境中运行相比，最主要的差异都是需要在其安全性与稳定性上投入较多的注意力。\n编写本书的动力之一是，与Docker相关的文档和博客文章中缺乏对实际生产环境与其他环境的明确区分。我们认为，80%的Docker博客文章中的建议在尝试在生产环境中运行6个月之后会被放弃（或至少修改）。为什么？因为大多数博客文章中举的都是理想化的例子，使用了最新、最好用的工具，一旦某个极端的情况变成了致命缺陷，这些工具将被遗弃（或延期），被更简单的方法所取代。这是Docker技术生态系统现状的一个反映，而非技术博客的缺陷。\n总的来说，生产环境很难管理。Docker简化了从开发到生产的工作流程，但同时增加了安全和编排的复杂度（更多关于编排的内容参见第4章）。\n为了节省时间，下面给出本书的重点综述。\n所有在生产环境中运行Docker的团队，都会在传统的安全最佳实践上做出一项或多项妥协。如果无法完全信任容器内运行的代码，那么就只得选用容器与虚拟机一对一的拓扑方式。对于很多团队而言，在生产环境中运行Docker的优势远远大于其带来的安全与编排问题。如果遇到工具方面的问题，请等待一到两个月，以便Docker社区对其进行修复，不要浪费时间去修补其他人的工具。保持Docker设置最小化。让一切自动化。最后，对成熟的编排工具（如Mesos、Kubernates等）的需求远比想象的要少得多。\n功能内置与组合工具\nDocker社区一个常见的口头禅是“电池内置但可移除”，指的是将很多功能捆绑在一起的单体二进制文件，这有别于传统Unix哲学下相对较小、功能单一、管道化的二进制文件。\nGo编程语言\n[1]\n换句话说，要让Docker运行于生产环境中，用户的一半工作将是决定哪些工具对自己的技术栈最有意义。与DevOps所有事情一样，先从最简单的解决方案入手，然后在必要时增加其复杂性。\nCompose\nMachine\nSwarm\n探索Docker生态系统时的另一项关键建议是：评估每个开源工具的资金来源及其商业目标。目前，Docker公司和CoreOS经常发布工具，以争夺关注度和市场份额。一个新工具发布后，最好等上几个月，看看社区的反应，不要因为它看起来很酷就切换到最新、最好用的工具上。\n哪些东西不要Docker化\n12 factor\nClusterHQ\n[2]\n另外，对网络吞吐量有高要求的应用进行最佳优化时不要使用Docker，因为Docker使用iptables来完成宿主机IP到容器IP的NAT转换。通过禁用Docker的NAT来提升网络性能是可行的，但这是一个高级的使用场景，很少有团队会在生产环境中这么做。\n技术审稿人\n衷心感谢以下技术审稿人提供的早期反馈及细致的评论：Mika Turunen、Xavier Bruhiere和Felix Rabe。\n[1]\n[2]\n",
  "factionName": "Docker生产环境实践指南",
  "newest": 10,
  "comments": [],
  "source": [],
  "index": "5"
},{
  "_id": "7d1b1395-84a4-46b9-baaf-c3a56c8c8d04",
  "headerImage": "https://wk-gulimall.oss-cn-beijing.aliyuncs.com/ProgramBook/bdfac9c7-b20e-47e6-9af9-22cf6142c1f1.jpg",
  "updateTime": {
    "$date": "2023-01-23T16:59:44.064Z"
  },
  "author": "华为Docker实践小组",
  "des": "在计算机技术日新月异的今天，Docker也算是其中异常璀璨的一员了。它的生态圈涉及内核、操作系统、虚拟化、云计算、DevOps等热门领域，受众群体也在不断扩大。\nDocker在国内的发展如火如荼，短短一两年时间里就陆续出现了一批关于Docker的创业公司。华为公司作为国内开源领域的领导者，对Docker也有很大的投入，我们认为有必要把自己的知识积累和实践经验总结出来分享给广大开发者。除了吸引更多的人投入到Docker的生态建设以外，我们也希望通过本书帮助更多的读者更好、更快地掌握Docker关键技术。\n关于本书\n目前市场已经有一些不错的Docker入门图书，但多侧重于入门和具体的应用，本书会介绍一些Docker关键技术原理和高级使用技巧，适合有一定基础的读者。另外，本书会对Docker涉及的各个模块、关系和原理进行系统梳理，帮助读者对Docker加深认识，更好地应用Docker部署生产环境，最大程度安全有效地发挥Docker的价值。\n本书不仅适合一般的Docker用户，也适合Docker生态圈中的开发者，希望它可以成为一本Docker进阶的图书，帮助读者快速提升。\n本书是由华为整个Docker团队合作完成的，笔者包括（排名不分先后）：邓广兴、胡科平、胡欣蔚、黄强、雷继棠、李泽帆、凌发科、刘华、孙远、谢可杨、杨书奎、张伟、张文涛、邹钰。\n本书的内容\n本书的定位是有一定Docker基础的读者，所以在基本的概念和使用上，我们不会花过多的篇幅讲解，而是给出相应有价值的链接，作为读者的延伸阅读。\n在内容上，除了对Docker进行系统的梳理外，同时还会对Docker背后的核心技术（即容器技术）及其历史进行介绍，进一步帮助读者更好地理解Docker。\n章节划分则以功能模块为粒度，对每一个重要的模块进行了深入分析和讲解，同时也为热门领域单独开辟了章节。在每一章的最后都会讲解一些高级用法、使用技巧或实际应用中遇到的问题。虽然各章节的内容相对独立，但也会有一些穿插的介绍和补充，以帮助读者融会贯通，系统深入地理解Docker的每一个细节。\n另外，本书的笔者都是一线的开发者和Docker社区活跃的贡献者，因此书中还专门准备了一个章节来介绍参与Docker开发的流程和经验。同时，伴随Docker的发展，Docker生态圈也在不断扩大并吸引了越来越多的人的关注。Docker集群管理和生态圈的介绍也将作为本书重点章节详细讲解。此外，Docker测试也是比较有特色的内容，分享了笔者在测试方面的经验。最后，附录中所包含的常用的Docker相关信息，可供读者需要时查询。\n本书的内容和代码都是基于Docker 1.8版本的。在代码示例中，使用“#”开头的命令表示以root用户执行，以“$”开头的命令表示以普通用户执行。\n勘误和支持\n由于笔者水平有限，编写的时间也很仓促，书中难免会出现一些错误或者不准确的地方，恳请读者批评指正。读者可以把书中发现的问题或建议发送到邮箱docker@huawei.com，我们会尽快回复大家的疑问，并把收集的信息整理修正。\n致谢\n本书是由整个Docker团队协作完成的，由于繁忙的工作书稿撰写几度中止。感谢我们的项目经理裴斐月女士，正是她的整体协调和督促，以及与出版社的大量沟通，才促成了本书的出版。感谢李泽帆，他不仅参与了本书的写作，而且承担了全书的审读工作，给出了大量有价值的建议。还要感谢Stephen Li、陈佳波、杨开封、胡欣蔚和张殿芳，以及其他华为公司主管对我们写书的大力支持，感谢机械工业出版社的编辑耐心专业的指导和审核。最后，感谢我们每一位家人的支持陪伴，我们的工作因为有了家人的支持和期待才变得更有意义。\n华为Docker实践小组\n2015年11月\n",
  "factionName": "Docker进阶与实战",
  "newest": 10,
  "comments": [],
  "source": [],
  "index": "5"
},{
  "_id": "479b0e56-d7e8-4b72-861d-5c2109d4dd62",
  "headerImage": "https://wk-gulimall.oss-cn-beijing.aliyuncs.com/ProgramBook/75424860-dfff-4449-8193-eee9aa0768a1.jpg",
  "updateTime": {
    "$date": "2023-01-23T16:59:49.923Z"
  },
  "author": "Castro",
  "des": "无论你是刚开始涉足网站制作，还是曾经做过网站、而今又想让自己的技能与时俱进，都会对这个领域振奋人心的进展感同身受。在过去的几年里，为网页编写代码和添加样式的方式、浏览网页所用的浏览器以及使用浏览器的设备都发生了明显的变化。以前，我们只能通过台式机或笔记本浏览万维网，而如今我们可以通过很多设备访问万维网：手机、平板电脑，当然也包括笔记本、台式机，以及很多别的设备。这是意料之中的事，因为万维网始终秉持消除边界的宗旨——无论是在城市还是在乡村，通过任何能访问万维网的设备，任何人都可以自由地分享和获取信息。总之，万维网的宗旨是普适性。万维网的覆盖范围不断扩大，过去，通信技术还未曾普及农村，而现在却已经实现了。更伟大的是，万维网是属于每一个人的，任何人都可以自由地创建和发布网站。本书将指导读者创建和发布网站，是没有任何HTML和CSS知识的建站初学者的理想教程。书中内容结构清晰，浅显易懂，将一步一步地教会你如何创建网页。总之，本书是开发人员手头案边的必备指南。若想了解某个主题的更多信息，可以通过查找目录直接跳到相关页面。",
  "factionName": "HTML5与CSS3基础教程",
  "newest": 10,
  "comments": [],
  "source": [],
  "index": "4"
},{
  "_id": "870972a4-8a9f-449f-a090-67ec0f3062fd",
  "headerImage": "https://wk-gulimall.oss-cn-beijing.aliyuncs.com/ProgramBook/efa32224-f676-4790-bd88-aba5cb0debca.jpg",
  "updateTime": {
    "$date": "2023-01-23T16:59:51.018Z"
  },
  "author": "wizard",
  "des": "欢迎阅读我编写的Java 8介绍。本教程将带领你一步一步地认识这门语言的新特性。通过简单明了的代码示例，你将会学习到如何使用默认接口方法，Lambda表达式，方法引用和重复注解。看完这篇教程后，你还将对最新推出的API有一定的了解，例如：流控制，函数式接口，map扩展和新的时间日期API等等。",
  "factionName": "Java8 简明教程",
  "newest": 10,
  "comments": [],
  "source": [],
  "index": "2"
},{
  "_id": "25732e81-2478-4f5e-ac7f-b126bd122e8f",
  "headerImage": "https://wk-gulimall.oss-cn-beijing.aliyuncs.com/ProgramBook/83060711-18ef-42ed-aed3-2fc282a94247.jpg",
  "updateTime": {
    "$date": "2023-01-23T17:00:30.119Z"
  },
  "author": "Mycrof",
  "des": "简单地说，Java 8中的新增功能是自Java 1.0发布18年以来，Java发生的最大变化。没有去掉任何东西，因此你现有的Java代码都能工作，但新功能提供了强大的新语汇和新设计模式，能帮助你编写更清楚、更简洁的代码。就像遇到所有新功能时那样，你一开始可能会想：“为什么又要去改我的语言呢？”但稍加练习之后，你就会发觉自己只用预期的一半时间，就用新功能写出了更短、更清晰的代码，这时你会意识到自己永远无法返回到“旧Java”了。 本书会帮助你跨过“原理听起来不错，但还是有点儿新，不太适应”的门槛，从而熟练地进行编程。",
  "factionName": "Java 8实战",
  "newest": 10,
  "comments": [],
  "source": [],
  "index": "2"
},{
  "_id": "10bd1eb9-b942-4df0-a78a-c27e28ecf3b6",
  "headerImage": "https://wk-gulimall.oss-cn-beijing.aliyuncs.com/ProgramBook/bef9b6dd-f34b-41ad-bdb2-96aa1fe8fb8b.jpg",
  "updateTime": {
    "$date": "2023-01-23T17:00:35.670Z"
  },
  "author": "Eckel,",
  "des": "本书是针对初学者编写的计算机科学和编程入门教程。从最基本的概念入手，每个术语都在首次使用时给出详尽的定义；循序渐进地介绍新概念；将内容广泛的主题（如递归和面向对象编程）分成多个部分，并分多章介绍。 本书简明扼要，每章都只有十几页的篇幅，涵盖了一周的大学课程内容。本书无意全面介绍 Java，只是想让读者了解基本的编程结构和技巧。我们从小问题和基本算法着手，逐步过渡到面向对象设计，用计算机教学术语讲，本书采取的是“迟来的对象”法。",
  "factionName": "Java 编程思想 第4版",
  "newest": 10,
  "comments": [],
  "source": [],
  "index": "2"
},{
  "_id": "0875907b-4486-4d0e-94e2-c458eb34c678",
  "headerImage": "https://wk-gulimall.oss-cn-beijing.aliyuncs.com/ProgramBook/e82bf1be-91f4-4c74-afe7-69ba6f6a2146.jpg",
  "updateTime": {
    "$date": "2023-01-23T17:00:38.059Z"
  },
  "author": "Downey",
  "des": "版权信息\n书名：Java编程思维\n作者：[美] Allen B. Downey　Chris Mayfield\n译者：袁国忠\nISBN：978-7-115-44015-0\n本书由北京图灵文化发展有限公司发行数字版。版权所有，侵权必究。\n您购买的图灵电子书仅供您个人使用，未经授权，不得以任何方式复制和传播本书内容。\n我们愿意相信读者具有这样的良知和觉悟，与我们共同保护知识产权。\n如果购买者有侵权行为，我们可能对该用户实施包括但不限于关闭该帐号等维权措施，并可能追究法律责任。\n091507240605ToBeReplacedWithUserId\n版权声明\nO'Reilly Media, Inc. 介绍\n业界评论\n前言\n编写理念\n面向对象编程\n附录\n使用代码示例\n排版约定\nSafari® Books Online\n联系我们\n致谢\n电子书\n第 1 章　编程之道\n1.1　何为编程\n1.2　何为计算机科学\n1.3　编程语言\n1.4　Hello World程序\n1.5　显示字符串\n1.6　转义序列\n1.7　设置代码格式\n1.8　调试代码\n1.9　术语表\n1.10　练习\n第 2 章　变量和运算符\n2.1　声明变量\n2.2　赋值\n2.3　状态图\n2.4　显示变量\n2.5　算术运算符\n2.6　浮点数\n2.7　舍入误差\n2.8　字符串运算符\n2.9　组合\n2.10　错误类型\n2.11　术语表\n2.12　练习\n第 3 章　输入和输出\n3.1　System类\n3.2　Scanner类\n3.3　程序结构\n3.4　英寸到厘米的转换\n3.5　字面量和常量\n3.6　设置输出的格式\n3.7　厘米到英寸的转换\n3.8　求模运算符\n3.9　整合\n3.10　Scanner类的bug\n3.11　术语表\n3.12　练习\n第 4 章　void 方法\n4.1　Math类的方法\n4.2　再谈组合\n4.3　添加方法\n4.4　执行流程\n4.5　形参和实参\n4.6　多个形参\n4.7　栈图\n4.8　阅读文档\n4.9　编写文档\n4.10　术语表\n4.11　练习\n第 5 章　条件和逻辑\n5.1　关系运算符\n5.2　逻辑运算符\n5.3　条件语句\n5.4　串接和嵌套\n5.5　标志变量\n5.6　return语句\n5.7　验证输入\n5.8　递归方法\n5.9　递归栈图\n5.10　二进制数\n5.11　术语表\n5.12　练习\n第 6 章　值方法\n6.1　返回值\n6.2　编写方法\n6.3　方法组合\n6.4　重载\n6.5　boolean方法\n6.6　Javadoc标签\n6.7　再谈递归\n6.8　姑且相信\n6.9　再举一个例子\n6.10　术语表\n6.11　练习\n第 7 章　循环\n7.1　while语句\n7.2　生成表格\n7.3　封装和泛化\n7.4　再谈泛化\n7.5　for语句\n7.6　do-while循环\n7.7　break和continue\n7.8　术语表\n7.9　练习\n第 8 章　数组\n8.1　创建数组\n8.2　访问元素\n8.3　显示数组\n8.4　复制数组\n8.5　数组的长度\n8.6　数组遍历\n8.7　随机数\n8.8　遍历和计数\n8.9　生成直方图\n8.10　改进的for循环\n8.11　术语表\n8.12　练习\n第 9 章　字符串\n9.1　字符\n9.2　字符串是不可修改的\n9.3　字符串遍历\n9.4　子串\n9.5　方法indexOf\n9.6　字符串比较\n9.7　设置字符串的格式\n9.8　包装类\n9.9　命令行实参\n9.10　术语表\n9.11　练习\n第 10 章　对象\n10.1　Point对象\n10.2　属性\n10.3　将对象用作参数\n10.4　将对象作为返回类型\n10.5　可修改的对象\n10.6　指定别名\n10.7　关键字null\n10.8　垃圾收集\n10.9　类图\n10.10　Java类库的源代码\n10.11　术语表\n10.12　练习\n第 11 章　类\n11.1　Time类\n11.2　构造函数\n11.3　再谈构造函数\n11.4　获取方法和设置方法\n11.5　显示对象\n11.6　方法toString\n11.7　方法equals\n11.8　时间相加\n11.9　纯方法和非纯方法\n11.10　术语表\n11.11　练习\n第 12 章　对象数组\n12.1　Card对象\n12.2　方法toString\n12.3　类变量\n12.4　方法compareTo\n12.5　Card对象是不可修改的\n12.6　Card数组\n12.7　顺序查找\n12.8　二分法查找\n12.9　跟踪代码\n12.10　递归版本\n12.11　术语表\n12.12　练习\n第 13 章　数组对象\n13.1　Deck类\n13.2　洗牌\n13.3　选择排序\n13.4　合并排序\n13.5　方法subdeck\n13.6　方法merge\n13.7　添加递归\n13.8　术语表\n13.9　练习\n第 14 章　包含其他对象的对象\n14.1　Deck和手里的牌\n14.2　CardCollection\n14.3　继承\n14.4　发牌\n14.5　Player类\n14.6　Eights类\n14.7　类之间的关系\n14.8　术语表\n14.9　练习\n附录 A　开发工具\nA.1　安装DrJava\nA.2　DrJava Interactions窗格\nA.3　命令行界面\nA.4　命令行测试\nA.5　运行Checkstyle\nA.6　使用调试器进行跟踪\nA.7　用JUnit进行测试\nA.8　术语表\n附录 B　Java 2D 图形\nB.1　创建图形\nB.2　Graphics类的方法\nB.3　绘图示例\nB.4　术语表\nB.5　练习\n附录 C　调试\nC.1　编译时错误\nC.1.1　编译器显示大量的错误消息\nC.1.2　编译器显示怪异的错误消息，怎么都消除不掉\nC.1.3　怎么做都无法让程序通过编译\nC.1.4　按编译器说的做了，但还是不管用\nC.2　运行时错误\nC.2.1　程序挂起\nC.2.2　程序运行时出现异常\nC.2.3　添加了很多打印语句，输出都泛滥成灾了\nC.3　逻辑错误\nC.3.1　程序不管用\nC.3.2　冗长表达式的结果出乎意料\nC.3.3　方法的返回值出乎意料\nC.3.4　打印语句什么都不显示\nC.3.5　陷入了绝境，无法自拔\nC.3.6　必须得有人帮我\nC.3.7　终于找到bug了！\n作者简介\n封面简介\n版权声明\n© 2016 Allen B. Downey and Chris Mayfield.\nSimplified Chinese Edition, jointly published by O'Reilly Media, Inc. and Posts & Telecom Press, 2016. Authorized translation of the English edition, 2016 O'Reilly Media, Inc., the owner of all rights to publish and sell the same.\nAll rights reserved including the rights of reproduction in whole or in part in any form.\n英文原版由 O'Reilly Media, Inc. 出版，2016。\n简体中文版由人民邮电出版社出版，2017。英文原版的翻译得到 O'Reilly Media, Inc. 的授权。此简体中文版的出版和销售得到出版权和销售权的所有者——O'Reilly Media, Inc. 的许可。\n版权所有，未得书面许可，本书的任何部分和全部不得以任何形式重制。\nO'Reilly Media, Inc. 介绍\nO'Reilly Media 通过图书、杂志、在线服务、调查研究和会议等方式传播创新知识。自 1978 年开始，O'Reilly 一直都是前沿发展的见证者和推动者。超级极客们正在开创着未来，而我们关注真正重要的技术趋势——通过放大那些“细微的信号”来刺激社会对新科技的应用。作为技术社区中活跃的参与者，O'Reilly 的发展充满了对创新的倡导、创造和发扬光大。\nO'Reilly 为软件开发人员带来革命性的“动物书”；创建第一个商业网站（GNN）；组织了影响深远的开放源代码峰会，以至于开源软件运动以此命名；创立了 Make 杂志，从而成为 DIY 革命的主要先锋；公司一如既往地通过多种形式缔结信息与人的纽带。O'Reilly 的会议和峰会集聚了众多超级极客和高瞻远瞩的商业领袖，共同描绘出开创新产业的革命性思想。作为技术人士获取信息的选择，O'Reilly 现在还将先锋专家的知识传递给普通的计算机用户。无论是通过书籍出版、在线服务或者面授课程，每一项 O'Reilly 的产品都反映了公司不可动摇的理念——信息是激发创新的力量。\n业界评论\n“O'Reilly Radar 博客有口皆碑。”\nWired\n“O'Reilly 凭借一系列（真希望当初我也想到了）非凡想法建立了数百万美元的业务。”\nBusiness 2.0\n“O'Reilly Conference 是聚集关键思想领袖的绝对典范。”\nCRN\n“一本 O'Reilly 的书就代表一个有用、有前途、需要学习的主题。”\nIrish Times\n“Tim 是位特立独行的商人，他不光放眼于最长远、最广阔的视野，并且切实地按照 Yogi Berra 的建议去做了：‘如果你在路上遇到岔路口，走小路（岔路）。’回顾过去，Tim 似乎每一次都选择了小路，而且有几次都是一闪即逝的机会，尽管大路也不错。”\nLinux Journal\n前言\n本书是针对初学者编写的计算机科学和编程入门教程。从最基本的概念入手，每个术语都在首次使用时给出详尽的定义；循序渐进地介绍新概念；将内容广泛的主题（如递归和面向对象编程）分成多个部分，并分多章介绍。\n本书简明扼要，每章都只有十几页的篇幅，涵盖了一周的大学课程内容。本书无意全面介绍 Java，只是想让读者了解基本的编程结构和技巧。我们从小问题和基本算法着手，逐步过渡到面向对象设计，用计算机教学术语讲，本书采取的是“迟来的对象”法。\n编写理念\n本书是基于如下的指导原则编写的。\n每次一个概念\n兼顾 Java 和概念\n简明扼要\n突出术语\n程序开发策略\n多条学习曲线\n面向对象编程\n有些 Java 书一上来就介绍类和对象，有些则先介绍过程性编程，再逐步过渡到面向对象编程。\nJava 的很多面向对象功能都旨在解决以前的语言存在的问题，因此，其实现受到了这些历史原因的影响。对于这些功能，如果你不熟悉它们所能解决的问题，就很难理解。\n我们每次介绍一个概念，并尽可能将它讲清楚，让读者能够立即将学到的知识付诸实践。在这个前提之下，我们会尽早地介绍面向对象编程，因此，你不可能翻开本书就接触到这个主题。\n然而，如果不使用面向对象功能，根本就无法编写 Java 程序，哪怕是简单的 Hello World 程序。对于有些功能，我们会在首次提及时简要地介绍一下，再在后面作更深入的讨论。\nhttp://thinkjava.org\n附录\n本书适合按顺序逐章阅读，因为每一章都以前一章的内容为基础。本书还有三个附录，你可在任何时间阅读。\n附录 A（开发工具）\n编译、运行和调试 Java 代码的步骤随开发环境和操作系统而异，我们没有将这些细节放在正文中，因为这会分散读者的注意力。相反，我们专辟了附录 A，简要地介绍 DrJava——一个非常适合初学者使用的集成开发环境（interactive development environment，IDE），以及用于检查代码质量的 Checkstyle 和用于测试的 JUnit 等工具。\n附录 B（Java 2D 图形）\nJava 提供了处理图形和动画的库，这些主题可能对学生很有吸引力。这些库涉及面向对象功能，读者可能阅读完前 11 章才能完全理解，但可以很早地使用它们。\n附录 C（调试）\n有关调试的建议遍布全书，我们将这些调试建议收集到了附录 C 中。建议读者在阅读本书的过程中反复温习该附录。\n使用代码示例\nhttps://github.com/AllenDowney/ThinkJavaCode\nGitHub 是一种托管服务，为 Git 仓库提供存储空间，还提供了方便的 Web 界面。它提供了多种处理代码的方式。\n单击 Fork 键可以在 GitHub 上创建仓库的副本。如果你没有 GitHub 账户，就需要创建一个。建立分支后，你便在 GitHub 上有自己的仓库了，可用它来跟踪你编写的代码。然后，还可以“克隆”这个仓库，即将文件的副本下载到计算机。\n你也可以在不建立分支的情况下克隆仓库。这样就不需要 GitHub 账户了，但也无法将所做的修改保存到 GitHub 中。\nhttp://www.tinyurl.com/ThinkJavaCodeZip\n克隆仓库或解压 ZIP 文件后，你将看到一个名为 ThinkJavaCode 的目录，其中包含与本书每章对应的子目录。\n本书中的所有示例都是用 Java SE Development Kit 8 开发和测试的。如果你使用的是更新的版本，这些示例也能正确地运行；但如果你使用的是更早的版本，有些示例可能无法正确地运行。\n排版约定\n本书使用了下列排版约定。\n楷体\n表示术语或重点强调的内容。\nconstant width\n表示程序片段，以及正文中出现的变量、函数名、数据库、数据类型、环境变量、语句和关键字等。\nconstant width bold\n表示应该由用户输入的命令或其他文本。\n®\nhttp://www.safaribooksonline.com\n对于组织团体、政府机构和个人，Safari Books Online 提供各种产品组合和灵活的定价策略。用户可通过一个功能完备的数据库检索系统访问 O'Reilly Media、Prentice Hall Professional、Addison-Wesley Professional、Microsoft Press、Sams、Que、Peachpit Press、Focal Press、Cisco Press、John Wiley & Sons、Syngress、Morgan Kaufmann、IBM Redbooks、Packt、Adobe Press、FT Press、Apress、Manning、New Riders、McGraw-Hill、Jones & Bartlett、Course Technology 以及其他几十家出版社的上千种图书、培训视频和正式出版之前的书稿。要了解 Safari Books Online 的更多信息，我们网上见。\n联系我们\n请把对本书的评价和问题发给出版社。\n美国：\n　　O'Reilly Media, Inc.\n　　1005 Gravenstein Highway North\n　　Sebastopol, CA 95472\n中国：\n　　北京市西城区西直门南大街 2 号成铭大厦 C 座 807 室（100035）\n　　奥莱利技术咨询（北京）有限公司\nO'Reilly 的每一本书都有专属网页，你可以在那儿找到本书的相关信息，包括勘误表、示例代码以及其他信息。本书的网站地址是：\nhttp://shop.oreilly.com/product/0636920041610.do\n对于本书的评论和技术性问题，请发送电子邮件到：\n　　bookquestions@oreilly.com\n要了解更多 O'Reilly 图书、培训课程、会议和新闻的信息，请访问以下网站：\nhttp://www.oreilly.com\nhttp://facebook.com/oreilly\nhttp://twitter.com/oreillymedia\nhttp://www.youtube.com/oreillymedia\n致谢\n很多人提出了勘误和建议，这里要特别感谢他们的宝贵反馈！\nEllen Hildreth 在威尔斯利女子学院讲授数据结构时，曾将本书作为补充读物，她指出了一大堆错误，还提出了一些很不错的建议。\nTania Passfield 指出有些术语表包含了正文中没有出现的术语。\nx\n2\nMatt Crawford 发来了一个包含大量勘误的文件。\nChi-Yu Li 指出了一个代码示例的输入错误和编程错误。\nDoan Thanh Nam 更正了一个示例。\nMuhammad Saied 在将本书翻译成阿拉伯语的过程中发现了多个错误。\nMarius Margowski 发现有个代码示例存在不一致的问题。\nx\n2\nMicah Lindstrom 指出了六七个输入错误，并给出了更正建议。\nhttp://fpl.cs.depaul.edu/jriely/thinkapjava/\nhttp://www.rigwit.co.uk/think/sharp/\nhttps://www.youtube.com/user/digipipeline\n这里要特别感谢技术审阅人 Blythe Samuels、David Wisneski 和 Stephen Rose。他们找出了错误，提出了很多宝贵建议，让本书的质量得到了极大的提高。\n另外，感谢以下人员发现并指出了输入错误：Stijn Debrouwere、Guy Driesen、Andai Velican、Chris Kuszmaul、Daniel Kurikesu、Josh Donath、Rens Findhammer、Elisa Abedrapo、Yousef BaAfif、Bruce Hill、Matt Underwood、Isaac Sultan、Dan Rice、Robert Beard 和 Daniel Pierce。\n如果你有其他建议或看法，请发送到 feedback@greenteapress.com。\n电子书\n扫描如下二维码，即可购买本书电子书。\n第 1 章　编程之道\n本书旨在教你像计算机科学家那样思考。这种思维方式兼具数学、工程和自然科学的优点：计算机科学家像数学家那样使用规范的语言来描绘概念，具体地说就是计算；像工程师那样设计，将各个部分组装成系统并权衡不同的解决方案；像科学家那样观察复杂系统的行为，进而作出假设并进行验证。\n解决问题\n一方面，你将学习编程，这本身就是一项很有用的技能；另一方面，你将把编程作为达到目的的手段。随着不断往下阅读，目的将变得更加清晰。\n1.1　何为编程\n程序\n输入\n从键盘、文件、传感器或其他设备获取数据。\n输出\n在屏幕上显示数据，或者将数据发送给文件或其他设备。\n数学运算\n执行基本的数学运算，如加法和除法。\n决策\n检查特定的条件，并根据检查结果执行相应的代码。\n重复\n反复执行某种操作，但通常每次执行时都略有不同。\n编程\n1.2　何为计算机科学\n对编程而言，最有趣的一个方面是决定如何解决特定的问题，尤其是问题存在多种解决方案时。例如，对数字列表进行排序的方法很多，其中每种方法都有其优点。要确定哪种方法是特定情况下的最佳方法，你必须具备规范地描述和分析解决方案的技能。\n计算机科学\n算法\n调试\n虽然调试可能令人沮丧，但它是计算机编程中有趣且挑战智商的部分。从某种程度上来说，调试犹如侦破工作：必须根据掌握的线索猜想出引发结果的过程和事件。在有些情况下，在考虑如何修复程序以及改善其性能的过程中，还能发现新的算法。\n1.3　编程语言\n高级语言\n低级语言\n用高级语言编程容易得多：编写程序所需要的时间更短，程序更简洁、更容易理解，同时更容易确保程序正确无误。\n可移植的\n解释器\n图 1-1：解释型语言是如何执行的\n编译器\n源代码\n目标代码\n可执行程序\n字节码\n图 1-2：Java 程序的编译和运行过程\n图 1-2 展示了这个过程包含的步骤。这个过程看似复杂，但在大多数程序开发环境中，这些步骤都是自动完成的：通常只需按一下按钮或输入简单的命令，就能编译并运行程序。然而，知道幕后执行了哪些步骤很重要，这样就可以在出现问题时找出问题所在。\n1.4　Hello World程序\n传统上，学习一门新的编程语言时，通常先编写一个名为 Hello World 的程序，它所做的只是在屏幕上显示“Hello, World!”。用 Java 编写时，这个程序与下面的类似：\npublic class Hello {\r\n\r\n    public static void main(String[] args) {\r\n        // 生成一些简单的输出\r\n        System.out.println(\"Hello, World!\");\r\n    }\r\n}\n这个程序运行时显示如下内容：\nHello, World!\n注意，输出中没有引号。\n类\n方法\n语句\n语句\n打印语句\nSystem.out.println(\"Hello, World!\");\nSystem.out.println\nprintln\n打印\n;\nSystem\nsystem\nSYSTEM\n方法\nmain\npublic static void main(String[] args)\nmain\nmain\n类\nHello\n{\n}\n//\n注释\n//\n1.5　显示字符串\nmain\npublic class Hello {\r\n\r\n    public static void main(String[] args) {\r\n        // 生成一些简单的输出\r\n        System.out.println(\"Hello, World!\"); // 第一行\r\n        System.out.println(\"How are you?\");  // 第二行\r\n    }\r\n}\n这个示例表明，除独占一行的注释外，还可在行尾添加注释。\n字符串\nSystem.out.println\n换行符\nprint\nprintln\npublic class Goodbye {\r\n\r\n    public static void main(String[] args) {\r\n        System.out.print(\"Goodbye, \");\r\n        System.out.println(\"cruel world\");\r\n    }\r\n}\nGoodbye, cruel world\n1.6　转义序列\n可用一行代码显示多行输出，只需告诉 Java 在哪里换行就可以了：\npublic class Hello {\r\n\r\n    public static void main(String[] args) {\r\n        System.out.print(\"Hello!\\nHow are you doing?\\n\");\r\n    }\r\n}\n上述代码的输出为两行，每行都以换行符结尾：\nHello!\r\nHow are you doing?\n\\n\n转义序列\n\\n\nHow\n转义序列的另一个常见用途是在字符串中包含引号。由于双引号标识字符串的开头和结尾，因此，要想在字符串中包含双引号，必须用反斜线对其进行转义。\nSystem.out.println(\"She said \\\"Hello!\\\" to me.\");\n结果如下：\nShe said \"Hello!\" to me.\n表1-1：常见的转义序列\n\\n\n换行符\n\\t\n制表符\n\\\"\n双引号\n\\\\\n反斜线\n1.7　设置代码格式\n在 Java 程序中，有些空格是必不可少的。例如，不同的单词之间至少得有一个空格，因此下面的程序是不合法的：\npublicclassGoodbye{\r\n\r\n    publicstaticvoidmain(String[] args) {\r\n        System.out.print(\"Goodbye, \");\r\n        System.out.println(\"cruel world\");\r\n    }\r\n}\n但其他空格大都是可有可无的。例如，下面的程序完全合法：\npublic class Goodbye {\r\npublic static void main(String[] args) {\r\nSystem.out.print(\"Goodbye, \");\r\nSystem.out.println(\"cruel world\");\r\n}\r\n}\n换行也是可选的，因此可将前面的代码编写如下：\npublic class Goodbye { public static void main(String[] args)\r\n{ System.out.print(\"Goodbye, \"); System.out.println\r\n(\"cruel world\");}}\n这也是可行的，但程序阅读起来更难了。要以直观的方式组织程序，换行和空格都很重要，使用它们可让程序更容易理解，发生错误时也更容易查找。\n很多编辑器都自动设置源代码的格式：以一致的方式缩进和换行。例如，在 DrJava（参见附录 A）中，可以按 Ctrl+A 选择所有的代码，再按 Tab 键来缩进代码。\nhttp://google.github.io/styleguide/javaguide.html\n这些指南提及了本书还未介绍的 Java 功能，因此你现在可能看不懂，但在阅读本书的过程中，你可能时不时地想要回过头来阅读它们。\n1.8　调试代码\n最好能在计算机前阅读本书，因为这样你就可以一边阅读一边尝试其中的示例。本书中的很多示例可直接在 DrJava 的 Interactions 窗格（见附录 A）中运行，但如果将代码存储到源代码文件中，则更容易对其修改再运行。\nprintln\n调试犹如实验科学：一旦对出问题的地方有所感觉，就修改程序并再次运行。如果假设没错，你就能预测修改后的结果，从而离程序正确运行更近一步；如果假设有误，你就必须作出新的假设。\n编程和调试必须齐头并进。不能先随便编写大量的代码，再通过反复调试来确保它们能够正确地运行；相反，应先编写少量可正确运行的代码，再逐步修改和调试，最终得到一个提供所需功能的程序。这样的方式可以确保在任何时候都有可运行的程序，从而更容易隔离错误。\nLinxu User\ns Guide\n最后，编程可能引发强烈的情绪。面对棘手的 bug 而束手无策时，你可能会感到愤怒、沮丧或窘迫。别忘了，并非只有你这样，大多数乃至所有程序员都有类似的经历；不要犹豫，赶快向朋友求助吧！\n1.9　术语表\n对于每个术语，本书都尽可能在首次用到时作出定义。同时，我们会在每章末尾按出现顺序列出涉及的新术语及其定义。如果你花点时间研究以下术语表，后面的内容阅读起来将更加轻松。\n解决问题\n明确地描述问题、找到并描述解决方案的过程。\n程序\n一系列的指令，指定了如何在计算机上执行任务。\n编程\n用问题解决技能创建可执行的计算机程序。\n计算机科学\n科学而实用的计算方法及其应用。\n算法\n解决问题的流程或公式，可以涉及计算机，也可以不涉及。\nbug\n程序中的错误。\n调试\n找出并消除错误的过程。\n高级语言\n人类能够轻松读写的编程语言。\n低级语言\n计算机能够轻松运行的编程语言，也叫“机器语言”或“汇编语言”。\n可移植\n程序能够在多种计算机上运行。\n解释\n指运行用高级语言编写的程序，即每次转换其中的一行并立即执行转换得到的指令。\n编译\n将用高级语言编写的程序一次性转换为低级语言，供以后执行。\n源代码\n用高级语言编写的、未编译的程序。\n目标代码\n编译器转换程序后得到的输出。\n可执行代码\n可在特定硬件上执行的目标代码的别名。\n字节码\nJava 程序使用的一种特殊目标代码，类似于低级语言，但像高级语言一样是可移植的。\n语句\n程序的一部分，指定了算法中的一个步骤。\n打印语句\n将输出显示到屏幕上的语句。\n方法\n命名的语句序列。\n类\n就目前而言，指的是一系列相关的方法。（后面你将看到，类并非只包含方法。）\n注释\n程序的一部分，包含有关程序的信息，但对程序的运行没有任何影响。\n字符串\n一系列字符，是一种基本的文本数据类型。\n换行符\n标识文本行尾的特殊字符。\n转义序列\n在字符串中用于表示特殊字母的编码序列。\n1.10　练习\n每章末尾都有练习，只需要利用在该章学到的知识就能完成。强烈建议你尝试完成每个练习，光阅读是学不会编程的，得实践才行。\n要想编译并运行 Java 程序，需要下载并安装一些工具。这样的工具很多，但我们推荐 DrJava——一个非常适合初学者使用的“集成开发环境”。有关如何安装 DrJava，请参阅附录 A 的 A.1 节。\n本章的示例代码位于仓库 ThinkJavaCode 的目录 ch01 中，有关如何下载这个仓库，请参阅前言中的“使用示例代码”一节。做以下的练习前，建议你先编译并运行本章的示例。\n练习1-1\n计算机科学家有个毛病，喜欢赋予常见的英语单词以新的义项。例如，在英语中 statement 和 comment 是同义词，但在程序中它们的含义不同。\n(1) 在计算机行话中，语句和注释有何不同？\n(2) 说程序是可移植的是什么意思？\n(3) 在普通英语中，单词 compile 是什么意思？\n(4) 何为可执行程序（executable）？为何这个单词被用作名词？\n每章末尾的术语表旨在突出计算机科学中有特殊含义的单词和短语。看到熟悉的单词时，千万不要理所应当地认为你知道它们的含义！\n练习1-2\n接着往下读之前，请先搞清楚如何编译和运行 Java 程序。有些编程环境提供了类似于本章 Hello World 程序的示例程序。\n(1) 输入 Hello World 程序的代码，再编辑并运行它。\n(2) 添加一条打印语句，在“Hello, World!”后面再显示一条诙谐的消息，如“How are you?”，然后再编译并运行这个程序。\n(3) 在这个程序中添加一条注释（什么地方都可以），再编译并运行它。新添的注释应该对结果没有任何影响。\n这个练习看似微不足道，却为编写程序打下了坚实的基础。要想得心应手地调试程序，必须熟悉编程环境。\n在一些编程环境中，一不小心就不知道当前执行的是哪个程序了。你可能想调试某个程序，却不小心运行了另一个程序。为确保你看到的就是要运行的程序，一种简单的方法是添加并修改打印语句。\n练习1-3\n将能想到的错误都犯一次是个不错的注意，这样你就知道编译器都会显示哪些错误消息了。在有些情况下，编译器会准确地指出错误，你只需要修复指出的错误即可；但有时候，错误消息会将你引入歧途。调试多了就会培养出感觉，知道什么情况下该信任编译器，什么情况下只能自力更生。\n请在本章的 Hello World 程序中尝试下面每一种错误。每次修改后编译程序并阅读出现的错误消息，然后再修复错误。\n(1) 删除其中的一个左大括号。\n(2) 删除其中的一个右大括号。\nmain\nmian\nstatic\npublic\nSystem\nprintln\nPrintln\nprintln\nprint\n(9) 删除其中的一个括号；添加一个括号。\n第 2 章　变量和运算符\n本章将介绍如何用变量和运算符来编写语句。变量用于存储数字、单词等值，而运算符是执行计算的符号。另外，本章还将介绍三种编程错误，并提供其他的调试建议。\n2.1　声明变量\n变量\n值\nString message;\n声明\nmessage\nString\n类型\nint\nchar\nInt\nstring\n要声明整型变量，可用如下语法：\nint x;\nx\nString firstName;\r\nString lastName;\r\nint hour, minute;\nString\nint\nfirstName\nfirstName\nfirstname\nFirstName\nhour\nminute\nint\n关键词\npublic\nclass\nstatic\nvoid\nint\nhttp://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html\n2.2　赋值\n赋值\nmessage = \"Hello!\"; // 给变量message指定值\"Hello!\"\r\nhour = 11;          // 将值11赋给变量hour\r\nminute = 59;        // 将变量minute的值设置为59\n这个示例包含三条赋值语句，其中的注释指出了三种解读赋值语句的方式。这里使用的术语可能令人迷惑，但涉及的概念简单易懂。\n当声明变量时，便创建了一个命名的存储位置。\n当给变量赋值时，便修改了它的值。\nmintue\nmessage\n看起来像\nmessage\n\"123\"\n'1'\n'2'\n'3'\n123\nmessage = \"123\"; // 合法\r\nmessage = 123;   // 非法\n初始化\nString message = \"Hello!\";\r\nint hour = 11;\r\nint minute = 59;\n2.3　状态图\na=b\na\na\na=7;\n7=a;\na\nb\na\nb\nint a = 5;\r\nint b = a;     // 现在a和b相等\r\na = 3;         // a和b不再相等\na\nb\n状态\n图 2-1：变量 a 和 b 的状态图\n状态图\n2.4　显示变量\nprint\nprintln\nfirstLine\n\"Hello, again!\"\nString firstLine = \"Hello, again!\";\r\nSystem.out.println(firstLine);\n值\n名称\nSystem.out.print(\"The value of firstLine is \");\r\nSystem.out.println(firstLine);\n这个示例的输出如下：\nThe value of firstLine is Hello, again!\n不管变量的类型如何，显示其值的语法都相同。例如：\nint hour = 11;\r\nint minute = 59;\r\nSystem.out.print(\"The current time is \");\r\nSystem.out.print(hour);\r\nSystem.out.print(\":\");\r\nSystem.out.print(minute);\r\nSystem.out.println(\".\");\n这个程序的输出如下：\nThe current time is 11:59.\nprint\nprintln\nprintln\nprint\nprintln\nprintln\n2.5　算术运算符\n算符\n+\n-\n*\n/\n下面的程序将时间转换为分钟数：\nint hour = 11;\r\nint minute = 59;\r\nSystem.out.print(\"Number of minutes since midnight: \");\r\nSystem.out.println(hour * 60 + minute);\nhour * 60 + minute\n表达式\n操作数\n前述示例的结果如下：\nNumber of minutes since midnight: 719\n表达式通常由数字、变量和运算符组成。程序编译并执行时，表达式将变成单个值。\n1 + 1\n2\nhour - 1\nhour\n11 - 1\n10\nhour * 60 + minute\n11 * 60 + 59\n660 + 59\n719\n加法、减法、乘法运算都与你的预期一样，但除法运算可能会让你感到意外。例如，下面的代码片段试图将分钟数转换为小时数：\nSystem.out.print(\"Fraction of the hour that has passed: \");\r\nSystem.out.println(minute / 60);\n其输出如下：\nFraction of the hour that has passed: 0\nminute\n一种替代方式是，计算百分比而不是小数：\nSystem.out.print(\"Percent of the hour that has passed: \");\r\nSystem.out.println(minute * 100 / 60);\n上述代码的输出如下：\nPercent of the hour that has passed: 98\n同样，结果也被向下圆整了，但至少离正确的答案更近了。\n2.6　浮点数\n浮点\ndouble\ndouble\ndouble pi;\r\npi = 3.14159;\ndouble\ndouble minute = 59.0;\r\nSystem.out.print(\"Fraction of the hour that has passed: \");\r\nSystem.out.println(minute / 60.0);\n输出如下：\nFraction of the hour that has passed: 0.9833333333333333\n1\n1.0\nint\ndouble\nint x = 1.1; // 编译错误\n自动\ndouble y = 1; // 合法，但这是一种糟糕的做法\nint\n1\ndouble\n1.0\ndouble y = 1 / 3; // 常见的错误\ny\n0.333333\n0\nint\n0\ndouble\n0.0\ny\ny\n0.333333\ndouble y = 1.0 / 3.0; // 正确\n作为一种编程风格，在任何情况下都应将浮点值赋给浮点变量。编译器并没有要求必须这样做，但如果不这样做的话，不知什么时候一个简单的错误就可能阴魂不散，给你带来麻烦。\n2.7　舍入误差\n大致\n舍入误差\nSystem.out.println(0.1 * 10);\r\nSystem.out.println(0.1 + 0.1 + 0.1 + 0.1 + 0.1\r\n                 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1);\n但在很多计算机上，它们的输出如下：\n1.0\r\n0.9999999999999999\n0.1\n绝对\ndouble balance = 123.45; // 可能存在舍入误差\n在这个示例中，随着不断地对变量执行算术运算（如存款和取款），它存储的值将不再准确。这可能会激怒顾客，甚至引发诉讼。为避免这种问题，可以用整数来表示余额：\nint balance = 12345; // 美分数\nint\n2.8　字符串运算符\n一般而言，不能对字符串执行数学运算，即便对那些看起来像数字的字符串亦是如此。下面的表达式是非法的：\n\"Hello\" - 1     \"World\" / 123    \"Hello\" * \"World\"\n+\n+\n串接\n\"Hello, \" + \"World!\"\n\"Hello, World!\"\nString\nname\n\"Hello, \" + name\nname\n鉴于对数字和字符串都定义了加法运算，因此 Java 可能执行意料之外的自动转换：\nSystem.out.println(1 + 2 + \"Hello\");\r\n// 输出为3Hello\r\n\r\nSystem.out.println(\"Hello\" + 1 + 2);\r\n// 输出为Hello12\n1 + 2\n3\n3 + \"Hello\"\n\"3Hello\"\n\"Hello\" + 1\n\"Hello1\"\n\"Hello1\" + 2\n\"Hello12\"\n运算顺序\n1 + 2 * 3\n7\n9\n2 + 4 / 2\n4\n3\nminute * 100 / 60\nminute\n5900 / 60\n98\n59 * 1\n(1 + 2) * 3\n9\n(minute * 100) / 60\n别费劲地去记运算符的优先级，尤其是除算术运算符外的其他运算符。如果表达式的含义不那么明显，可用括号让它清晰起来。\n2.9　组合\n前面分别介绍了编程语言的一些元素——变量、表达式和语句，但没有讨论如何结合使用它们。\n组合\nSystem.out.println(17 * 3);\n任何算术表达式都可用于打印语句中，我们见过这样的例子：\nSystem.out.println(hour * 60 + minute);\n还可将表达式放在赋值语句的右边：\nint percentage;\r\npercentage = (minute * 100) / 60;\n赋值语句的左边必须是变量名，不能是表达式，这是因为赋值语句的左边要指定将结果放在什么地方，而表达式表示的并非存储位置。\nhour = minute + 1;  // 正确\r\nminute + 1 = hour;  // 导致编译错误\n就目前而言，能够将操作组合起来好像没什么大不了的，但在本书的后文中你将了解到，这让我们能够编写简洁的代码以执行复杂的计算。不过，也别忘乎所以，冗长而复杂的表达式可能会难以理解和调试。\n2.10　错误类型\n程序中可能出现的错误有三种：编译时错误、运行时错误和逻辑错误。区分这些错误可以更快地找出错误。\n编译时错误\n语法\n(1 + 2)\n8)\n8)\n编译器显示的错误消息通常会指出错误出现在程序的什么地方，有时还可以准确地指出错误。我们来重温一下第 1 章中的 Hello World 程序。\npublic class Hello {\r\n\r\n    public static void main(String[] args) {\r\n        // 生成一些简单的输出\r\n        System.out.println(\"Hello, World!\");\r\n    }\r\n}\n如果遗漏了打印语句末尾的分号，将出现类似于以下的错误消息：\nFile: Hello.java  [line: 5]\r\nError: ';' expected\n真是太好了：这条错误消息准确地指出了错误的位置，还指出了是什么样的错误。\n然而，并非所有的错误消息都是容易理解的。有时编译器报告的错误位置不准确；有时对错误的描述模棱两可，几乎没什么帮助。\nmain\nFile: Hello.java  [line: 7]\r\nError: reached end of file while parsing\n分析\n错误消息提供了很有用的信息，你应尽力阅读并理解它们，但也不能将它们奉为圭臬。\n刚从事编程的几周内，你可能会为找出编译错误花费大量的时间，但随着经验越来越丰富，你犯的错误将越来越少，找出错误的速度也将越来越快。\n运行时错误\n本书前几章的简单程序中很少出现运行时错误，因此可能需要过段时间才能见到它们。运行时错误发生时，解释器将显示一条错误消息，指出在什么地方出现了什么问题。\n例如，如果你不小心将零用作了除数，将出现类似于以下的错误消息：\nException in thread \"main\" java.lang.ArithmeticException: / by zero at Hello.main(Hello.java:5)\njava.lang.ArithmeticException\n/ by zero\nHello.main\nHello\nmain\n有些错误消息还包含无意义的信息，因此你面临的挑战之一是确定有用的部分，而不被多余的信息搞得不知所措。另外别忘了，导致程序崩溃的代码行可能并不是需要修改的代码行。\n逻辑错误\npublic class Hello {\r\n\r\n    public static void main(String[] args) {\r\n        System.out.println(\"Hello, \");\r\n        System.out.println(\"World!\");\r\n    }\r\n}\n这个程序能够通过编译并运行，但输出如下：\nHello,\r\nWorld!\nprintln\nprint\n有时很难找出逻辑错误，因为你必须进行反向推导：根据输出结果推断程序行为不正确的原因，并确定如何让它的行为正确无误。编译器和解释器在这方面帮不了你，因为它们并不知道正确的行为是什么样的。\n了解这三种错误后，你应该阅读一下附录 C，其中搜集了一些我们最喜欢的调试建议。因为这些建议涉及了一些还未讨论的语言功能，所以你可能需要时不时地再次阅读这个附录。\n2.11　术语表\n变量\n命名的存储位置。所有变量都有类型，这是在创建变量时声明的。\n值\nint\nString\n声明\n创建变量并指定其类型的语句。\n类型\n从数学角度来说，类型是一个值集。变量的类型决定了它可存储哪些值。\n关键词\npublic\nclass\nvoid\n赋值\n给变量指定值的语句。\n初始化\n首次给变量赋值。\n状态\n程序中的变量及其当前值。\n状态图\n程序在特定时点的状态的图形表示。\n运算符\n表示计算（如加、乘和字符串串接）的符号。\n操作数\n运算符操作的值。在 Java 中，大多数运算符需要两个操作数。\n表达式\n表示单个值的变量、运算符和值的组合。表达式也有类型，这是由表达式包含的运算符和操作数决定的。\n浮点\ndouble\n舍入误差\n要表示的数字和与之最接近的浮点数之间的差。\n拼接\n将两个值（通常是字符串）首尾相连。\n运算顺序\n决定运算顺序执行的规则。\n组合\n将简单的表达式和语句合并为复合的表达式和语句。\n语法\n程序的结构，即程序包含的单词和符号的排列方式。\n编译时错误\n导致源代码无法编译的错误，也叫“语法错误”。\n分析\n分析程序的结构，这是编译器做的第一项工作。\n运行时错误\n导致程序无法完成运行的错误，也叫“异常”。\n逻辑错误\n导致程序的行为不符合程序员预期的错误。\n2.12　练习\n本章的示例代码位于仓库 ThinkJavaCode 的目录 ch02 中，有关如何下载这个仓库，请参阅前言中的“使用示例代码”一节。做以下的练习前，建议你先编译并运行本章的示例。\n如果你还没有阅读 A.2 节，那么现在正是阅读的好时机。该节介绍了 DrJava 的 Interactions 窗格，它提供了极佳的途径，让你无需编写完整的类定义就能开发并测试简短的代码片段。\n练习2-1\n如果你将本书用作教材的话，可能会很喜欢这个练习。找个同伴一起来玩 Stump the Chump 的游戏吧。\n先编写一个能够通过编译并正确运行的程序。一个人在程序中添加一个错误，另一个人不能偷看，然后尝试找出并修复这个错误。在不编译程序的情况下找出错误得两分，求助于编译器找出错误得 1 分，找不出错误对手得 1 分。\n练习2-2\nint\nString\n(1) 新建一个程序，将其命名为 Date.java。输入或复制类似于程序 Hello World 中的代码，并确保程序能够通过编译并运行。\nday\ndate\nmonth\nyear\nday\ndate\n(3) 显示（打印）每个变量的值，且每个变量要独占一行。这是一个中间步骤，有助于确认到目前为止一切正确。编译并运行这个程序，然后再接着往下做。\nThursday, July 16, 2015\n(5) 修改程序，使其以欧洲格式显示日期。最终的输出应类似于以下这样：\nAmerican format:\r\nThursday, July 16, 2015\r\nEuropean format:\r\nThursday 16 July 2015\n练习2-3\n这个练习旨在：使用一些算术运算符；考虑用多个值表示复合实体（如时间）。\n(1) 新建一个程序，将其命名为 Time.java。从现在开始，我们将不再提醒你先编写一个可运行的小程序，但你应该这样做。\nhour\nminute\nsecond\nhour\n(3) 让程序计算并显示从午夜开始过去了多少秒。\n(4) 计算并显示当天还余下多少秒。\n(5) 计算并显示当天已逝去时间的百分比。如果用整数计算百分比，可能会出现问题，因此请考虑使用浮点数。\nhour\nminute\nsecond\n提示\n第 3 章　输入和输出\n本书前面介绍的程序都只显示消息，并不涉及太多的计算。本章将介绍如何从键盘读取输入，并用这些输入来计算结果，再设置结果的输出格式。\nSystem\nSystem.out.println\nSystem\nSystem.out\nprintln\nSystem.out.println\nSystem.out\nSystem.out.println(System.out);\n结果如下：\njava.io.PrintStream@685d72cd\nSystem.out\nPrintStream\nPrintStream\njava.io\n包\njava.io\n@\nSystem.out\n地址\n685d72cd\nSystem\nPrintStream\n库\nSystem.out.println\nSystem\nout\nprintln\nPrintStream\nScanner\nSystem\nSystem.in\nInputStream\nScanner\njava.util\njava.util\nScanner\nimport java.util.Scanner;\n导入语句\nScanner\njava.util\nScanner\nScanner\n导入语句不能存在于类定义中。根据约定，它们通常位于文件的开头。\nScanner\nScanner in = new Scanner(System.in);\nin\nScanner\nScanner\nSystem.in\nScanner\nnextLine\nString\nimport java.util.Scanner;\r\n\r\npublic class Echo {\r\n\r\n    public static void main(String[] args) {\r\n        String line;\r\n        Scanner in = new Scanner(System.in);\r\n\r\n        System.out.print(\"Type something: \");\r\n        line = in.nextLine();\r\n        System.out.println(\"You said: \" + line);\r\n\r\n        System.out.print(\"Type something else: \");\r\n        line = in.nextLine();\r\n        System.out.println(\"You also said: \" + line);\r\n    }\r\n}\nScanner\nScanner\nSystem\nSystem\njava.lang\njava.lang\nString\njava.lang\n3.3　程序结构\n至此，我们介绍了 Java 程序的所有组成元素，图 3-2 显示了这些组织单元。\n图 3-2：Java 语言的组成元素，按从大到小的顺序排列\n标记\n数千个\nhttp://docs.oracle.com/javase/8/docs/api/\n语言\n库\n3.4　英寸到厘米的转换\n现在让我们来看一个有点实用价值的示例。虽然全球的大部分地区都在用公制度量衡，但有些国家依然还在用英制单位。例如，与欧洲的朋友谈论天气时，美国人可能要在摄氏温度和华氏温度之间进行转换。另外，还可能要将身高从英寸数转换为厘米数。\nScanner\nScanner\nint inch;\r\ndouble cm;\r\nScanner in = new Scanner(System.in);\nprint\nprintln\nScanner\nnextInt\nSystem.out.print(\"How many inches? \");\r\ninch = in.nextInt();\n接下来，我们将英寸数乘以 2.54（因为 1 英寸相当于 2.54 厘米）并显示结果：\ncm = inch * 2.54;\r\nSystem.out.print(inch + \" in = \");\r\nSystem.out.println(cm + \" cm\");\n这些代码可以正确运行，但存在一个小问题：其他程序员看到这些代码时，可能不明白 2.54 是怎么来的。为方便其他程序员（还有未来的你），更好的做法是将这个值赋给一个变量，并给这个变量指定一个有意义的名称。我们将在 3.5 节中对此进行演示。\n3.5　字面量和常量\n\" in =\"\n字面量\n魔幻数字\ndouble cmPerInch = 2.54;\r\ncm = inch * cmPerInch;\ncmPerInch\nfinal\nfinal double CM_PER_INCH = 2.54;\nfinal\nfinal\n常量\n3.6　设置输出的格式\nprint\nprintln\ndouble\nSystem.out.print(4.0 / 3.0);\n结果如下：\n1.3333333333333333\nSystem.out\nprintf\nprintf\nSystem.out.printf(\"Four thirds = %.3f\", 4.0 / 3.0);\n格式字符串\n格式说明符\n%.3f\nFour thirds = 1.333\n格式字符串可包含任意数目的格式说明符，下面的格式字符串就包含了两个格式说明符：\nint inch = 100;\r\ndouble cm = inch * CM_PER_INCH;\r\nSystem.out.printf(\"%d in = %f cm\\n\", inch, cm);\n结果如下：\n100 in = 254.000000 cm\nprint\nprintf\n%d\ninch\n%d\ncm\n%f\njava.util.Formatter\n表3-1：格式说明符示例\n%d\n十进制整数\n12345\n%08d\n添加前导零，确保显示的值至少包含 8 位\n00012345\n%f\n浮点数\n6.789000\n%.2f\n舍入到两位小数\n6.79\n3.7　厘米到英寸的转换\n现在假设有一个以厘米为单位的值，我们想将其转换为与之最接近的英寸数。你可能很想这样编写代码：\ninch = cm / CM_PER_INCH;  // 语法错误\n但这将导致编译错误，会出现类似于“Bad types in assignment: from double to int”这样的错误消息。这是因为右边是浮点数，而左边是整数变量。\n类型转换\ndouble pi = 3.14159;\r\nint x = (int) pi;\n(int)\nx\n3\n0.999999\n-0.999999\npi\ndouble pi = 3.14159;\r\ndouble x = (int) pi * 20.0;\n请务必牢记这一点。下面的代码演示了如何将厘米数转换为英寸数：\ninch = (int) (cm / CM_PER_INCH);\r\nSystem.out.printf(\"%f cm = %d in\\n\", cent, inch);\n转换运算符后面的括号使得除法运算先执行，然后再进行类型转换。因此除法运算的结果将向下圆整；我们将在下一章介绍如何将浮点数圆整为与之最接近的整数。\n3.8　求模运算符\n现在我们再进一步：假设你有一个以英寸为单位的值，并且想将其转换为英尺数和英寸数。为此，需要除以 12（1 英尺对应 12 英寸），并将余数记录下来。\n/\n求模\n%\n可像以下这样用除法和求模运算来将英寸数转换为英尺数和英寸数：\nquotient = 76 / 12;   // 除法\r\nremainder = 76 % 12;  // 求模\n第 1 行的结果为 6，第 2 行读作“76 与 12 的模”，结果为 4。因此，76 英寸相当于 6 英尺 4 英寸。\n求模运算符看起来像百分号，但其实可以将其视为除号（÷）向左旋转 90 度的结果。\nx % y\nx\ny\nx % 10\nx\nx % 100\n3.9　整合\nScanner\nprintf\nimport java.util.Scanner;\r\n\r\n/**\r\n * 将厘米数转换为英尺数和英寸数\r\n */\r\npublic class Convert {\r\n\r\n    public static void main(String[] args) {\r\n        double cm;\r\n        int feet, inches, remainder;\r\n        final double CM_PER_INCH = 2.54;\r\n        final int IN_PER_FOOT = 12;\r\n        Scanner in = new Scanner(System.in);\r\n\r\n        // 提示用户输入值并读取这个值\r\n        System.out.print(\"Exactly how many cm? \");\r\n        cm = in.nextDouble();\r\n\r\n        // 转换并输出结果\r\n        inches = (int) (cm / CM_PER_INCH);\r\n        feet = inches / IN_PER_FOOT;\r\n        remainder = inches % IN_PER_FOOT;\r\n        System.out.printf(\"%.2f cm = %d ft, %d in\\n\",\r\n                          cm, feet, remainder);\r\n    }\r\n}\nmain\n/**\nIN_PER_FOOT\n常见的编程风格是将过长（超过 80 个字符）的语句分成多行，以便阅读时不用水平滚动。\nScanner\nScanner\nSystem.out.print(\"What is your name? \");\r\nname = in.nextLine();\r\nSystem.out.print(\"What is your age? \");\r\nage = in.nextInt();\r\nSystem.out.printf(\"Hello %s, age %d\\n\", name, age);\n其输出可能类似于以下这样：\nHello Grace Hopper, age 45\nString\nint\nint\nString\nSystem.out.print(\"What is your age? \");\r\nage = in.nextInt();\r\nSystem.out.print(\"What is your name? \");\r\nname = in.nextLine();\r\nSystem.out.printf(\"Hello %s, age %d\\n\", name, age);\n如果尝试运行上述示例代码，你将发现它根本不允许输入姓名，而在你输入年龄后会直接显示输出：\nWhat is your name? Hello , age 45\nScanner\nScanner\nScanner\nnextInt\nnextInt\nnextInt\nnextInt\n45\nWhat is your name?\nnextLine\nnextLine\n\"\"\nnextInt\nnextLine\nSystem.out.print(\"What is your age? \");\r\nage = in.nextInt();\r\nin.nextLine();  // 读取换行符\r\nSystem.out.print(\"What is your name? \");\r\nname = in.nextLine();\r\nSystem.out.printf(\"Hello %s, age %d\\n\", name, age);\nint\ndouble\n3.11　术语表\n包\n一组彼此相关的类。\n地址\n值在计算机内存中的位置，通常用十六进制整数表示。\n库\n可在其他程序中使用的一系列包和类。\n导入语句\n让程序能够使用其他包中定义的类的语句。\n标记\n程序的基本元素，如单词、空格、符号或数字。\n字面量\n\"Hello\"\n74\n魔幻数字\n表达式中没有任何解释的数字，通常应将其替换为常量。\n常量\nfinal\n格式字符串\nprintf\n格式说明符\n以百分号开头的特殊编码，指定了相应值的数据类型和格式。\n类型转换\nint\n求模\n5 \\% 2\n1\n3.12　练习\n本章的示例代码位于仓库 ThinkJavaCode 的目录 ch03 中，有关如何下载这个仓库，请参阅前言中的“使用示例代码”一节。做以下的练习前，建议你先编译并运行本章的示例。\n如果你还没有阅读 A.3 节，那么现在正是阅读的好时机。该节介绍了命令行界面，这是与计算机交互的强大而高效的一种方式。\n练习3-1\nprintf\n%f\nint\n%d\ndouble\n练习3-2\ndouble\n\"24.0 C=75.2 F\"\n下面是转换公式，请注意，千万不要用整数除法！\n练习3-3\nprintf\n\"5000 seconds = 1 hours, 23 minutes, and 20 seconds\"\n提示\n练习3-4\n这个练习的目标是编写一个“猜数”游戏，其输出应类似于以下这样：\nI'm thinking of a number between 1 and 100\r\n(including both). Can you guess what it is?\r\nType a number: 45\r\nYour guess is: 45\r\nThe number I was thinking of is: 14\r\nYou were off by: 31\njava.util\nRandom\nimport java.util.Random;\r\n\r\npublic class GuessStarter {\r\n\r\n    public static void main(String[] args) {\r\n        // 生成一个随机数\r\n        Random random = new Random();\r\n        int number = random.nextInt(100) + 1;\r\n        System.out.println(number);\r\n    }\r\n}\nScanner\nRandom\nScanner\nnew\nRandom\nnextInt\nnextInt(100)\nGuessStarter\n(2) 编译并运行这个程序。\nScanner\n(4) 将用户输入作为整数读取，并显示结果。再次编译并测试这个程序。\n(5) 计算并显示用户猜测的数字和生成的随机数之间的差。\n第 4 章　void 方法\nmain\nMath\nMath\nx\n实参\n计算 log(1/sin(π/2)) 这样更复杂的表达式时，可重复执行这个过程：先计算最里面的函数的实参，再计算函数本身，依此类推。\nMath\njava.lang\n调用\nMath\ndouble root = Math.sqrt(17.0);\r\ndouble angle = 1.5;\r\ndouble height = Math.sin(angle);\nroot\nangle\n弧度\nMath\nPI\ndouble\ndouble degrees = 90;\r\ndouble angle = degrees / 180.0 * Math.PI;\nPI\nPi\npi\npie\nPI\nMath.E\nMath\ndouble radians = Math.toRadians(180.0);\r\ndouble degrees = Math.toDegrees(Math.PI);\nround\nlong\nlong\nint\nint\n31\nlong\n63\n18\nlong x = Math.round(Math.PI * 20.0);\n结果为 63（这是将 62.8319 向上圆整得到的）。\nMath\n4.2　再谈组合\n组合\ndouble x = Math.cos(angle + Math.PI / 2.0);\nMath.PI\nangle\ndouble x = Math.exp(Math.log(10.0));\nlog\nx\nMath\nMath.pow\n1024.0\nx\ndouble x = Math.pow(2.0, 10.0);\nMath\nMath\npow(2.0, 10.0)\nFile: Test.java [line: 5]\r\nError: cannot find symbol\r\n  symbol: method pow(double,double)\r\n  location: class Test\npow\nTest\n4.3　添加方法\n此时你应该已经猜到了，在一个类中可定义多个方法，如下例所示：\npublic class NewLine {\r\n\r\n    public static void newLine() {\r\n        System.out.println();\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        System.out.println(\"First line.\");\r\n        newLine();\r\n        System.out.println(\"Second line.\");\r\n    }\r\n}\nNewLine\nNewLine\nnewLine\nmain\nNewLine\nnewLine\njammingWordsTogetherLikeThis\nmain\nnewLine\nmain\nvoid\nMath\n形参\nmain\nargs\nString[]\nmain\nnewLine\nmain\nnewLine\nmain\nmain\nnewLine\n这个程序的输出如下：\nFirst line.\r\n\r\nSecond line.\nnewLine\npublic static void main(String[] args) {\r\n    System.out.println(\"First line.\");\r\n    newLine();\r\n    newLine();\r\n    newLine();\r\n    System.out.println(\"Second line.\");\r\n}\n我们也可以再编写一个显示三个空行的方法：\npublic static void threeLine() {\r\n    newLine();\r\n    newLine();\r\n    newLine();\r\n}\r\n\r\npublic static void main(String[] args) {\r\n    System.out.println(\"First line.\");\r\n    threeLine();\r\n    System.out.println(\"Second line.\");\r\n}\nmain\nthreeLine\nthreeLine\nnewLine\n初学者常常对不厌其烦地创建新方法心存疑惑。这样做的原因很多，这个示例说明了其中的几个原因。\n通过创建新方法，你可以给一组语句指定名称，从而让代码更容易阅读和理解。\nthreeLine\n一种常见的问题解决技巧是将任务划分成子问题。方法让你能够只专注于子问题，然后再将方法组合成完整的解决方案。\n4.4　执行流程\n将 4.3 节中的代码组合起来可以得到类似于下面这样的完整程序：\npublic class NewLine {\r\n\r\n    public static void newLine() {\r\n        System.out.println();\r\n    }\r\n\r\n    public static void threeLine() {\r\n        newLine();\r\n        newLine();\r\n        newLine();\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        System.out.println(\"First line.\");\r\n        threeLine();\r\n        System.out.println(\"Second line.\");\r\n    }\r\n}\n执行流程\nmain\nmain\nthreeLine\nthreeLine\nnewLine\nnewLine\nprintln\nprintln\nnewLine\nnewLine\nthreeLine\nthreeLine\nmain\n总之，阅读程序时，不要按照从头到尾的顺序阅读，而应按执行流程阅读。\n4.5　形参和实参\nsin\ndouble\nprintln\nString\n在使用方法时提供的是实参，在编写方法时指定的是形参。形参列表指定了必须提供哪些实参，以下是一个示例：\npublic class PrintTwice {\r\n\r\n    public static void printTwice(String s) {\r\n        System.out.println(s);\r\n        System.out.println(s);\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        printTwice(\"Don't make me say this twice!\");\r\n    }\r\n}\nprintTwice\ns\nString\nprintTwice\nString\n\"Don't make me say this twice!\"\ns\n参数传递\nString\nString argument = \"Never say never.\";\r\nprintTwice(argument);\n用作实参的值必须与形参的类型相同，例如，如果你试图像下面这样做：\nprintTwice(17);  // 语法错误\n将出现类似于下面这样的错误消息：\nFile: Test.java [line: 10]\r\nError: method printTwice in class Test cannot be applied\r\n       to given types;\r\n  required: java.lang.String\r\n  found: int\r\n  reason: actual argument int cannot be converted to\r\n          java.lang.String by method invocation conversion\nMath.sqrt\ndouble\nMath.sqrt(25)\n25\n25.0\nprintTwice\n17\nString\nmain\ns\nprintTwice\nargs\nmain\n局部变量\n4.6　多个形参\n下面是一个接受两个形参的方法：\npublic static void printTime(int hour, int minute) {\r\n    System.out.print(hour);\r\n    System.out.print(\":\");\r\n    System.out.println(minute);\r\n}\n你可能很想将上述的形参列表写成下面这样：\npublic static void printTime(int hour, minute) {\r\n    ...\nint\n要调用这个方法，必须提供两个整数实参：\nint hour = 11;\r\nint minute = 59;\r\nprintTime(hour, minute);\n常见的错误是像下面这样声明实参的类型：\nint hour = 11;\r\nint minute = 59;\r\nprintTime(int hour, int minute);  // 语法错误\nint hour\nint minute\nprintTime(int 11, int 59); // 语法错误\n4.7　栈图\n将 4.6 节的代码片段组合起来可以得到完整的类定义，如下：\npublic class PrintTime {\r\n\r\n    public static void printTime(int hour, int minute) {\r\n        System.out.print(hour);\r\n        System.out.print(\":\");\r\n        System.out.println(minute);\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        int hour = 11;\r\n        int minute = 59;\r\n        printTime(hour, minute);\r\n    }\r\n}\nprintTime\nhour\nminute\nmain\nhour\nminute\nprintTime\nhour\nmain\nhour\nprintTime\nint hour = 11;\r\nint minute = 59;\r\nprintTime(hour + 1, 0);\n12\n0\nprintTime\nhour\n12\n11\nminute\n0\n59\nprintTime\nmain\n栈图\n栈帧\nprintTime\nPrintTime\n4.8　阅读文档\nJava 的优点之一是自带了庞大的类库和方法。但在使用之前，可能还必须阅读文档，而这并非总是那么容易。\nScanner\nScanner\njava.util\nScanner\n文档的下一部分是描述，阐述了当前类的用途，还包含了使用示例。这些内容可能难以理解，因为其中使用了你还没有学过的术语，但其中的示例经常很有用。要开始使用新类，一种不错的方式是将文档中的示例粘贴到测试文件中，看看它们能否编译并运行。\nScanner\nString\nSystem.in\nString input = \"1 fish 2 fish red fish blue fish\";\r\nScanner s = new Scanner(input);\n描述、代码示例和其他细节的后面是以下几个表格：\nConstructor summary\nScanner\nMethod summary\nScanner\nConstructor detail\nScanner\nMethod detail\n有关各个方法的详细信息\nnextInt\npublic int nextInt()\r\nScans the next token of the input as an int.\n特征标\nint\n表格 Method detail 更详细地阐述了这个方法：\npublic int nextInt()\r\nScans the next token of the input as an int.\r\n\r\nAn invocation of this method of the form nextInt() behaves in\r\nexactly the same way as the invocation nextInt(radix), where\r\nradix is the default radix of this scanner.\r\n\r\nReturns:\r\nthe int scanned from the input\r\nThrows:\r\nInputMismatchException - if the next token does not match\r\n    the Integer regular expression, or is out of range\r\nNoSuchElementException - if input is exhausted\r\nIllegalStateException - if this scanner is closed\n其中的 Returns 部分描述了这个方法成功时返回的结果，而 Throws 部分描述了可能发生的错误及其引发的异常。\n要想熟练地阅读文档并就哪些部分可以忽略作出准确的判断，可能需要一段时间的学习，但这样的付出是值得的。知道 Java 库有哪些类可避免重复劳动，只需阅读少量的文档就可避免繁重的调试工作。\n4.9　编写文档\n受益于优秀文档的同时，应该编写优秀的文档来作为回报。Java 语言提供了一项很好的功能，即可以在源代码中嵌入文档。这让你能够在编写代码的同时编写文档，同时，更容易在修改代码时确保文档与代码一致。\n可用工具 Javadoc 自动提取包含在源代码中的文档，并生成格式良好的 HTML。这个工具包含在标准 Java 开发环境中，被大家广泛使用。事实上，Java 库的在线文档就是用 Javadoc 生成的。\n文档注释\n/**\n*/\nmain\n/**\r\n * 演示print和println的示例程序\r\n */\r\npublic class Goodbye {\r\n\r\n    /**\r\n     * 打印问候语\r\n     */\r\n    public static void main(String[] args) {\r\n        System.out.print(\"Goodbye, \"); // 请注意其中的空格\r\n        System.out.println(\"cruel world\");\r\n    }\r\n}\n类注释阐述了类的目的，而方法注释阐述了方法的作用。\n//\n相反，Javadoc 注释更长，通常是完整的句子。它们阐述每个方法的功能，但不涉及其工作原理的细节，旨在让人无需查看源代码就能使用这些方法。\n要想让源代码易于理解，合适的注释和文档是必不可少的。另外别忘了，对于你编写的代码，未来阅读得最多的人就是你自己，届时你定将庆幸自己编写了优秀的文档。\n4.10　术语表\n实参\n调用方法时提供的值，其类型必须与相应形参的类型相同。\n调用\n执行方法。\n形参\n运行方法所需要的信息。形参也是变量，包含值和类型。\n执行流程\nJava 执行方法和语句的顺序，这种顺序并不一定是从上到下、从左到右的。\n参数传递\n将实参的值赋给形参变量的过程。\n局部变量\n在方法内声明的变量；在所属方法外不能访问。\n栈图\n各个方法中的变量的图形化表示。执行流程中的方法调用按从上到下的顺序堆叠。\n栈帧\n在栈图中表示特定方法中的变量和形参及其当前值的部分。\n特征标\n方法的第一行，定义了方法的名称、返回类型和形参。\nJavadoc\n读取 Java 源代码并生成 HTML 格式文档的工具。\n文档\n描述类或方法用法的注释。\n4.11　练习\n本章的示例代码位于仓库 ThinkJavaCode 的目录 ch04 中，有关如何下载这个仓库，请参阅前言中的“使用示例代码”一节。做以下的练习前，建议你先编译并运行本章的示例。\n如果你还没有阅读 A.4 节，那么现在正是阅读的好时机。该节介绍了对接受用户输入并显示输出的程序进行测试的一种高效方式。\n练习4-1\n这个练习的意义在于阅读包含多个方法的程序的代码，并确保你明白其执行流程。\n(1) 下面程序的输出是什么？务必准确地指出哪些地方有空格以及在哪些地方换行了。\n提示\nping\nbaffle\nping\nping\nbaffle()\npublic static void zoop() {\r\n    baffle();\r\n    System.out.print(\"You wugga \");\r\n    baffle();\r\n}\r\n\r\npublic static void main(String[] args) {\r\n    System.out.print(\"No, I \");\r\n    zoop();\r\n    System.out.print(\"I \");\r\n    baffle();\r\n}\r\n\r\npublic static void baffle() {\r\n    System.out.print(\"wug\");\r\n    ping();\r\n}\r\n\r\npublic static void ping() {\r\n    System.out.println(\".\");\r\n}\n练习4-2\n这个练习旨在确保你明白如何编写和调用接受参数的方法。\nzool\nint\nString\nzool\n11\n练习4-3\n这个练习的目的在于将之前编写的代码封装到一个接受参数的方法中。做这个练习前，必须先完成练习 2-2。\nprintAmerican\nmain\nSaturday, July 22, 2015\nprintAmerican\nprintEuropean\n第 5 章　条件和逻辑\nboolean\nif\n5.1　关系运算符\n关系运算符\nx == y           // x等于y\r\nx != y           // x与y不相等\r\nx > y            // x大于y\r\nx < y            // x小于y\r\nx >= y           // x大于或等于y\r\nx <= y           // x小于或等于y\ntrue\nfalse\nboolean\nboolean\n=\n≠\n≤\n=\n==\n=\n==\n=<\n=>\n5 < \"6\"\n5\nint\n\"6\"\nString\n5 < 6.0\n5\n5.0\n==\n!=\nequals\nString fruit1 = \"Apple\";\r\nString fruit2 = \"Orange\";\r\nSystem.out.println(fruit1.equals(fruit2));\nfruit1.equals(fruit2)\nboolean\nfalse\n5.2　逻辑运算符\n逻辑运算符\n&&\n||\n!\nx\nx > 0 && x < 10\ntrue\nevenFlag || n \\% 3 == 0\nevenFlag\nn\ntrue\n!\nboolean\nevenFlag\ntrue\n!evenFlag\ntrue\ntrue || anything\ntrue\nanything\nfalse && anything\nfalse\n短路\nanything\nanything\n如果你曾必须对包含逻辑运算符的表达式求反，以后也很可能遇到这样的情况。在这种情况下，德 · 摩根定律（De Morgan's laws）可以提供帮助：\n!(A && B)\n!A || !B\n!(A || B)\n!A && !B\n!\n&&\n||\n!A\n!B\n德 · 摩根定律也适用于关系运算符。在这种情况下，对每一项求反意味着使用“相反”的运算符：\n!(x < 5 && y == 3 )\nx > =5 || y! = 3\n!(x >= 1 || y! = 7 )\nx < 1 && y == 7\nx\ny\nx\ny\n5.3　条件语句\n条件语句\nif\nif (x > 0) {\r\n    System.out.println(\"x is positive\");\r\n}\ntrue\nboolean\nif\nelse\n分支\nif (x % 2 == 0) {\r\n    System.out.println(\"x is even\");\r\n} else {\r\n    System.out.println(\"x is odd\");\r\n}\nx\nx\n对于只有一条语句的分支来说，大括号是可选的，因此前一个示例可以写成下面这样：\nif (x % 2 == 0)\r\n    System.out.println(\"x is even\");\r\nelse\r\n    System.out.println(\"x is odd\");\nif\nelse\nif (x > 0)\r\n    System.out.println(\"x is positive\");\r\n    System.out.println(\"x is not zero\");\nprintln\nif\nif (x > 0) {\r\n    System.out.println(\"x is positive\");\r\n}\r\n    System.out.println(\"x is not zero\");\nprintln\n5.4　串接和嵌套\nif\nelse\n串接\nif (x > 0) {\r\n    System.out.println(\"x is positive\");\r\n} else if (x < 0) {\r\n    System.out.println(\"x is negative\");\r\n} else {\r\n    System.out.println(\"x is zero\");\r\n}\n你可以想串接多长就串接多长，但太长可能难以阅读。为提高可读性，可使用标准的缩进方式，如这里的示例所示。将语句和大括号对齐可降低出现语法错误的可能性。\n嵌套\nif (x == 0) {\r\n    System.out.println(\"x is zero\");\r\n} else {\r\n    if (x > 0) {\r\n        System.out.println(\"x is positive\");\r\n    } else {\r\n        System.out.println(\"x is negative\");\r\n    }\r\n}\n外面的条件语句有两个分支，第一个分支包含一条打印语句，第二个分支包含另一个条件语句，该条件语句也有两个分支。这两个分支都是打印语句，但它们本来也可以是条件语句。\n这样的嵌套结构很常见，但很难快速地阅读它们。因此我们必须使用正确的缩进，以便这种结构易于理解。\n5.5　标志变量\ntrue\nfalse\nboolean\nboolean\nboolean flag;\r\nflag = true;\r\nboolean testResult = false;\nboolean\nboolean evenFlag = (n % 2 == 0);    // n为偶数时为true\r\nboolean positiveFlag = (x > 0);     // x为正数时为true\n标志\n定义标志变量后，就可以在条件语句中使用了：\nif (evenFlag) {\r\n    System.out.println(\"n was even when I checked it\");\r\n}\nif (evenFlag == true)\nevenFlag\nboolean\nfalse\nif (!evenFlag) {\r\n    System.out.println(\"n was odd when I checked it\");\r\n}\nreturn\nreturn\nreturn\npublic static void printLogarithm(double x) {\r\n    if (x <= 0.0) {\r\n        System.err.println(\"Error: x must be positive.\");\r\n        return;\r\n    }\r\n    double result = Math.log(x);\r\n    System.out.println(\"The log of x is \" + result);\r\n}\nprintLogarithm\ndouble\nx\nx\nreturn\nSystem.err\nOutputStream\nSystem.err\n5.7　验证输入\nprintLogarithm\npublic static void scanDouble() {\r\n    Scanner in = new Scanner(System.in);\r\n    System.out.print(\"Enter a number: \");\r\n    double x = in.nextDouble();\r\n    printLogarithm(x);\r\n}\nnextDouble\nScanner\ndouble\nScanner\ndouble\nScanner\nInputMismatchException\n为防范这种错误，可在分析前检查输入：\npublic static void scanDouble() {\r\n    Scanner in = new Scanner(System.in);\r\n    System.out.print(\"Enter a number: \");\r\n    if (!in.hasNextDouble()) {\r\n        String word = in.next();\r\n        System.err.println(word + \" is not a number\");\r\n        return;\r\n    }\r\n    double x = in.nextDouble();\r\n    printLogarithm(x);\r\n}\nScanner\nhasNextDouble\ndouble\nnextDouble\nmain\n5.8　递归方法\n递归\npublic static void countdown(int n) {\r\n    if (n == 0) {\r\n        System.out.println(\"Blastoff!\");\r\n    } else {\r\n        System.out.println(n);\r\n        countdown(n - 1);\r\n    }\r\n}\ncountdown\nn-1\n递归方法\nmain\ncountdown(3)\n这次执行 countdown 时，n==3；由于 n 不为零，因此它显示值3，再调用自己……\r\n    这次执行 countdown 时，n==2；由于 n 不为零，因此它显示值2，再调\r\n    用自己……\r\n        这次执行 countdown 时，n==1；由于 n 不为零，因此它显示值\r\n        1，再调用自己……\r\n            这次执行 countdown 时，n==0；由于n 为零，因此它\r\n            显示值“Blastoff!”再返回。\r\n        使用 1 调用的 countdown 返回。\r\n    使用 2 调用的 countdown 返回。\r\n使用 3 调用的 countdown 返回。\nmain\n3\r\n2\r\n1\r\nBlastoff!\nnewLine\nthreeLine\npublic static void newLine() {\r\n    System.out.println();\r\n}\r\n\r\npublic static void threeLine() {\r\n    newLine();\r\n    newLine();\r\n    newLine();\r\n}\n虽然这些方法管用，但如果要显示 2 个或 100 个空行，它们并不能提供帮助。下面是一种更佳的解决方案：\npublic static void nLines(int n) {\r\n    if (n > 0) {\r\n        System.out.println();\r\n        nLines(n - 1);\r\n    }\r\n}\nn\nn\ncountdown\nn\nn\nn\nn\n5.9　递归栈图\n第 4 章用栈图来表示程序在方法调用期间的状态，使用相同的图可让递归方法更容易解释。\ncountdown\ncountdown\nmain\nmain\nargs\ncountdown\nn\n基线条件\nStackOverflowError\n例如，下面的递归方法就不包含基线条件：\npublic static void forever(String s) {\r\n    System.out.println(s);\r\n    forever(s);\r\n}\n这个方法将不断地显示指定的字符串，直到栈溢出，进而引发异常。\n5.10　二进制数\ncountdown\npublic static void countup(int n) {\r\n    if (n == 0) {\r\n        System.out.println(\"Blastoff!\");\r\n    } else {\r\n        countup(n - 1);\r\n        System.out.println(n);\r\n    }\r\n}\nn\nSystem.out.println\nBlastoff!\r\n1\r\n2\r\n3\n二进制\n23 / 2 is 11 remainder 1\r\n11 / 2 is  5 remainder 1\r\n 5 / 2 is  2 remainder 1\r\n 2 / 2 is  1 remainder 0\r\n 1 / 2 is  0 remainder 1\nhttp://www.mathsisfun.com/binary-number-system.html\n下面的递归方法可用于显示任何正整数的二进制表示：\npublic static void displayBinary(int value) {\r\n    if (value > 0) {\r\n        displayBinary(value / 2);\r\n        System.out.print(value % 2);\r\n    }\r\n}\nvalue\ndisplayBinary\ndisplayBinary\nprintln\ndisplayBinary(23);\r\nSystem.out.println();\r\n// 输出为10111\n要想像计算机科学家那样思考，学会递归思维很重要。向上或向下执行计算的递归算法可以用简洁的方式实现很多算法。\n5.11　术语表\nboolean\ntrue\nfalse\n关系运算符\n对两个值进行比较，从而得到一个表示两者关系的 boolean 值的运算符。\n逻辑运算符\nboolean\nboolean\n短路\n执行逻辑运算符的一种方式，仅在必要时计算第二个操作数的值。\n德 · 摩根定律\n指出如何对逻辑表达式求反的数学规则。\n条件语句\n根据条件确定执行哪些语句的语句。\n分支\n条件语句中多个可能执行的语句块之一。\n串接\n一种将多个条件语句依次连接起来的方式。\n嵌套\n在一个条件语句的分支中包含另一个条件语句。\n标志\nboolean\n递归\n在当前执行的方法中再调用该方法的过程。\n递归方法\n调用自己的方法，通常提供不同的实参。\n基线条件\n导致递归方法不再进行递归调用的条件。\n二进制\n只用 0 和 1 表示数字的计数系统，也被称为“以 2 为基数”的计数系统。\n5.12　练习\n本章的示例代码位于仓库 ThinkJavaCode 的目录 ch05 中，有关如何下载这个仓库，请参阅前言中的“使用示例代码”一节。做以下的练习前，建议你先编译并运行本章的示例。\n如果你还没有阅读 A.6 节，那么现在正是阅读的好时机。该节介绍了 DrJava 调试器，这是一个很有用的执行流程跟踪工具。\n练习5-1\nif\nif (x > 0) {\r\n    if (x < 10) {\r\n        System.out.println(\"positive single digit number.\");\r\n    }\r\n}\n练习5-2\n根据下面的程序：\n第二次\nping\n(2) 这个程序的完整输出是什么？\npublic static void zoop(String fred, int bob) {\r\n    System.out.println(fred);\r\n    if (bob == 5) {\r\n        ping(\"not \");\r\n    } else {\r\n        System.out.println(\"!\");\r\n    }\r\n}\r\n\r\npublic static void main(String[] args) {\r\n    int bizz = 5;\r\n    int buzz = 2;\r\n    zoop(\"just for\", bizz);\r\n    clink(2 * buzz);\r\n}\r\n\r\npublic static void clink(int fork) {\r\n    System.out.print(\"It's \");\r\n    zoop(\"breakfast \", fork) ;\r\n}\r\n\r\npublic static void ping(String strangStrung) {\r\n    System.out.println(\"any \" + strangStrung + \"more \");\r\n}\n练习5-3\nmain\nnLines\nnLines\n练习5-4\nn\nn\nn\nn\ncheckFermat\na\nb\nc\nn\nn\nn\nn\nn\n提示\nMath.pow\n练习5-5\n99 Bottles of Beer\n99 bottles of beer on the wall,\n99 bottles of beer,\nya' take one down, ya' pass it around,\n98 bottles of beer on the wall.\n接下来的各段歌词与此相同，只是每段中的瓶数依次少 1。而最后一段歌词如下：\nNo bottles of beer on the wall,\nno bottles of beer,\nya' can't take one down, ya' can't pass it around,\n'cause there are no more bottles of beer on the wall!\n至此，这个歌曲总算结束了。\n请编写一个显示这首歌全部歌词的程序。程序应包含一个承担重任的递归方法，但你可能还需要编写其他方法。可在程序编写期间用较少的段数（如 3）进行测试。\n练习5-6\n这个练习将通过一个包含多个方法的程序来复习执行流程。请阅读下面的代码，并回答后面的问题。\npublic class Buzz {\r\n\r\n    public static void baffle(String blimp) {\r\n        System.out.println(blimp);\r\n        zippo(\"ping\", -5);\r\n    }\r\n\r\n    public static void zippo(String quince, int flag) {\r\n        if (flag < 0) {\r\n            System.out.println(quince + \" zoop\");\r\n        } else {\r\n            System.out.println(\"ik\");\r\n            baffle(quince);\r\n            System.out.println(\"boo-wa-ha-ha\");\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        zippo(\"rattle\", 13);\r\n    }\r\n}\n(1) 在这个程序首先执行的代码行旁边标上数字 1。\n(2) 在这个程序执行的第 2 行代码旁边标上数字 2，再依此类推，直到该程序末尾。多次执行的代码行旁边将有多个数字。\nbaffle\nblimp\n(4) 这个程序的输出是什么？\n练习5-7\n学习条件语句后，现在我们可以回过头去完善练习 3-4 中的“猜数”游戏了。\n你应该已经有这样一个程序，它可以选择一个随机数，让用户猜这个数，并显示用户猜的数字与这个随机数的差距。\n请修改这个程序，让程序可以告诉用户他猜的数字太大还是太小，并提示用户再猜一次。每次修改只添加少量的代码，并边修改边测试。\n这个程序应不断运行，直到用户猜对为止。\n提示\n第 6 章　值方法\nMath\n编写\nvoid\n值方法\n6.1　返回值\nvoid\ncountup\npublic static void countup(int n) {\r\n    if (n == 0) {\r\n        System.out.println(\"Blastoff!\");\r\n    } else {\r\n        countup(n - 1);\r\n        System.out.println(n);\r\n    }\r\n}\n下面的代码演示了如何调用它：\ncountup(3);\r\nSystem.out.println(\"Have a nice day.\");\n另一方面，调用值方法时，必须对其返回值做些什么。我们通常将其赋给变量或用于表达式中，如下所示：\ndouble error = Math.abs(expected - actual);\r\ndouble height = radius * Math.sin(angle);\nvoid\n返回类型\nreturn\n返回值\ncalculateArea\ndouble\npublic static double calculateArea(double radius) {\r\n    double result = Math.PI * radius * radius;\r\n    return result;\r\n}\nvoid\ndouble\ndouble\nreturn\npublic static double calculateArea(double radius) {\r\n    return Math.PI * radius * radius;\r\n}\nresult\n临时变量\nreturn\ndouble\ndouble\nreturn\nreturn\npublic static double absoluteValue(double x) {\r\n    if (x < 0) {\r\n        return -x;\r\n    } else {\r\n        return x;\r\n    }\r\n}\nreturn\nreturn\nreturn\n无用代码\npublic static double absoluteValue(double x) {\r\n    if (x < 0) {\r\n        return -x;\r\n    } else {\r\n        return x;\r\n    }\r\n    System.out.println(\"This line is dead.\");\r\n}\nreturn\nreturn\npublic static double absoluteValue(double x) {\r\n    if (x < 0) {\r\n        return -x;\r\n    } else if (x > 0) {\r\n        return x;\r\n    }\r\n    // 语法错误\r\n}\nx\nreturn\nreturn\nreturn\n6.2　编写方法\n渐进开发\n先编写一个能够运行的简单程序，再逐步修改。这样的话，无论什么时候出现错误，你都知道该检查哪些地方。\n用变量存储中间值，以便能够用打印语句或调试器检查它们。\n程序能够正确运行后再将多条语句合并为复合表达式（前提是这样不会导致程序更难理解）。\nx\n1\ny\n1\nx\n2\ny\n2\ndistance\ndouble\ndouble\n存根\nreturn\npublic static double distance\r\n        (double x1, double y1, double x2, double y2) {\r\n    return 0.0;\r\n}\nreturn\nmain\ndouble dist = distance(1.0, 2.0, 4.0, 6.0);\n坐标指定的两点间的水平距离为 3.0，垂直距离为 4.0，因此结果应为 5.0。测试方法时知道正确答案很有帮助。\n存根通过编译后，我们就可以开始添加代码了——每次一行。每次修改后都再次编译并运行程序。无论什么时候出现错误，我们都很清楚该检查什么地方：添加的最后一行代码。\nx\n2\nx\n1\ny\n2\ny\n1\ndx\ndy\npublic static double distance\r\n        (double x1, double y1, double x2, double y2) {\r\n    double dx = x2 - x1;\r\n    double dy = y2 - y1;\r\n    System.out.println(\"dx is \" + dx);\r\n    System.out.println(\"dy is \" + dy);\r\n    return 0.0;\r\n}\n脚手架\ndx\ndy\nMath.pow\npublic static double distance\r\n        (double x1, double y1, double x2, double y2) {\r\n    double dx = x2 - x1;\r\n    double dy = y2 - y1;\r\n    double dsquared = dx * dx + dy * dy;\r\n    System.out.println(\"dsquared is \" + dsquared);\r\n    return 0.0;\r\n}\nMath.sqrt\npublic static double distance\r\n        (double x1, double y1, double x2, double y2) {\r\n    double dx = x2 - x1;\r\n    double dy = y2 - y1;\r\n    double dsquared = dx * dx + dy * dy;\r\n    double result = Math.sqrt(dsquared);\r\n    return result;\r\n}\n等编程经验更丰富后，你就可以一次编写并调试多行代码。即便如此，渐进开发也可为你节省大量的时间。\n6.3　方法组合\nxc\nyc\nxp\nyp\ndistance\ndouble radius = distance(xc, yc, xp, yp);\ncalculateArea\ndouble area = calculateArea(radius);\r\nreturn area;\n将这些代码放到一个新的方法中，结果如下：\npublic static double circleArea\r\n        (double xc, double yc, double xp, double yp) {\r\n    double radius = distance(xc, yc, xp, yp);\r\n    double area = calculateArea(radius);\r\n    return area;\r\n}\nradius\narea\npublic static double circleArea\r\n        (double xc, double yc, double xp, double yp) {\r\n    return calculateArea(distance(xc, yc, xp, yp));\r\n}\n功能分解\n6.4　重载\ncircleArea\ncalculateArea\ncalculateArea\ncircleArea\n重载\ncircleArea\ncalculateArea\npublic static double calculateArea\r\n        (double xc, double yc, double xp, double yp) {\r\n    return calculateArea(distance(xc, yc, xp, yp));\r\n}\n请注意，这个方法并不是递归方法。当调用重载的方法时，Java 会根据你提供的实参判断要调用的是哪个版本。如果编写如下代码：\ndouble x = calculateArea(3.0);\ndouble\ncalculateArea\ndouble y = calculateArea(1.0, 2.0, 4.0, 6.0);\ncalculateArea\nprint\nprintln\nMath\nabs\ndoube\nint\n虽然重载是一项很有用的功能，但还是应该慎用。如果在调试方法的一个版本时，不小心调用了另一个版本，你可能会把自己绕进去。\nboolean\nboolean\nboolean\npublic static boolean isSingleDigit(int x) {\r\n    if (x > -10 && x < 10) {\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}\nisSingleDigit\nboolean\nboolean\nreturn\nboolean\nx >- 10 && x < 10\nboolean\nif\npublic static boolean isSingleDigit(int x) {\r\n    return x > -10 && x < 10;\r\n}\nmain\nSystem.out.println(isSingleDigit(2));\r\nboolean bigFlag = !isSingleDigit(17);\ntrue\nbigFlag\ntrue\nboolean\nif (isSingleDigit(z)) {\r\n    System.out.println(\"z is small\");\r\n} else {\r\n    System.out.println(\"z is big\");\r\n}\n像这样的语句几乎都可解读为“如果 z 是个位数，就打印……否则打印……”。\n6.6　Javadoc标签\n我们在 4.9 节中讨论了如何用 /** 编写文档注释。一般而言，最好给每个类和方法都编写文档，这样其他程序员无需阅读代码就能知道它们是做什么的。\n标签\n@param\n@return\n/**\r\n * 检查整数x是否是个位数\r\n *\r\n * @param x 要检查的整数\r\n * @return 如果x是个位数，返回true，否则返回false\r\n */\r\npublic static boolean isSingleDigit(int x) {\n图 6-1 显示了 Javadoc 生成的 HTML 页面。请注意其中的源代码和文档之间的关系。\nisSingleDigit\n@param\nvoid\n@return\n6.7　再谈递归\n图灵完备的\n为了让你了解学过的工具能做哪些事情，我们来看一些方法，这些方法可用于计算以递归方式定义的函数。递归定义引用了当前定义的东西，从这种意义上说，它类似于循环定义。\n当然，真正意义上的循环定义用处不大，请看以下定义。\n递归（recursive）\n用于描述递归的方法。\n如果在字典中看到这个定义，你可能非常恼火。但如果用 Google 搜索 recursion，它将显示 Did you mean: recursion，这是一个只有知道内情的人才懂的玩笑。\nn\n阶乘\nn\n!\n阶乘\n非\nfactorial(0)\n1\nfactorial(n)\nn*factorial(n - 1)\nfactorial(3)\n3*factorial(2)\nfactorial(2)\n2*factorial(1)\nfactorial(1)\n1*factorial(0)\nfactorial(0)\n1\nfactorial(3)\n3*2*1*1\nint\nint\npublic static int factorial(int n) {\r\n    return 0;\r\n}\n接下来需要考虑基线条件。如果提供的实参为 0，则返回 1。\npublic static int factorial(int n) {\r\n    if (n == 0) {\r\n        return 1;\r\n    }\r\n    return 0;\r\n}\nn\nn\npublic static int factorial(int n) {\r\n    if (n == 0) {\r\n        return 1;\r\n    }\r\n    int recurse = factorial(n - 1);\r\n    int result = n * recurse;\r\n    return result;\r\n}\ncountdown\nfactorial\nn\nn\nn\nn\nn\nn\nn\nn\nn\nn\nrecurse\nresult\nn == 0\nfactorial\n6.8　姑且相信\n姑且相信\n假设\nMath.cos\nSystem.out.println\nisSingleDigit\n假定\nn\nn\nn\n当然，假定未编写好的方法能够正确地运行让人觉得很别扭，这正是我们称之为“姑且相信”的原因所在！\n6.9　再举一个例子\n另一个以递归方式定义的常见函数是斐波纳契数列，其定义如下：\n如果将该定义转换为 Java 代码，结果如下：\npublic static int fibonacci(int n) {\r\n    if (n == 1 || n == 2) {\r\n        return 1;\r\n    }\r\n    return fibonacci(n - 1) + fibonacci(n - 2);\r\n}\nn\n6.10　术语表\nvoid\n不返回值的方法。\n值方法\n返回值的方法。\n返回类型\n方法返回的值的类型。\n返回值\n方法调用的结果。\n临时变量\n短期的变量，通常用于调试。\n无用代码\nreturn\n渐进开发\n创建程序的一种流程，每次只编写几行代码，并立即进行编译和测试。\n存根\n未完成的方法的占位符，旨在让类能够通过编译。\n脚手架\n在程序开发期间使用但不包含在最终版本中的代码。\n功能分解\n将复杂的计算分成多个简单的方法，再组合这些方法来执行计算。\n重载\n定义了多个名称相同但形参不同的方法。\n标签\n@\n图灵完备的\n编程语言能够实现任何理论上可行的算法。\n阶乘\n将从 1 到给定整数的所有整数相乘。\n姑且相信\n阅读递归程序的一种方式，假设递归调用可以正确地工作，而不沿执行流程前行。\n6.11　练习\n本章的示例代码位于仓库 ThinkJavaCode 的目录 ch06 中，有关如何下载这个仓库，请参阅前言中的“使用示例代码”一节。做以下的练习前，建议你先编译并运行本章的示例。\n如果你还没有阅读 A.7 节，那么现在正是阅读的好时机。该节介绍了 JUnit——一款测试值方法的有效工具。\n练习6-1\n如果你对某种做法是否合法、不合法的结果是什么存在疑问，让编译器来解答是一种不错的方法。请尝试回答下面的问题。\n(1) 如果调用一个值方法，但不用它返回的结果，即既没有将其赋给变量，也没有将其用于表达式中，结果将如何呢？\nvoid\nSystem.out.println(\"boo!\") + 7\n练习6-2\nisDivisible\nn\nm\nn\nm\ntrue\nfalse\n练习6-3\n给定 3 根棍子，可能能够将它们排列成三角形，也可能不行。例如，如果其中一根棍子长 12 英寸，另外两根都为 1 英寸，那么就无法将 3 根棍子相互相连。给定任意 3 根棍子的长度，可通过下面的简单测试来判断它们能否组成三角形：\n只要其中 1 根棍子的长度大于其他 2 根棍子的总长，它们就无法组成三角形。\nisTriangle\ntrue\nfalse\n练习6-4\na * b + c\n(1) 创建一个程序，并命名为 Multadd.java。\nmultadd\ndouble\na * b + c\nmain\nmultadd\nmultadd\n1.0\n2.0\n3.0\nmain\nmultadd\nexpSum\ndouble\nmultadd\n在这个练习的最后一部分，你需要编写一个方法，这个方法要能调用你编写的另一个方法。在这种情况下，最好先仔细测试要调用的方法，否则你可能面临同时调试两个方法的困境。\n这个练习的目的之一是锻炼你的模式匹配能力——能够看出要解决的问题是通用问题的特例。\n练习6-5\n以下程序的输出是什么？\npublic static void main(String[] args) {\r\n    boolean flag1 = isHoopy(202);\r\n    boolean flag2 = isFrabjuous(202);\r\n    System.out.println(flag1);\r\n    System.out.println(flag2);\r\n    if (flag1 && flag2) {\r\n        System.out.println(\"ping!\");\r\n    }\r\n    if (flag1 || flag2) {\r\n        System.out.println(\"pong!\");\r\n    }\r\n}\r\n\r\npublic static boolean isHoopy(int x) {\r\n    boolean hoopyFlag;\r\n    if (x % 2 == 0) {\r\n        hoopyFlag = true;\r\n    } else {\r\n        hoopyFlag = false;\r\n    }\r\n    return hoopyFlag;\r\n}\r\n\r\npublic static boolean isFrabjuous(int x) {\r\n    boolean frabjuousFlag;\r\n    if (x > 0) {\r\n        frabjuousFlag = true;\r\n    } else {\r\n        frabjuousFlag = false;\r\n    }\r\n    return frabjuousFlag;\r\n}\n这个练习旨在确保你明白逻辑运算符和值方法的执行流程。\n练习6-6\n在这个练习中，你可以用栈图来帮助理解下述递归程序的执行流程：\npublic static void main(String[] args) {\r\n    System.out.println(prod(1, 4));\r\n}\r\n\r\npublic static int prod(int m, int n) {\r\n    if (m == n) {\r\n        return n;\r\n    } else {\r\n        int recurse = prod(m, n - 1);\r\n        int result = n * recurse;\r\n        return result;\r\n    }\r\n}\nprod\n(2) 这个程序的输出是什么？（先尝试用纸和笔来回答这个问题，再通过运行代码来检查答案。）\nprod\nprod\nrecurse\nresult\n提示\nelse\n练习6-7\noddSum\nn\nn\noddSum\nn\n练习6-8\nm\nn\nack\nint\nack\nmain\nm\nn\n练习6-9\npower\ndouble\nx\nint\nn\nn\n提示\nn\nx\nx\nn\nn\nn\nx\nn\n2\n第 7 章　循环\n计算机常用于自动完成重复的任务。重复执行任务而不出错是计算机的强项，也是人类的弱项。\n迭代\ncountdown\nfactorial\nwhile\nfor\nwhile\nwhile\ncountdown\npublic static void countdown(int n) {\r\n    while (n > 0) {\r\n        System.out.println(n);\r\n        n = n - 1;\r\n    }\r\n    System.out.println(\"Blastoff!\");\r\n}\nwhile\nn\nn\nn\n循环体\nwhile\ntrue\nfalse\nfalse\ntrue\n循环\nfalse\n无限循环\ncountdown\nn\nfalse\npublic static void sequence(int n) {\r\n    while (n != 1) {\r\n        System.out.println(n);\r\n        if (n % 2 == 0) {         // n为偶数\r\n            n = n / 2;\r\n        } else {                  // n为奇数\r\n            n = n * 3 + 1;\r\n        }\r\n    }\r\n}\nn\nn\nsequence\nn\nn\nn\nn\nn\nn\nn\nhttps://en.wikipedia.org/wiki/Collatz_conjecture\n7.2　生成表格\n循环非常适合用于生成和显示表格型数据。计算机还未面世时，人们必须手工计算对数、正弦、余弦等常见的数学函数。为简化这种工作，有些书提供了表格，让你能够查找各种函数的值，但手工创建这样的表格既缓慢又繁琐，并且结果常常错误百出。\n计算机面世后，大家最初的反应之一是：太好了，可用计算机来生成这样的表格了，并确保它们没有任何错误。事实证明确实如此，但人们的目光还是太短浅了，不久后，计算机就非常普及，这些打印出来的表格也就被淘汰了。\nhttps://en.wikipedia.org/wiki/Pentium_FDIV_bug\n虽然“对数表”不再像以前那么有用了，但它依然是迭代的典范。下面的循环显示了一个表格，其中左边一列是一系列值，而右边一列是这些值的对数：\nint i = 1;\r\nwhile (i < 10) {\r\n    double x = (double) i;\r\n    System.out.println(x + \" \" + Math.log(x));\r\n    i = i + 1;\r\n}\n这个程序的输出如下：\n1.0   0.0\r\n2.0   0.6931471805599453\r\n3.0   1.0986122886681098\r\n4.0   1.3862943611198906\r\n5.0   1.6094379124341003\r\n6.0   1.791759469228055\r\n7.0   1.9459101490553132\r\n8.0   2.0794415416798357\r\n9.0   2.1972245773362196\nMath.log\n我们可将前面的循环修改成下面这样：\nint i = 1;\r\nwhile (i < 10) {\r\n    double x = (double) i;\r\n    System.out.println(x + \" \" + Math.log(x) / Math.log(2));\r\n    i = i + 1;\r\n}\n结果如下：\n1.0   0.0\r\n2.0   1.0\r\n3.0   1.5849625007211563\r\n4.0   2.0\r\n5.0   2.321928094887362\r\n6.0   2.584962500721156\r\n7.0   2.807354922057604\r\n8.0   3.0\r\n9.0   3.1699250014423126\nx\nx\nfinal double LOG2 = Math.log(2);\r\nint i = 1;\r\nwhile (i < 100) {\r\n    double x = (double) i;\r\n    System.out.println(x + \" \" + Math.log(x) / LOG2);\r\n    i = i * 2;\r\n}\nMath.log(2)\nfinal\nx\n1.0    0.0\r\n2.0    1.0\r\n4.0    2.0\r\n8.0    3.0\r\n16.0   4.0\r\n32.0   5.0\r\n64.0   6.0\n这个表格列出了 2 的幂及其以 2 为底的对数。虽然对数表已毫无用处，但对计算机科学家来说，知道 2 的幂大有裨益！\n7.3　封装和泛化\n程序开发\nmain\n(2) 如果能够正确运行，就将它们封装到一个方法中，并再次测试。\n(3) 如果这个方法没问题，就将其中的字面量替换为变量和形参。\n封装\n泛化\n为演示这种流程，我们将开发几个显示乘法表的方法。下面的循环显示 2 的幂，这些幂值都显示在一行中：\nint i = 1;\r\nwhile (i <= 6) {\r\n    System.out.printf(\"%4d\", 2 * i);\r\n    i = i + 1;\r\n}\r\nSystem.out.println();\ni\n循环变量\ni\ni\n2 * i\nSystem.out.printf\nprintln\n因此，上述代码的输出如下：\n2  4  6  8  10  12\n下一步是将这些代码“封装”到一个新方法中。这个方法类似于下面这样：\npublic static void printRow() {\r\n    int i = 1;\r\n    while (i <= 6) {\r\n        System.out.printf(\"%4d\", 2 * i);\r\n        i = i + 1;\r\n    }\r\n    System.out.println();\r\n}\nn\n2\npublic static void printRow(int n) {\r\n    int i = 1;\r\n    while (i <= 6) {\r\n        System.out.printf(\"%4d\", n * i);\r\n        i = i + 1;\r\n    }\r\n    System.out.println();\r\n}\n如果用实参 2 调用这个方法，得到的输出将与前面相同。使用实参 3 调用这个方法时，输出如下：\n3   6   9  12  15  18\n下面是用实参 4 调用这个方法得到的输出：\n4  8  12  16  20  24\nprintRow\nint i = 1;\r\nwhile (i <= 6) {\r\n    printRow(i);\r\n    i = i + 1;\r\n}\n输出类似于以下这样：\n1   2   3   4   5   6\r\n2   4   6   8  10  12\r\n3   6   9  12  15  18\r\n4   8  12  16  20  24\r\n5  10  15  20  25  30\r\n6  12  18  24  30  36\nprintRow\n%4d\n最后，我们将第二个循环封装到一个方法中：\npublic static void printTable() {\r\n    int i = 1;\r\n    while (i <= 6) {\r\n        printRow(i);\r\n        i = i + 1;\r\n    }\r\n}\n编程时面临的挑战之一是如何将程序划分成多个方法，对初学者来说尤其如此。封装和泛化流程能够让你一边编程一边设计。\n7.4　再谈泛化\nprintTable\n6\npublic static void printTable(int rows) {\r\n    int i = 1;\r\n    while (i <= rows) {\r\n        printRow(i);\r\n        i = i + 1;\r\n    }\r\n}\n下面是用实参 7 调用这个方法得到的输出：\n1   2   3   4   5   6\r\n2   4   6   8  10  12\r\n3   6   9  12  15  18\r\n4   8  12  16  20  24\r\n5  10  15  20  25  30\r\n6  12  18  24  30  36\r\n7  14  21  28  35  42\nprintRow\npublic static void printRow(int n, int cols) {\r\n    int i = 1;\r\n    while (i <= cols) {\r\n        System.out.printf(\"%4d\", n * i);\r\n        i = i + 1;\r\n    }\r\n    System.out.println();\r\n}\nprintRow\nn\ncols\nn\ncols\nprintRow\nprintTable\nprintRow\npublic static void printTable(int rows) {\r\n    int i = 1;\r\n    while (i <= rows) {\r\n        printRow(i, rows);\r\n        i = i + 1;\r\n    }\r\n}\nrows\nprintRow\nprintRow\ncols\n1   2   3   4   5   6   7\r\n2   4   6   8  10  12  14\r\n3   6   9  12  15  18  21\r\n4   8  12  16  20  24  28\r\n5  10  15  20  25  30  35\r\n6  12  18  24  30  36  42\r\n7  14  21  28  35  42  49\nab\nba\nprintTable\nprintRow(i, i);\n这使得每行的长度与其行号相同，结果是一个三角形乘法表：\n1\r\n2   4\r\n3   6   9\r\n4   8  12  16\r\n5  10  15  20  25\r\n6  12  18  24  30  36\r\n7  14  21  28  35  42  49\n泛化可让代码更通用、更易于重用甚至更容易编写。\nfor\nfor\nprintTable\npublic static void printTable(int rows) {\r\n    for (int i = 1; i <= rows; i = i + 1) {\r\n        printRow(i, rows);\r\n    }\r\n}\nfor\n初始化部分\n条件部分\nfalse\n更新部分\nfor\nwhile\nfor\nfor\nfor\nprintRow\npublic static void printRow(int n, int cols) {\r\n    for (int i = 1; i <= cols; i = i + 1) {\r\n        System.out.printf(\"%4d\", n * i);\r\n    }\r\n    System.out.println(i); // 编译错误\r\n}\ni\npublic static void printRow(int n, int cols) {\r\n    int i;\r\n    for (i = 1; i <= cols; i = i + 1) {\r\n        System.out.printf(\"%4d\", n * i);\r\n    }\r\n    System.out.println(i);\r\n}\nfor\ni = i + 1\n递增\ni = i + 1\n--\n递减\ni = i - 1\n1\n+=\n-=\ni += 2\ni\n2\ndo-while\nwhile\nfor\n先测试循环\n后测试循环\ndo-while\nreturn\ndo-while\nScanner in = new Scanner(System.in);\r\nboolean okay;\r\ndo {\r\n    System.out.print(\"Enter a number: \");\r\n    if (in.hasNextDouble()) {\r\n        okay = true;\r\n    } else {\r\n        okay = false;\r\n        String word = in.next();\r\n        System.err.println(word + \" is not a number\");\r\n    }\r\n} while (!okay);\r\ndouble x = in.nextDouble();\n这些代码看似很复杂，但其实只包含三个步骤。\n(1) 显示提示。\n(2) 检查输入。如果无效就显示错误消息并重新开始。\n(3) 读取输入。\nokay\nhasNextDoublec()\nfalse\nnext()\nSystem.err\nhasNextDouble()\ntrue\nbreak\ncontinue\nif-else\nbreak\nbreak\nScanner in = new Scanner(System.in);\r\nwhile (true) {\r\n    System.out.print(\"Enter a number: \");\r\n    if (in.hasNextDouble()) {\r\n        break;\r\n    }\r\n    String word = in.next();\r\n    System.err.println(word + \" is not a number\");\r\n}\r\ndouble x = in.nextDouble();\nwhile\ntrue\nbreak\nbreak\ncontinue\ncontinue\nScanner in = new Scanner(System.in);\r\nint x = -1;\r\nint sum = 0;\r\nwhile (x != 0) {\r\n    x = in.nextInt();\r\n    if (x <= 0) {\r\n        continue;\r\n    }\r\n    System.out.println(\"Adding \" + x);\r\n    sum += x;\r\n}\nbreak\ncontinue\n7.8　术语表\n迭代\n反复地执行一系列语句。\n循环\n反复地执行一系列语句的语句。\n循环体\n循环中的语句。\n无限循环\ntrue\n程序开发\n程序编写流程，至此，我们介绍了两种程序开发流程——渐进开发以及封装和泛化。\n封装\n将一系列语句放在方法中。\n泛化\n将具体的信息（如常量值）替换为通用信息（如变量或形参）。\n循环变量\n为控制循环而被初始化、测试和修改的变量。\n递增\n增大变量的值。\n递减\n减小变量的值。\n先测试循环\n在每次迭代前检查条件的循环。\n后测试循环\n在每次迭代后检查条件的循环。\n7.9　练习\n本章的示例代码位于仓库 ThinkJavaCode 的目录 ch07 中，有关如何下载这个仓库，请参阅前言中的“使用示例代码”一节。做以下的练习前，建议你先编译并运行本章的示例。\n如果你还没有阅读 A.5 节，那么现在正是阅读的好时机。该节介绍了 Checkstyle——一款分析源代码众多方面的工具。\n练习7-1\n请看下面的方法，并思考问题：\npublic static void main(String[] args) {\r\n    loop(10);\r\n}\r\n\r\npublic static void loop(int n) {\r\n    int i = n;\r\n    while (i > 1) {\r\n        System.out.println(i);\r\n        if (i % 2 == 0) {\r\n            i = i / 2;\r\n        } else {\r\n            i = i + 1;\r\n        }\r\n    }\r\n}\ni\nn\n(2) 这个程序的输出是什么？\nn\n练习7-2\na\nx\n0\nx\n0\nx\n1\nx\n1\nx\n2\nx\n2\nx\n3\nsquareRoot\ndouble\nMath.sqrt\na\nMath.abs\n练习7-3\ndouble\nx\nn\nn\n练习7-4\nfactorial\n练习7-5\nx\ni\ni\ni\nmyexp\nx\nn\nn\nx\nfactorial\nx\ni\nMath.pow\nfactorial\ncheck\nx\nx\nmyexp(x)\nMath.exp(x)\n1.0    2.708333333333333    2.718281828459045\n\"\\t\"\ncheck\nmyexp\nx\nmain\ncheck\nx\nmain\ncheck\n练习7-6\nx\n2\ni\ni\nx\ni\ni\ngauss\nx\nn\nn\nfactorial\npow\n第 8 章　数组\n到目前为止，我们使用的变量只能存储单个值，如数字或字符串。你将在本章中学习如何用单个变量存储多个同类型的值。这种语言功能让你能够编写程序以便操作大量的数据。\n8.1　创建数组\n数组\n元素\nint\ndouble\n数组类型\ncounts\nvalues\nint\ndouble\nint[] counts;\r\ndouble[] values;\nnew\ncounts = new int[4];\r\nvalues = new double[size];\ncount\nvalues\ndouble\nvalues\nsize\n当然，也可在同一个代码行内声明变量并创建数组：\nint[] counts = new int[4];\r\ndouble[] values = new double[size];\nNegativeArraySizeException\n8.2　访问元素\nint\ncounts\nint\ncounts\n引用\n数组\n变量\ncounts\ncounts\n索引\n[]\nSystem.out.println(\"The zeroth element is \" + counts[0]);\n[]\ncounts[0] = 7;\r\ncounts[1] = counts[0] * 2;\r\ncounts[2]++;\r\ncounts[3] -= 60;\n图 8-2 显示了执行这些语句的结果。\n图 8-2：执行多条赋值语句后的状态图\nint\nint i = 0;\r\nwhile (i < 4) {\r\n    System.out.println(counts[i]);\r\n    i++;\r\n}\nwhile\ni\ni\ni\ni\nfor\nfor (int i = 0; i < 4; i++) {\r\n    System.out.println(counts[i]);\r\n}\ncounts\nArrayIndexOutOfBoundsException\n8.3　显示数组\nprintln\nprintln\nint[] a = {1, 2, 3, 4};\r\nSystem.out.println(a);\n遗憾的是，输出类似于以下这样：\n[I@bf3f7e0\nI\npublic static void printArray(int[] a) {\r\n    System.out.print(\"{\" + a[0]);\r\n    for (int i = 1; i < a.length; i++) {\r\n        System.out.print(\", \" + a[i]);\r\n    }\r\n    System.out.println(\"}\");\r\n}\n给定前面的数组，该方法的输出如下：\n{1, 2, 3, 4}\njava.util.Arrays\ntoString\nSystem.out.println(Arrays.toString(a));\n输出如下：\n[1, 2, 3, 4]\njava.util.Arrays\nprintArray\n8.4　复制数组\n引用\ndouble[] a = new double[3];\r\ndouble[] b = a;\ndouble\n图 8-3：显示两个变量指向同一个数组的状态图\na[0] = 17.0\nb[0]\n17.0\na\nb\n别名\n如果要复制数组本身而不是指向它的引用，那么就必须创建一个新的数组，并将旧数组中的每个元素都复制到新数组中，如下所示：\ndouble[] b = new double[3];\r\nfor (int i = 0; i < 3; i++) {\r\n    b[i] = a[i];\r\n}\njava.util.Arrays\ncopyOf\ndouble[] b = Arrays.copyOf(a, 3);\n其中的第二个参数用来指定要复制的元素个数，因此你也可以只复制数组的一部分。\n8.5　数组的长度\na.length\ndouble[] b = new double[a.length];\r\nfor (int i = 0; i < a.length; i++) {\r\n    b[i] = a[i];\r\n}\nlength\na.length\ni\na.length-1\ni\na.length\na[a.length]\na.length\nArrays.copyOf\ndouble[] b = Arrays.copyOf(a, a.length);\n8.6　数组遍历\ndouble\nfor (int i = 0; i < a.length; i++) {\r\n    a[i] = Math.pow(a[i], 2.0);\r\n}\n遍历\n查找\nint\nint\nint\npublic static int search(double[] a, double target) {\r\n    for (int i = 0; i < a.length; i++) {\r\n        if (a[i] == target) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}\n-1\n归并\ndouble\npublic static int sum(double[] a) {\r\n    double total = 0.0;\r\n    for (int i = 0; i < a.length; i++) {\r\n        total += a[i];\r\n    }\r\n    return total;\r\n}\ntotal\ntotal\ntotal\n累加器\n8.7　随机数\n确定的\n不确定的\n伪随机数\njava.util.Random\nnextInt\nint\nn\n0\nn-1\nnextInt\nint\npublic static int[] randomArray(int size) {\r\n    Random random = new Random();\r\n    int[] a = new int[size];\r\n    for (int i = 0; i < a.length; i++) {\r\n        a[i] = random.nextInt(100);\r\n    }\r\n    return a;\r\n}\nprintArray\nint numValues = 8;\r\nint[] array = randomArray(numValues);\r\nprintArray(array);\n输出类似于以下这样：\n{15, 62, 46, 74, 67, 52, 51, 10}\n运行这些代码生成的随机数可能与这里显示的不同。\n8.8　遍历和计数\n直方图\n就考试成绩而言，我们可能需要 10 个计数器，用来指出考试成绩为 90~100 分、80~90 分等的学生分别有多少。为此，我们可以遍历数组，并计算值在给定范围内的元素数。\nlow\nhigh\nlow\nhigh\npublic static int inRange(int[] a, int low, int high) {\r\n    int count = 0;\r\n    for (int i = 0; i < a.length; i++) {\r\n        if (a[i] >= low && a[i] < high) {\r\n            count++;\r\n        }\r\n    }\r\n    return count;\r\n}\nlow\n>=\nhigh\n<\n现在可以计算每个范围内的考试成绩数了：\nint[] scores = randomArray(30);\r\nint a = inRange(scores, 90, 100);\r\nint b = inRange(scores, 80, 90);\r\nint c = inRange(scores, 70, 80);\r\nint d = inRange(scores, 60, 70);\r\nint f = inRange(scores, 0, 60);\n8.9　生成直方图\n前面的代码有些重复，但只要范围数不多，这是完全可以接受的。然而，如果我们要计算每个分数出现的次数，就必须编写 100 行代码：\nint count0 = inRange(scores, 0, 1);\r\nint count1 = inRange(scores, 1, 2);\r\nint count2 = inRange(scores, 2, 3);\r\n...\r\nint count99 = inRange(scores, 99, 100);\n我们需要存储 100 个计数器，最好还能用索引来访问计数器。换言之，我们需要一个数组！\ninRange\nint[] counts = new int[100];\r\nfor (int i = 0; i < counts.length; i++) {\r\n    counts[i] = inRange(scores, i, i + 1);\r\n}\ni\ncounts\ninRange\ninRange\n一次\nint[] counts = new int[100];\r\nfor (int i = 0; i < scores.length; i++) {\r\n    int index = scores[i];\r\n    counts[index]++;\r\n}\nscores\ncounts\nscores\nfor\nfor\nfor (int i = 0; i < values.length; i++) {\r\n    System.out.println(values[i]);\r\n}\n对于这个循环，我们可将其重写成下面这样：\nfor (int value : values) {\r\n    System.out.println(value);\r\n}\n改进的\nfor\n循环\nvalues\nvalue\n通过使用改进的 for 循环并删除临时变量，我们可用更简洁的方式编写前一节生成直方图的代码：\nint[] counts = new int[100];\r\nfor (int score : scores) {\r\n    counts[score]++;\r\n}\nfor\nfor\n8.11　术语表\n数组\n一系列的值，所有值的类型都相同，每个值都由一个索引标识。\n元素\n[]\n索引\nint\nint\n引用\n标识另一个值（如数组）的值；在状态图中用箭头表示。\n别名\n与另一个变量指向同一个对象的变量。\n遍历\n通过循环访问数组（或其他集合）中的每个元素。\n查找\n一种在数组中查找特定元素的遍历模式。\n归并\n一种将数组的所有元素合并为单个值的遍历模式。\n累加器\n在遍历期存储累积结果的变量。\n确定的\n每次运行时结果都相同的程序。\n不确定的\n每次运行时结果都不同的程序，即便每次运行时输入相同亦如此。\n伪随机数\n一系列看似随机，但实际是用确定性计算得到的数字。\n直方图\nint\nfor\n另一种遍历数组元素（值）的语法。\n8.12　练习\n本章的示例代码位于仓库 ThinkJavaCode 的目录 ch08 中，有关如何下载这个仓库，请参阅前言中的“使用示例代码”一节。做以下的练习前，建议你先编译并运行本章的示例。\n练习8-1\n这个练习旨在用本章的一些示例来练习封装。\npowArray\ndouble\na\na\nhistogram\nint\n练习8-2\n这个练习旨在让你阅读代码，并识别本章介绍过的遍历模式。下面的方法难以阅读，因为它们给变量指定的不是有意义的名称，而是水果名。\npublic static int banana(int[] a) {\r\n    int kiwi = 1;\r\n    int i = 0;\r\n    while (i < a.length) {\r\n        kiwi = kiwi * a[i];\r\n        i++;\r\n    }\r\n    return kiwi;\r\n}\r\n\r\npublic static int grapefruit(int[] a, int grape) {\r\n    for (int i = 0; i < a.length; i++) {\r\n        if (a[i] == grape) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}\r\n\r\npublic static int pineapple(int[] a, int apple) {\r\n    int pear = 0;\r\n    for (int pine: a) {\r\n        if (pine == apple) {\r\n            pear++;\r\n        }\r\n    }\r\n    return pear;\r\n}\n用一句话描述每个方法的功能，无需涉及其相关的工作原理细节。指出每个变量扮演的角色。\n练习8-3\nmus\nmus\npublic static int[] make(int n) {\r\n    int[] a = new int[n];\r\n    for (int i = 0; i < n; i++) {\r\n        a[i] = i + 1;\r\n    }\r\n    return a;\r\n}\r\n\r\npublic static void dub(int[] jub) {\r\n    for (int i = 0; i < jub.length; i++) {\r\n        jub[i] *= 2;\r\n    }\r\n}\r\n\r\npublic static int mus(int[] zoo) {\r\n    int fus = 0;\r\n    for (int i = 0; i < zoo.length; i++) {\r\n        fus += zoo[i];\r\n    }\r\n    return fus;\r\n}\r\n\r\npublic static void main(String[] args) {\r\n    int[] bob = make(5);\r\n    dub(bob);\r\n    System.out.println(mus(bob));\r\n}\n练习8-4\nindexOfMax\nint\nfor\n练习8-5\nhttps://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\nsieve\nint\nn\nboolean\n0\nn-1\n练习8-6\nareFactors\nint\nn\nint\nn\nn\ntrue\n练习8-7\narePrimeFactors\nint\nn\nint\nn\ntrue\n练习8-8\n本章介绍的很多数组遍历模式也可以用递归方式来实现。这种做法虽然不常见，却是一个很有用的练习。\nmaxInRange\nint\nlowIndex\nhighIndex\nlowIndex==highIndex\n如果这个范围包含多个元素，我们可将这个范围分成两部分，并在两部分中分别找出最大的元素，再在这两个最大的元素中找出更大的那个。\nmaxInRange\ndouble max = maxInRange(a, 0, a.length - 1);\nmax\nmaxInRange\n第 9 章　字符串\n对象\nScanner\nSystem.out\nSystem.in\n字符串也是对象。它们包含字符，并提供了操作字符数据的方法。本章将探索其中几个方法。\nint\ndouble\nboolean\n基本类型\n9.1　字符\ncharAt\nchar\n基本类型\nString fruit = \"banana\";\r\nchar letter = fruit.charAt(0);\n0\nletter\nb\n字符的工作原理与前面介绍过的其他基本类型相似，可用关系运算符来比较它们：\nif (letter == 'a') {\r\n    System.out.println('?');\r\n}\n'a'\n'\\t'\n递增和递减运算符也可用于字符，因此下面的循环显示字母表中的所有字母：\nSystem.out.print(\"Roman alphabet: \");\r\nfor (char c = 'A'; c <= 'Z'; c++) {\r\n    System.out.print(c);\r\n}\r\nSystem.out.println();\nhttp://unicode.org/\n在 Unicode 中，每个字符由一个字符编码表示，我们可将字符编码视为整数。大写的希腊字母的字符编码为 913~937，因此我们可以像下面这样显示希腊字母表：\nSystem.out.print(\"Greek alphabet: \");\r\nfor (int i = 913; i <= 937; i++) {\r\n    System.out.print((char) i);\r\n}\r\nSystem.out.println();\n这个示例使用了类型转换将指定范围内的每个整数都转换为相应的字符。\n9.2　字符串是不可修改的\ntoUpperCase\ntoLowerCase\n不可修改的\ntoUpperCase\nString name = \"Alan Turing\";\r\nString upperName = name.toUpperCase();\nupperName\n\"ALAN TURING\"\nname\n\"Alan Turing\"\nreplace\n\"Computer Science\"\n\"CS\"\nString text = \"Computer Science is fun!\";\r\ntext = text.replace(\"Computer Science\", \"CS\");\ntext.replace\ntext.replace\n\"CS is fun!\"\ntext\ntext.replace\n9.3　字符串遍历\nfruit\nfor (int i = 0; i < fruit.length(); i++) {\r\n    char letter = fruit.charAt(i);\r\n    System.out.println(letter);\r\n}\nlength\n()\ni<fruit.length()\ni\nfalse\nfor\nfor\nfor (char letter : fruit.toCharArray()) {\r\n    System.out.println(letter);\r\n}\n为获取字符串的最后一个字符，你可能试图像下面这样做：\nint length = fruit.length();\r\nchar last = fruit.charAt(length);     // 不对！\ncharAt\nStringIndexOutOfBoundsException\n\"banana\"\nlength\nint length = fruit.length();\r\nchar last = fruit.charAt(length - 1); // 正确\n很多字符串遍历操作涉及读取一个字符串并创建另一个字符串。例如，要想反转字符串，可按从后到前的顺序将字符依次加入到另一个字符串中：\npublic static String reverse(String s) {\r\n    String r = \"\";\r\n    for (int i = s.length() - 1; i >= 0; i--) {\r\n        r = r + s.charAt(i);\r\n    }\r\n    return r;\r\n}\nr\n\"\"\n空字符串\ns\nr\nr\ns\nreverse(\"banana\")\n\"ananab\"\n9.4　子串\nsubstring\nfruit.substring(0)\n\"banana\"\nfruit.substring(2)\n\"nana\"\nfruit.substring(6)\n\"\"\nsubstring\nsubstring\n图 9-1：包含 6 个字符的字符串状态图\nsubstring\nsubstring\nsubstring\nfruit.substring(0, 3)\n\"ban\"\nfruit.substring(2, 5)\n\"nan\"\nfruit.substring(6, 6)\n\"\"\nsubstring\ni\nlen\nfruit.substring(i, i+len)\nindexOf\nindexOf\nString fruit = \"banana\";\r\nint index = fruit.indexOf('a');\n'a'\nindexOf\n第一次\nindexOf\nint index = fruit.indexOf('a', 2);\n'n'\n'a'\n'a'\nfruit.indexOf('a', 5)\n5\nindexOf\n-1\nindexOf\nfruit.indexOf(\"nan\")\n2\n9.6　字符串比较\n==\n!=\nString name1 = \"Alan Turing\";\r\nString name2 = \"Ada Lovelace\";\r\nif (name1 == name2) {                 // 不对!\r\n    System.out.println(\"The names are the same.\");\r\n}\n==\nfalse\nequals\nif (name1.equals(name2)) {\r\n    System.out.println(\"The names are the same.\");\r\n}\nname1\nequals\nname2\nequals\ntrue\nfalse\ncompareTo\nint diff = name1.compareTo(name2);\r\nif (diff == 0) {\r\n    System.out.println(\"The names are the same.\");\r\n} else if (diff < 0) {\r\n    System.out.println(\"name1 comes before name2.\");\r\n} else if (diff > 0) {\r\n    System.out.println(\"name2 comes before name1.\");\r\n}\ncompareTo\ncompareTo\n8\n\"Ada\"\n\"Alan\"\nequals\ncompareTo\n\"Ada\"\n\"ada\"\n9.7　设置字符串的格式\nprintf\npublic static String timeString(int hour, int minute) {\r\n    String ampm;\r\n    if (hour < 12) {\r\n        ampm = \"AM\";\r\n        if (hour == 0) {\r\n            hour = 12; // 午夜\r\n        }\r\n    } else {\r\n        ampm = \"PM\";\r\n        hour = hour - 12;\r\n    }\r\n    return String.format(\"%02d:%02d %s\", hour, minute, ampm);\r\n}\nString.format\nSystem.out.printf\nSystem.out.printf\nString.format\n%02d\ntimeString(19, 5)\n\"07:05 PM\"\n9.8　包装类\nint\ndouble\nchar\nint\nequals\nint i = 5;\r\nSystem.out.println(i.equals(5));  // 编译错误\n包装类\nchar\nCharacte\nint\nInteger\nBoolean\nLong\nDouble\njava.lang\nMIN_VALUE\nMAX_VALUE\nInteger.MIN_VALUE\n-2147483648\nInteger.MAX_VALUE\n2147483647\nInteger.parseInt\nString str = \"12345\";\r\nint num = Integer.parseInt(str);\n分析\nDouble.parseDouble\nBoolean.parseBoolean\ntoString\nint num = 12345;\r\nString str = Integer.toString(num);\n\"12345\"\n9.9　命令行实参\nmain\nargs\nargs\nSystem.in\npublic class Max {\r\n    public static void main(String[] args) {\r\n        System.out.println(Arrays.toString(args));\r\n    }\r\n}\n要运行这个程序，可在命令行中执行如下命令：\njava Max\nargs\n空数组\n[]\nmain\njava Max 10 -3 55 0 14\n输出如下：\n[10, -3, 55, 0, 14]\nargs\nfor\nInteger\nint max = Integer.MIN_VALUE;\r\nfor (String arg : args) {\r\n    int value = Integer.parseInt(arg);\r\n    if (value > max) {\r\n        max = value;\r\n    }\r\n}\r\nSystem.out.println(\"The max is \" + max);\nmax\nint\nint\nargs\nMIN_VALUE\n9.10　术语表\n对象\n一系列相关的数据以及一组操作这些数据的方法。\n基本类型\n存储单个值且没有提供任何方法的数据类型。\nUnicode\n字符编码的一种标准，涵盖全球大部分语言中的字符。\n不可修改的\n一旦创建就不能修改的对象。字符串就被设计成不可修改。\n空字符串\n\"\"\n包装类\njava.lang\n分析\n读取字符串并对其进行解读或转换。\n空数组\n不包含任何元素且长度为零的数组。\n9.11　练习\n本章的示例代码位于仓库 ThinkJavaCode 的目录 ch09 中，有关如何下载这个仓库，请参阅前言中的“使用示例代码”一节。做以下的练习前，建议你先编译并运行本章的示例。\n练习9-1\n这个练习旨在探索 Java 类型，并补充本章前面未涉及的一些细节。\nmain\n+\nchar\n+\nboolean\nchar\nint\ndouble\nstring\nboolean\nchar\nint\ndouble\nstring\n(3) 想想 Java 的设计者在填写这个表格时作出的一些选择。在这个表格中，有多少项因为别无选择而无法避免。又有多少项原本有同样充分理由的可能性，但 Java 的设计者只是随便选择了其中的一个。哪些项存在严重的问题？\nx++\nx = x + 1\nx\nchar\nx++\nx = x + 1\n\"\"\n\"\"+5\nint\ndouble\n练习9-2\nletterHist\n练习9-3\n这个练习旨在复习封装和泛化（参见 7.3 节）。下面的代码片段遍历了一个字符串，并检查了它包含的左括号数和右括号数是否相等：\nString s = \"((3 + 7) * 2)\";\r\nint count = 0;\r\n\r\nfor (int i = 0; i < s.length(); i++) {\r\n    char c = s.charAt(i);\r\n    if (c == '(') {\r\n        count++;\r\n    } else if (c == ')') {\r\n        count--;\r\n    }\r\n}\r\n\r\nSystem.out.println(count);\ncount\n(2) 泛化这些代码使其适用于任何字符串，然后还能如何进一步泛化呢？\n(3) 用多个字符串测试编写的方法，包括左右括号数相等和不等的字符串。\n练习9-4\n创建一个名为 Recurse.java 的程序，并在其中输入以下方法：\n/**\r\n * 返回给定字符串中的第一个字符。\r\n */\r\npublic static char first(String s) {\r\n    return s.charAt(0);\r\n}\r\n\r\n/**\r\n * 返回给定字符串中除第一个字符外的其他所有字符。\r\n */\r\npublic static String rest(String s) {\r\n    return s.substring(1);\r\n}\r\n\r\n/**\r\n * 返回给定字符串中除第一个和最后一个字符外的其他所有字符。\r\n */\r\npublic static String middle(String s) {\r\n    return s.substring(1, s.length() - 1);\r\n}\r\n\r\n/**\r\n * 返回给定字符串的长度。\r\n */\r\npublic static int length(String s) {\r\n    return s.length();\r\n}\nmain\nprintString\nvoid\nprintBackward\nprintString\nreverseString\nString backwards = reverseString(\"coffee\");\r\nSystem.out.println(backwards);\n其输出应为：\neeffoc\n(5) 回文指的是顺着读和倒着读一样的单词，如 otto 和 palindromeemordnilap。一种判断单词是否为回文的方式如下：\n只包含一个字母的单词是回文；单词包含两个字母时，如果这两个字母相同，那么这个单词是回文；对于其他的单词，如果第一个字母和最后一个字母相同，且余下的部分为回文，则这个单词为回文。\nisPalindrome\nboolean\n练习9-5\n如果一个单词包含的字母是按字母表顺序排列的，那么这个单词就是 abecedarian 单词。例如，下面列出了所有按字母顺序排列的含 6 个字母的英语单词：\nabdest, acknow, acorsy, adempt, adipsy, agnosy, befist, behint, beknow, bijoux, biopsy,cestuy, chintz, deflux, dehors, dehort, deinos, diluvy, dimpsy\nisAbecedarian\nboolean\n练习9-6\n如果一个单词包含的每个字母都刚好出现两次，那么它就是 doubloon 单词。下面是字典中的一些 doubloon 单词：\nAbba, Anna, appall, appearer, appeases, arraigning, beriberi, bilabial, boob, Caucasus, coco, Dada, deed, Emmett, Hannah, horseshoer, intestines, Isis, mama, Mimi, murmur, noon, Otto, papa, peep, reappear, redder, sees, Shanghaiings, Toto\nisDoubloon\ntoLowerCase\n练习9-7\n如果两个单词包含的字母相同，且其中的每个字母出现的次数也相同，那么这两个单词就是重组词。例如，单词 stop 是 pots 的重组词，而 allen downey 是 well annoyed 的重组词。\n请编写一个方法，让它接受两个字符串，并检查它们是否为重组词。\n练习9-8\n在拼字游戏 Scrabble 中，每个玩家都有一组字母卡片，玩家需要用这些卡片拼出单词。其中的计分系统非常复杂，但一般而言，拼出的单词越长，得分越高。\n\"quijibo\"\n\"jib\"\ncanSpell\n第 10 章　对象\nString\ncharAt\nsubstring\nJava 是一种“面向对象”的语言，这意味着它用对象来表示数据并提供与数据相关的方法。这种组织程序的方式是一种功能强大的设计理念，我们将在本书余下的篇幅中简单地介绍。\nPoint\nRectangle\nPoint\njava.awt\nPoint\nx\ny\nx\ny\nPoint\nimport java.awt.Point;\nPoint\nnew\nPoint blank;\r\nblank = new Point(3, 4);\nblank\nPoint\nPoint\nnew\n引用\nblank\nPoint\nPoint\nblank\nblank\nx\ny\n10.2　属性\n属性\n句点表示法\nint x = blank.x;\nblank.x\nblank\nx\nx\nx\nx\n哪个\n可以在表达式中使用句点表示法，如下所示：\nSystem.out.println(blank.x + \", \" + blank.y);\r\nint sum = blank.x * blank.x + blank.y * blank.y;\n3, 4\n25\n10.3　将对象用作参数\n可像通常那样将对象作为参数进行传递，例如：\npublic static void printPoint(Point p) {\r\n    System.out.println(\"(\" + p.x + \", \" + p.y + \")\");\r\n}\nPoint\nprintPoint(blank)\n(3, 4)\nprintPoint\nSystem.out.println(blank)\njava.awt.Point[x=3,y=4]\nPoint\ntoString\nprintln\ntoString\njava.awt.Point\ndistance\nPoint\ndouble\npublic static double distance(Point p1, Point p2) {\r\n    int dx = p2.x - p1.x;\r\n    int dy = p2.y - p1.y;\r\n    return Math.sqrt(dx * dx + dy * dy);\r\n}\n将对象作为参数可让源代码更易理解且不易出错，因为相关的值被关联起来了。\n10.4　将对象作为返回类型\njava.awt\nRectangle\nimport java.awt.Rectangle;\nRectangle\nPoint\nx\ny\nwidth\nheight\nRectangle\nbox\nRectangle box = new Rectangle(0, 0, 100, 200);\n图 10-2 说明了这条赋值语句的作用。\nRectangle\nSystem.out.println(box)\njava.awt.Rectangle[x=0,y=0,width=100,height=200]\nprintln\nRectangle\ntoString\nRectangle\nfindCenter\nRectangle\nPoint\npublic static Point findCenter(Rectangle box) {\r\n    int x = box.x + box.width / 2;\r\n    int y = box.y + box.height / 2;\r\n    return new Point(x, y);\r\n}\nPoint\nPoint\n10.5　可修改的对象\nx\ny\nRectangle box = new Rectangle(0, 0, 100, 200);\r\nbox.x = box.x + 50;\r\nbox.y = box.y + 100;\n结果如图 10-3 所示。\n图 10-3：显示最新属性值的状态图\n我们可将这些代码封装到一个方法中后再进行泛化，让这个方法能够将矩形移动任何指定的距离：\npublic static void moveRect(Rectangle box, int dx, int dy) {\r\n    box.x = box.x + dx;\r\n    box.y = box.y + dy;\r\n}\ndx\ndy\nRectangle\nRectangle box = new Rectangle(0, 0, 100, 200);\r\nmoveRect(box, 50, 100);\r\nSystem.out.println(box);\n将对象作为实参传递给方法以便修改十分有用，但也可能导致调试更加困难，因为并非在任何情况下都能清楚地知道哪些方法会修改其实参。\nPoint\nRectangle\ntranslate\nmoveRect\nRectangle\nbox.translate(50, 100);\nbox\ntranslate\nbox\n面向对象\nmoveRect\n10.6　指定别名\n引用\nRectangle box1 = new Rectangle(0, 0, 100, 200);\r\nRectangle box2 = box1;\n结果如图 10-4 所示。\n图 10-4：两个变量指向同一个对象的状态图\nbox1\nbox2\nSystem.out.println(box2.width);\r\nbox1.grow(50, 50);\r\nSystem.out.println(box2.width);\n100\nbox2\nRectangle\nbox1\ngrow\nRectangle\ngrow\nbox1\nbox2\n200\nnull\n创建对象变量时，别忘了你在这种变量中存储的是指向对象的引用。Java 中的关键字 null 是一个特殊值，意思是“没有指向任何对象”。可像下面这样声明并初始化对象变量：\nPoint blank = null;\nnull\nnull\nnull\nNullPointerException\nPoint blank = null;\r\nint x = blank.x;             // NullPointerException\r\nblank.translate(50, 50);     // NullPointerException\nnull\nnull\n10.8　垃圾收集\n10.6 节说明了多个变量指向同一个对象会带来的后果。如果一个对象没有被任何变量指向，结果将如何呢？\nPoint blank = new Point(3, 4);\r\nblank = null;\nPoint\nblank\nblank\nblank\nPoint\nnull\n对于未被任何变量指向的对象，则无法访问其属性，也无法对其调用方法。在程序员看来，这样的对象已不复存在，但它依然驻留在计算机内存中，占据着内存空间。\n垃圾收集\n垃圾收集是自动进行的，你什么都不用做，一般都意识不到垃圾收集过程的存在。但在高性能应用程序中，你可能时不时地会注意到些微的延迟，这是因为 Java 在回收被丢弃的对象所占据的空间。\n10.9　类图\nPoint\nRectangle\n数据\n代码\n统一建模语言\n类图\nint x\nx: int\nPoint\nRectangle\n状态图描述的是程序运行时的对象和变量，而类图描述的是编译时的源代码。\nPoint\nRectangle\n10.10　Java类库的源代码\nSystem\nString\nScanner\nMath\nRandom\nJava 类库包含数千个文件，其中的很多文件都包含数千行代码。完全阅读并理解这些代码超出了个人的能力范围，因此千万不要感到害怕！\n因为 Java 类库很大，所以其源代码存储在一个名为 src.zip 的文件中。请花点时间在你的计算机中找到这个文件。\nopenjdk-8-source\n在 OS X 系统中，它很可能位于目录 /Library/Java/JavaVirtualMachines/jdk.../Contents/Home/ 中。\n在 Windows 系统中，它很可能位于目录 C:\\Program Files\\Java\\jdk...\\ 中。\njava\nawt\nPoint.java\nRectangle.java\njava.awt\nPoint.java\nPoint.java\n@param\n@return\nPoint\nRectangle\ngrow\ntranslate\n这里对本章的内容作个总结。对象封装了数据并提供了可直接访问和修改这些数据的方法；面向对象编程能够将繁杂的细节隐藏起来，从而让你更轻松地使用和理解他人编写的代码。\n10.11　术语表\n属性\n对象中的命名数据项。\n句点表示法\n.\n面向对象\n将代码和数据组织成对象，而不是独立的方法。\n垃圾收集\n找出未被引用的对象并收回其占据的存储空间的过程。\nUML\n统一建模语言，软件工程领域中的一种标准绘图方式。\n类图\n对类的属性和方法进行描述的插图。\n10.12　练习\n本章的示例代码位于仓库 ThinkJavaCode 的目录 ch10 中，有关如何下载这个仓库，请参阅前言中的“使用示例代码”一节。做以下的练习前，建议你先编译并运行本章的示例。\n练习10-1\n这个练习旨在确保你明白将对象作为参数进行传递的机制。\nriddle\nmain\nriddle\n(2) 这个程序的输出是什么？\nblank\npublic static int riddle(int x, Point p) {\r\n    x = x + 7;\r\n    return x + p.x + p.y;\r\n}\r\n\r\npublic static void main(String[] args) {\r\n    int x = 5;\r\n    Point blank = new Point(1, 2);\r\n\r\n    System.out.println(riddle(x, blank));\r\n    System.out.println(x);\r\n    System.out.println(blank.x);\r\n    System.out.println(blank.y);\r\n}\n练习10-2\n这个练习旨在确保你明白从方法返回对象的机制。\ndistance\n(2) 这个程序的输出是什么？你能在不运行它的情况下确定这一点吗？\npublic static double distance(Point p1, Point p2) {\r\n    int dx = p2.x - p1.x;\r\n    int dy = p2.y - p1.y;\r\n    return Math.sqrt(dx * dx + dy * dy);\r\n}\r\n\r\npublic static Point findCenter(Rectangle box) {\r\n    int x = box.x + box.width / 2;\r\n    int y = box.y + box.height / 2;\r\n    return new Point(x, y);\r\n}\r\n\r\npublic static void main(String[] args) {\r\n    Point blank = new Point(5, 8);\r\n\r\n    Rectangle rect = new Rectangle(0, 2, 4, 4);\r\n    Point center = findCenter(rect);\r\n\r\n    double dist = distance(center, blank);\r\n    System.out.println(dist);\r\n}\n练习10-3\n这个练习与别名有关。前面说过，别名指的是两个指向同一个对象的变量。\nmain\n(2) 这个程序的输出是什么？\nmain\np1\np2\npublic static void printPoint(Point p) {\r\n    System.out.println(\"(\" + p.x + \", \" + p.y + \")\");\r\n}\r\n\r\npublic static Point findCenter(Rectangle box) {\r\n    int x = box.x + box.width / 2;\r\n    int y = box.y + box.height / 2;\r\n    return new Point(x, y);\r\n}\r\n\r\npublic static void main(String[] args) {\r\n    Rectangle box1 = new Rectangle(2, 4, 7, 9);\r\n    Point p1 = findCenter(box1);\r\n    printPoint(p1);\r\n\r\n    box1.grow(1, 1);\r\n    Point p2 = findCenter(box1);\r\n    printPoint(p2);\r\n}\n练习10-4\nfactorial\nfactorial\n(2) 以表格的方式显示整数 0~30 及其阶乘。你可能会发现，结果到 15 左右就不再正确了。这是为什么呢？\nBigInteger\nBigInteger\njava.math.BigInteger\nBigInteger\nvalueOf\nBigInteger\nint x = 17;\r\nBigInteger big = BigInteger.valueOf(x);\nBigInteger\nadd\nBigInteger\nadd\nBigInteger small = BigInteger.valueOf(17);\r\nBigInteger big = BigInteger.valueOf(1700000000);\r\nBigInteger total = small.add(big);\nmultiply\npow\nfactorial\nBigInteger\nBigInteger\nint\nfactorial\nBigInteger\n练习10-5\n很多加密算法需要计算大整数的幂，下面的方法实现了一种高效的整数幂算法：\npublic static int pow(int x, int n) {\r\n    if (n == 0) return 1;\r\n\r\n    // 递归地计算x的n/2次幂\r\n    int t = pow(x, n / 2);\r\n\r\n    // 如果n为偶数，结果就是t的平方\r\n    // 如果n为奇数，结果就是t的平方乘以x\r\n    if (n % 2 == 0) {\r\n        return t * t;\r\n    } else {\r\n        return t * t * x;\r\n    }\r\n}\nint\nBigInteger\nint\nBigInteger\nadd\nmultiply\nBigInteger.pow\n第 11 章　类\nHello\nHello\nHello\nnew\nHello\nHello\n有用的\n类\n实例\n类定义相当于创建对象的模板，指定了对象包含哪些属性以及哪些方法可以操作这些属性。\n类犹如建筑设计图，可根据同一张设计图建造出很多房子。\n操作对象的方法是在对象所属的类中定义的。\nTime\n数据封装\nPoint\nRectangle\nTime\nTime\nTime\n实例变量\nhour\nminute\nsecond\ndouble\n实例变量是在类定义开头（而不是方法中）声明的。下述代码片段本身就是一个合法的类定义：\npublic class Time {\r\n    private int hour;\r\n    private int minute;\r\n    private double second;\r\n}\nTime\nTime\n信息隐藏\n11.2　构造函数\n构造函数\n构造函数与类同名；\n构造函数没有返回类型（因此没有返回值）；\nstatic\nTime\npublic Time() {\r\n    this.hour = 0;\r\n    this.minute = 0;\r\n    this.second = 0.0;\r\n}\n这个构造函数不接受任何实参，其中的每行代码都将一个实例变量初始化为零（就这里而言，这意味着午夜）。\nthis\nthis\nthis\nthis\nthis\nreturn\nvoid\nTime\nnew\nTime time = new Time();\nnew\nnew\nTime\ntime\nTime\nnew\nnew Time()\npublic Time() {\r\n    new Time();         // 不对！\r\n    this.hour = 0;\r\n    this.minute = 0;\r\n    this.second = 0.0;\r\n}\n11.3　再谈构造函数\n与其他方法一样，构造函数也可重载，这意味着可提供形参不同的多个构造函数。Java 知道该调用哪个构造函数，这是根据你提供的实参确定的。\n一种常见的做法是，在提供一个不接受任何参数的构造函数（如前面的构造函数）的同时，提供一个“值构造函数”，如下：\npublic Time(int hour, int minute, double second) {\r\n    this.hour = hour;\r\n    this.minute = minute;\r\n    this.second = second;\r\n}\n遮盖\nthis\nnew\nTime\nTime time = new Time(11, 59, 59.9);\n重载构造函数可提供这样的灵活性，即先创建对象再填充属性或在创建对象本身前收集所有的信息。\n一旦掌握构造函数的编写技巧，你就会觉得这样的工作很乏味。只需看一眼实例变量列表就能快速编写出构造函数。事实上，有些 IDE 都能替你生成构造函数。\n将前面的代码整合起来，得到如下完整的类定义：\npublic class Time {\r\n    private int hour;\r\n    private int minute;\r\n    private double second;\r\n\r\n    public Time() {\r\n        this.hour = 0;\r\n        this.minute = 0;\r\n        this.second = 0.0;\r\n    }\r\n\r\n    public Time(int hour, int minute, double second) {\r\n        this.hour = hour;\r\n        this.minute = minute;\r\n        this.second = second;\r\n    }\r\n}\n11.4　获取方法和设置方法\nTime\nTime\nTimeClient\n客户端\npublic class TimeClient {\r\n\r\n    public static void main(String[] args) {\r\n        Time time = new Time(11, 59, 59.9);\r\n        System.out.println(time.hour); // compiler error\r\n    }\r\n}\nhour has private access in Time\nTime\nhour\nhour\nTime\nTime\n第一种选择很有吸引力，因为它简单易行，但问题是如果类 A 直接访问类 B 的实例变量，那么类 A 将“依赖”于类 B。换而言之，每当你修改类 B 时，很可能也必须修改类 A。\n如果类 A 只使用类 B 的方法来与类 B 交互，那么它们将是彼此“独立的”，这意味着修改类 B 不会影响类 A（只要类 A 使用的方法的特征标没有变化）。\nTimeClient\nTime\nTime\npublic int getHour() {\r\n    return this.hour;\r\n}\r\n\r\npublic int getMinute() {\r\n    return this.minute;\r\n}\r\n\r\npublic int getSecond() {\r\n    return this.second;\r\n}\n获取方法\nsomething\ngetSomething\nTimeClient\nTime\nTime\npublic void setHour(int hour) {\r\n    this.hour = hour;\r\n}\r\n\r\npublic void setMinute(int minute) {\r\n    this.minute = minute;\r\n}\r\n\r\npublic void setSecond(int second) {\r\n    this.second = second;\r\n}\n设置方法\nsomething\nsetSomething\n编写获取方法和设置方法的工作可能很繁琐，但很多 IDE 都能够根据实例变量生成这些方法。\n11.5　显示对象\nTime\nprintln\npublic static void main(String[] args) {\r\n    Time time = new Time(11, 59, 59.9);\r\n    System.out.println(time);\r\n}\n输出将类似于下面这样：\nTime@80cc7c0\n当要求显示对象类型的值时，Java 显示类型名和对象的地址（十六进制表示）。如果需要跟踪各个对象，这种地址在调试中很有用。\nTime\nprintTime\npublic static void printTime(Time t) {\r\n    System.out.print(t.hour);\r\n    System.out.print(\":\");\r\n    System.out.println(t.minute);\r\n    System.out.print(\":\");\r\n    System.out.println(t.second);\r\n}\ntime\n11:59:59.9\nprintf\npublic static void printTime(Time t) {\r\n    System.out.printf(\"%02d:%02d:%04.1f\\n\",\r\n        t.hour, t.minute, t.second);\r\n}\n%d\n%f\n02\n04.1\ntoString\ntoString\nprint\nprintln\ntoString\ntoString\n覆盖\nTime\ntoString\npublic String toString() {\r\n    return String.format(\"%02d:%02d:%04.1f\\n\",\r\n        this.hour, this.minute, this.second);\r\n}\nstatic\n实例方法\nTime\nprintTime\nthis\nprintf\nString.format\nString.format\ntoString\nTime time = new Time(11, 59, 59.9);\r\nString s = time.toString();\nprintln\nSystem.out.println(time);\ntoString\nthis\ntime\n11:59:59.9\nequals\n==\nequals\n==\n相同\nequals\n相等\n==\nequals\nTime time1 = new Time(9, 30, 0.0);\r\nTime time2 = time1;\r\nTime time3 = new Time(9, 30, 0.0);\n图 11-2 所示的状态图显示了这些变量及其值。\nTime\ntime1\ntime2\ntime1 == time2\ntrue\ntime1\ntime3\ntime1 == time3\nfalse\nequals\n==\nTime\ntime1\ntime3\nequals\npublic boolean equals(Time that) {\r\n    return this.hour == that.hour\r\n    && this.minute == that.minute\r\n    && this.second == that.second;\r\n}\nequals\nthis\nstatic\nequals\ntime1.equals(time3);\nequals\nthis\ntime1\nthat\ntime3\ntrue\n很多对象采用了类似的相等定义，即如果两个对象的实例变量相等，那么这两个对象就相等。然而，也可用其他的方式定义相等。\n11.8　时间相加\n假设你要去看电影，影片开始放映的时间为 18:50（6:50PM），时长为 2 小时 16 分钟，请问影片将在什么时候结束？\nTime\nTime\nTime\n为说明差别，我们将演示这两种方式。静态方法的代码类似于下面这样：\npublic static Time add(Time t1, Time t2) {\r\n    Time sum = new Time();\r\n    sum.hour = t1.hour + t2.hour;\r\n    sum.minute = t1.minute + t2.minute;\r\n    sum.second = t1.second + t2.second;\r\n    return sum;\r\n}\n下面的代码演示了如何调用这个静态方法：\nTime startTime = new Time(18, 50, 0.0);\r\nTime runningTime = new Time(2, 16, 0.0);\r\nTime endTime = Time.add(startTime, runningTime);\n另一方面，实例方法的代码类似于下面这样：\npublic Time add(Time t2) {\r\n    Time sum = new Time();\r\n    sum.hour = this.hour + t2.hour;\r\n    sum.minute = this.minute + t2.minute;\r\n    sum.second = this.second + t2.second;\r\n    return sum;\r\n}\n所做的修改如下。\nstatic\n删除了第一个形参。\nt1\nthis\nt2\nthat\nthis\nthat\nt2\n下面的代码演示了如何调用这个实例方法：\nTime endTime = startTime.add(runningTime);\n这就是将时间相加的静态方法和实例方法。静态方法和实例方法的功能相同，要想在它们之间转换，只需要修改几个地方。\n20:66\nsecond\nminute\nminute\nhour\nadd\npublic Time add(Time t2) {\r\n    Time sum = new Time();\r\n    sum.hour = this.hour + t2.hour;\r\n    sum.minute = this.minute + t2.minute;\r\n    sum.second = this.second + t2.second;\r\n\r\n    if (sum.second >= 60.0) {\r\n        sum.second -= 60.0;\r\n        sum.minute += 1;\r\n    }\r\n    if (sum.minute >= 60) {\r\n        sum.minute -= 60;\r\n        sum.hour += 1;\r\n    }\r\n    return sum;\r\n}\nhour\nTime\ndays\nhour\nsum.hour -= 24\n11.9　纯方法和非纯方法\nadd\nTime\npublic void increment(double seconds) {\r\n    this.second += seconds;\r\n    while (this.second >= 60.0) {\r\n        this.second -= 60.0;\r\n        this.minute += 1;\r\n    }\r\n    while (this.minute >= 60) {\r\n        this.minute -= 60;\r\n        this.hour += 1;\r\n    }\r\n}\nincrement\nTime\nTime\nadd\n纯方法\n它们没有修改形参；\n它们没有任何“副作用”，如打印；\n它们的返回值完全取决于形参，而不受任何其他状态的影响。\nincrement\n非纯方法\nvoid\n因为非纯方法不创建对象，所以效率可能更高，但也更容易出错。如果对象被多个变量指向，可能难以搞清楚非纯方法带来的影响。\nString\n11.10　术语表\n类\n在本书前面，我们将类定义为相关方法的集合。现在你应该知道类也是创建对象的模板。\n实例\n类的一员。每个对象都是某个类的实例。\n数据封装\n将多个命名变量放在单个对象中。\n实例变量\n对象的属性，即在类中定义的非静态变量。\n信息隐藏\n将实例变量声明为私有的，以减少类之间的依赖关系。\n构造函数\n对新创建的对象的实例变量进行初始化的特殊方法。\n遮盖\n定义类型和名称与实例变量相同的局部变量或形参。\n客户端\n使用其他类定义的对象的类。\n获取方法\n返回实例变量的值的方法。\n设置方法\n给实例变量赋值的方法。\n覆盖\ntoString\n实例方法\nthis\n相同\n两个一样的值；就对象变量而言，指的是它们指向同一个对象。\n相等\nequals\n纯方法\n结果只取决于形参，而不受其他数据影响的静态方法。\n非纯方法\n修改对象状态（实例变量）的方法。\n11.11　练习\n本章的示例代码位于仓库 ThinkJavaCode 的目录 ch11 中，有关如何下载这个仓库，请参阅前言中的“使用示例代码”一节。做以下的练习前，建议你先编译并运行本章的示例。\n至此，你已经具备了足够的知识，应该能够看懂介绍简单 2D 图形和动画的附录 B。阅读接下来的几章时，你应抽空阅读这个附录并完成各章的练习。\n练习11-1\njava.awt.Rectangle\njava.lang.String\n练习11-2\nincrement\n提示\n练习11-3\n在图版游戏 Scrabble 中，每个卡片都包含一个字母和一个分数，其中前者用于在行列上拼出单词，后者用于计算单词的价值。\nTile\nchar\nletter\nint\nvalue\nletter\nvalue\nprintTile\nTile\ntestTile\nletter\nvalue\nZ\n10\nTile\nprintTile\nTile\ntoString\nequals\n(6) 为每个属性创建获取方法和设置方法。\n这个练习旨在让你熟悉创建类定义以及编写测试类的代码。\n练习11-4\nDate\nint\nyear\nmonth\nday\nyear\nmonth\nday\nmain\nDate\nbirthday\n练习11-5\n有理数是可表示为分数的数字。例如，2/3 就是一个有理数，数字 7 也是有理数，因为可将其视为 7/1。\nRational\nint\n(2) 编写一个构造函数，让它不接受任何参数，并将分子和分母分别设置为 0 和 1。\nprintRational\nRational\nmain\nRational\n(5) 至此，你编写了一个最基本的程序，请对其进行测试，必要时进行调试。\nRational\ntoString\nprintln\n(7) 再编写一个构造函数，让它包含两个形参，并用它们来初始化实例变量。\nnegate\nvoid\nmain\ninvert\nmain\ntoDouble\ndouble\nreduce\n提示\nadd\nRational\nthis\nRational\n将分数相加的方法有很多种。你可根据自己的喜好选择，但务必对结果进行化简，让分子和分母没有除 1 之外的其他公约数。\n这个练习旨在让你编写包含各种方法的类定义：构造函数、静态方法、实例方法、非纯方法和纯方法。\n第 12 章　对象数组\n在余下的几章中，我们将开发处理单张扑克牌和整副扑克牌的程序。这里大致说一下后面要做的工作。\nCard\nDeck\nCrazy Eights\n本章的代码位于 Card.java 中，这个文件可在本书的代码仓库目录 ch12 中找到。有关如何下载这个仓库，请参阅前言中的“使用示例代码”一节。\nCard\nhttps://en.wikipedia.org/wiki/Standard_52-card_deck\n一副标准的扑克牌有 52 张，每张扑克牌都为 4 种花色（suit）和 13 个点数（rank）之一。四种花色为黑桃、红心、方块和梅花；13 个点数为 A、2、3、4、5、6、7、8、9、10、J、 Q 和 K。\nrank\nsuit\nString\nsuit\n\"Spade\"\nrank\n\"Queen\"\n编码\n下面是为花色建立的一种映射：\n花牌与数字的映射关系如下，其他扑克牌对应其点数表示的数字（2~10）：\nCard\npublic class Card {\r\n    private int rank;\r\n    private int suit;\r\n\r\n    public Card(int rank, int suit) {\r\n        this.rank = rank;\r\n        this.suit = suit;\r\n    }\r\n}\n实例变量被声明为私有的：可以在这个类中访问，但不能在其他类中访问。\nnew\nCard\nCard threeOfClubs = new Card(3, 0);\nCard\ntoString\ntoString\nCard\nString\nString[] suits = new String[4];\n然后给每个元素赋值：\nsuits[0] = \"Clubs\";\r\nsuits[1] = \"Diamonds\";\r\nsuits[2] = \"Hearts\";\r\nsuits[3] = \"Spades\";\n我们也可像 8.3 节那样，在创建数组的同时初始化元素：\nString[] suits = {\"Clubs\", \"Diamonds\", \"Hearts\", \"Spades\"};\nString\n图 12-1：一个字符串数组的状态图\n我们还需要一个对点数进行解码的数组：\nString[] ranks = {null, \"Ace\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"Jack\", \"Queen\", \"King\"};\nnull\nsuit\nrank\nString s = ranks[card.rank] + \" of \" + suits[card.suit];\nsuits[card.suit]\ncard\nsuit\nsuits\ntoString\npublic String toString() {\r\n    String[] ranks = {null, \"Ace\", \"2\", \"3\", \"4\", \"5\", \"6\",\r\n               \"7\", \"8\", \"9\", \"10\", \"Jack\", \"Queen\", \"King\"};\r\n    String[] suits = {\"Clubs\", \"Diamonds\", \"Hearts\", \"Spades\"};\r\n    String s = ranks[this.rank] + \" of \" + suits[this.suit];\r\n    return s;\r\n}\nCard\nprintln\ntoString\nCard card = new Card(11, 1);\r\nSystem.out.println(card);\nJack of Diamonds\n12.3　类变量\n到目前为止，你已经见过了局部变量和实例变量，其中局部变量是在方法中声明的，而实例变量是在类定义中声明的，通常位于类定义前面。\n局部变量是在方法被调用时创建的，方法结束时，它们占据的内存空间将被收回。实例变量是在创建对象时创建的，在对象被作为垃圾收集时，它们占据的内存空间将被收回。\n类变量\nstatic\n共享\npublic class Card {\r\n\r\n    public static final String[] RANKS = {\r\n        null, \"Ace\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\",\r\n        \"8\", \"9\", \"10\", \"Jack\", \"Queen\", \"King\"};\r\n\r\n    public static final String[] SUITS = {\r\n        \"Clubs\", \"Diamonds\", \"Hearts\", \"Spades\"};\r\n\r\n    // 这里为实例变量和构造函数\r\n\r\n    public String toString() {\r\n        return RANKS[this.rank] + \" of \" + SUITS[this.suit];\r\n    }\r\n}\nfinal\nstatic\nfinal\nstatic\nfinal\nstatic final\ntoString\nSUITS\nRANKS\nSUITS\nRANKS\ntoString\nfinal\ncompareTo\nequals\npublic boolean equals(Card that) {\r\n    return this.rank == that.rank\r\n        && this.suit == that.suit;\r\n}\n<\n>\nString\ncompareTo\nequals\ncompareTo\n有些类型是“完全有序的”，即可以通过比较判断出任何两个值的大小。整数和字符串都是完全有序的。\nboolean\ntrue < false\n扑克牌是“部分有序的”，这意味着有些扑克牌能够比较，有些不能。例如，我们知道梅花 3 比梅花 2 大，方块 3 比梅花 3 大，但梅花 3 和方块 2 哪个更大呢？它们一个点数更大，另一个花色更大。\n要想让扑克牌是可以比较的，必须指定哪个更重要：点数还是花色。如何选择没有定规，不同的游戏可能作出不同的选择。但刚买的扑克牌是有序的，开头全部是梅花，然后全部是方块，依次类推。因此，我们现在暂时假设花色更重要。\ncompareTo\npublic int compareTo(Card that) {\r\n    if (this.suit < that.suit) {\r\n        return -1;\r\n    }\r\n    if (this.suit > that.suit) {\r\n        return 1;\r\n    }\r\n    if (this.rank < that.rank) {\r\n        return -1;\r\n    }\r\n    if (this.rank > that.rank) {\r\n        return 1;\r\n    }\r\n    return 0;\r\n}\nthis\ncompareTo\nthat\nCard\nCard\nrank\nsuit\npublic int getRank() {\r\n    return this.rank;\r\n}\r\n\r\npublic int getSuit() {\r\n    return this.suit;\r\n}\nCard\nCard\nfinal\npublic class Card {\r\n    private final int rank;\r\n    private final int suit;\r\n\r\n    ...\r\n}\n你依然可以在构造函数中给这些变量赋值，但如果有人编写试图修改这些变量的方法，编译器将报错。\nCard\nString\nCard\nCard\nCard[] cards = new Card[52];\n图 12-2 是这个数组的状态图。\nCard\nCard\nCard\n引用\nCard\nnull\nif (cards[0] == null) {\r\n    System.out.println(\"No card yet!\");\r\n}\nCard\nNullPointerException\ncards[0].rank     // NullPointerException\nCard\nfor\nint index = 0;\r\n    for (int suit = 0; suit <= 3; suit++) {\r\n    for (int rank = 1; rank <= 13; rank++) {\r\n        cards[index] = new Card(rank, suit);\r\n        index++;\r\n    }\r\n}\n外面的循环迭代花色（从 0~3）。对于每种花色，内部的循环迭代点数（从 1~13）。由于外面的循环运行 4 次，里面的循环运行 13 次，因此循环体被执行 52 次。\n我们使用了一个独立变量来跟踪下一张牌应存储在数组的什么地方，图 12-3 显示了创建开头两张牌后这个数组是什么样的。\nCard\n处理数组时，如果有一个显示其内容的方法将很方便。你已经见过很多次数组遍历模式，因此对下面的方法应该不会感到陌生：\npublic static void printDeck(Card[] cards) {\r\n    for (int i = 0; i < cards.length; i++) {\r\n        System.out.println(cards[i]);\r\n    }\r\n}\ncards\nCard[]\nCard\nprintln\nCard\ntoString\nSystem.out.println(Arrays.toString(cards))\n12.7　顺序查找\nsearch\nCard\nCard\nCard\nCard\nCard\nCard\nsearch\n顺序查找\npublic static int search(Card[] cards, Card target) {\r\n    for (int i = 0; i < cards.length; i++) {\r\n        if (cards[i].equals(target)) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}\nCard\nCard\nequals\nCard\nCard\nCard\nCard\n如何对数组排序将在下一章中介绍。将数组排序后，查找元素将容易得多。顺序查找的效率极低，数组非常大时尤其如此。\n12.8　二分法查找\n二分法查找\n(1) 从字典中间附近的某页开始。\n(2) 将要查找的单词与该页的某个单词比较。如果找到，则就此结束。\n(3) 如果这个单词排在要查找的单词前面，就往后翻并回到第 2 步。\n(4) 如果该页的单词排在要查找的单词后面，就往前翻并回到第 2 步。\n如果你在某页找到两个相邻的单词，即要查找的单词应排在它们之间，那么你就知道这本字典没有你要找的单词。\nCard\nCard\nsearch\npublic static int binarySearch(Card[] cards, Card target) {\r\n    int low = 0;\r\n    int high = cards.length - 1;\r\n    while (low <= high) {\r\n        int mid = (low + high) / 2;                 // 第1步\r\n        int comp = cards[mid].compareTo(target);\r\n\r\n        if (comp == 0) {                            // 第2步\r\n            return mid;\r\n        } else if (comp < 0) {                      // 第3步\r\n            low = mid + 1;\r\n        } else {                                    // 第4步\r\n            high = mid - 1;\r\n        }\r\n    }\r\n    return -1;\r\n}\nlow\nhigh\n0\nlength - 1\nwhile\nlow\nhigh\nmid\nCard\n(2) 如果找到目标，就返回这个索引。\nmid\nCard\nmid + 1\nhigh\nmid\nCard\nlow\nmid - 1\nlow\nhigh\nCard\n-1\ncompareTo\n12.9　跟踪代码\n为了搞明白二分法查找的工作原理，在循环开头添加如下打印语句大有帮助：\nSystem.out.println(low + \", \" + high);\nbinarySearch\nCard card = new Card(11, 0);\r\nSystem.out.println(binarySearch(cards, card));\nCard\n0, 51\r\n0, 24\r\n0, 11\r\n6, 11\r\n9, 11\r\n10\nnew Card(15, 1)\n0, 51\r\n26, 51\r\n26, 37\r\n26, 30\r\n26, 27\r\n-1\nlow\nhigh\nk\nCard\nk\nCard\nCard\nn\nn\nn\n12.10　递归版本\nlow\nhigh\npublic static int binarySearch(Card[] cards, Card target,\r\n                               int low, int high) {\r\n    if (high < low) {\r\n        return -1;\r\n    }\r\n    int mid = (low + high) / 2;                               // 第1步\r\n    int comp = cards[mid].compareTo(target);\r\n\r\n    if (comp == 0) {                                          // 第2步\r\n        return mid;\r\n    } else if (comp < 0) {                                    // 第3步\r\n        return binarySearch(cards, target, mid + 1, high);\r\n    } else {                                                  // 第4步\r\n        return binarySearch(cards, target, low, mid - 1);\r\n    }\r\n}\nwhile\nif\nhigh\nlow\nCard\nCard\nStackOverflowException\n12.11　术语表\n编码\n在两组值之间建立映射，以便用其中的一组值来表示另一组值。\n类变量\nstatic\n顺序查找\n查找数组元素的一种算法。它逐个查找，直到找到目标值为止。\n二分法查找\n查找有序数组的一种算法。它从中间元素开始，将该元素同目标进行比较，从而将余下的一半元素排除在外。\n12.12　练习\n本章的示例代码位于仓库 ThinkJavaCode 的目录 ch12 中，有关如何下载这个仓库，请参阅前言中的“使用示例代码”一节。做以下的练习前，建议你先编译并运行本章的示例。\n练习12-1\nmakeDeck\nCards\n练习12-2\ncompareTo\n练习12-3\n在扑克牌游戏中，同花指的是这样一手牌，即包含 5 张或更多同花色的牌。一手牌可包含任意数量的牌。\nsuitHist\nhasFlush\ntrue\nfalse\n练习12-4\n如果能够在屏幕上显示扑克牌，那么将更有趣。如果你还没有阅读介绍 2D 图形的附录 B，应先阅读再来完成这个练习。本章示例代码所在的目录 ch12 包含：\ncardset-oxymoron，这个目录包含各种扑克牌图像；\nCardTable.java，一个演示如何读取并显示图像的示例程序。\nCardTable.java 演示了如何使用二维数组，具体地说是二维图像数组。这个数组的声明类似于下面这样：\nprivate Image[][] images;\nimages\nImage\nImage\njava.awt\nimages = new Image[14][4];\n这个数组包含 14 行（每种点数占 1 行，还有一个未用的、表示点数 0 的行）、4 列（每种花色一列）。下面的循环填充了这个数组：\nString cardset = \"cardset-oxymoron\";\r\nString suits = \"cdhs\";\r\n\r\nfor (int suit = 0; suit <= 3; suit++) {\r\n    char c = suits.charAt(suit);\r\n    for (int rank = 1; rank <= 13; rank++) {\r\n        String s = String.format(\"%s/%02d%c.gif\",\r\n                                 cardset, rank, c);\r\n        images[rank][suit] = new ImageIcon(s).getImage();\r\n    }\r\n}\ncardset\nsuits\ns\nrank=1\nsuit=2\ns\n\"cardset-oxymoron/01h.gif\"\nImage\nrank\nsuit\n如果编译并运行 CardTable.java，你将在一个绿色表格中看到整副扑克牌的图像。你可以用这个类来实现自己的扑克牌游戏。\n第 13 章　数组对象\nCard\n在本章中，我们将向面向对象编程再迈进一步，定义一个表示整副扑克牌的类。另外，我们还将介绍洗牌算法和数组排序算法。\nch13\nDeck\nDeck\nCard\npublic class Deck {\r\n    private Card[] cards;\r\n\r\n    public Deck(int n) {\r\n        this.cards = new Card[n];\r\n    }\r\n}\nn\nCard\nCard\nCard\nDeck\nDeck\nCard\npublic Deck() {\r\n    this.cards = new Card[52];\r\n    int index = 0;\r\n    for (int suit = 0; suit <= 3; suit++) {\r\n        for (int rank = 1; rank <= 13; rank++) {\r\n            this.cards[index] = new Card(rank, suit);\r\n            index++;\r\n        }\r\n    }\r\n}\n这个方法类似于 12.6 节中的示例；我们只是将这个示例转换成了构造函数。现在可以像下面这样来创建一副标准的扑克牌：\nDeck deck = new Deck();\nDeck\nprintDeck\npublic void print() {\r\n    for (int i = 0; i < this.cards.length; i++) {\r\n        System.out.println(this.cards[i]);\r\n    }\r\n}\ndeck.print()\n13.2　洗牌\n大多数扑克牌游戏需要提供洗牌功能，即将牌随机地排列。8.7 节介绍了如何生成随机数，但如何用随机数来洗牌并不那么简单。\n一种选择是模拟人工洗牌的方式：通常将整副牌分成两半，再交替地从这两半中取牌。因为人工洗牌通常不能洗得很乱，所以需要重复大约 7 次才能让整副牌的排列顺序相当随机。\nhttps://en.wikipedia.org/wiki/Faro_shuffle\n伪代码\nfor each index i {\r\n    // 在i和length - 1之间随机地选择一个数字\r\n    // 将第i张牌和随机选择的那张牌的位置互换\r\n}\nlow\nhigh\n辅助方法\n自上而下的开发\nhttps://en.wikipedia.org/wiki/Top-down_and_bottom-up_design\nrandomInt\nswapCards\nshuffle\n13.3　选择排序\n选择排序\ni\ni\ni\npublic void selectionSort() {\r\n    for each index i {\r\n        // 在整个数组或索引i右边的范围内找到最小的那张牌\r\n        // 将索引i处的牌与找到的最小的牌互换位置\r\n    }\r\n}\nswapCards\nindexLowest\nindexLowest\nselectionSort\n13.4　合并排序\nn\nn\nn\nn\n2\n合并排序\nn\nn\n2\nn\nn\nn\n2\nn\n2\nn\n2\n合并排序的理念如下：如果有两堆已排好序的牌，将它们合并成排好序的一堆牌将既容易又快捷。请用一整副牌来尝试这种算法。\n(1) 将整副牌分成两堆，每堆大约 26 张；分别对每堆牌进行排序，使其面朝上时最小的牌位于最上面；将两堆牌都面朝上放在你面前。\n(2) 比较两堆牌最上面的那张，选择较小的，将其翻过来并加入合并堆。\n(3) 重复第 2 步，直到其中一堆没牌，再将另一堆中余下的牌全都翻过来并加入合并堆。\n结果是排好序的整副牌。接下来的几节将介绍如何用 Java 实现这种算法。\nsubdeck\nsubdeck\nDeck\npublic Deck subdeck(int low, int high) {\r\n    Deck sub = new Deck(high - low + 1);\r\n    for (int i = 0; i < sub.cards.length; i++) {\r\n        sub.cards[i] = this.cards[low + i];\r\n    }\r\n    return sub;\r\n}\nDeck\nfor\nDeck\nDeck\nDeck\nhigh - low + 1\nlow = 0\nhigh = 4\nDeck\nDeck\nsubdeck\nDeck\nCard\nmerge\nmerge\nDeck\nDeck\nDeck\nd1\nd2\nDeck\npublic static Deck merge(Deck d1, Deck d2) {\r\n    // 新建一个可容纳所有扑克牌的Deck对象\r\n\r\n    // 用索引i和j来分别记录当前我们位于两个传入的Deck对象的什么位置\r\n    int i = 0;\r\n    int j = 0;\r\n\r\n    // 用索引k来遍历新创建的Deck对象（result）\r\n    for (int k = 0; k < result.cards.length; k++) {\r\n\r\n        // 如果d1为空，则d2获胜\r\n        // 如果d2为空，则d1获胜\r\n        // 如果d1和d2都不为空，则对两张牌进行比较\r\n\r\n        // 将获胜的牌加入新创建的Deck对象中，并放在索引k指定的位置\r\n        // 将i或j加1\r\n    }\r\n    // 返回新创建的Deck对象\r\n}\nmerge\n13.7　添加递归\nmerge\npublic Deck almostMergeSort() {\r\n    // 将Deck对象一分为二\r\n    // 用selectionSort对这两部分分别排序\r\n    // 合并两部分并返回结果\r\n}\n本章末尾有个练习，要求你实现这种算法。正确实现该算法后，有趣的部分就开始了！合并排序的神奇之处在于，它天然就是递归的。\nselectionSort\nmergeSort\n2\n必须\nmergeSort\nmergeSort\nmergeSort\npublic Deck mergeSort() {\r\n    // 如果Deck对象中没有牌或只包含一张牌，就原封不动地返回它\r\n    // 将Deck对象分成两部分\r\n    // 用mergeSort分别对这两部分排序\r\n    // 合并这两部分并返回结果\r\n}\n与通常情况一样，你也可以用两种方式研究递归程序：研究整个执行流程或采取“姑且相信”的态度（参见 6.8 节）。就这个示例而言，你完全可以采取姑且相信的态度。\nselectionSort\nselectionSort\nmergeSort\n准确地说，差不多是这样的，因为你可能需要确保基线条件没问题且它终将得以满足。除此之外，递归版本与非递归版本没有其他不同。\n13.8　术语表\n伪代码\n一种程序设计方式，结合自然语言和 Java 语言来设计大致的草案。\n辅助方法\n通常是较小的方法，本身所做的工作微不足道，只是为更复杂的方法提供帮助。\n自上而下的开发\n将问题分成几个小问题，再每次解决一个。\n选择排序\nn\n合并排序\n一种递归的排序算法，将数组分成两部分，用合并排序分别对每部分进行排序，再合并结果。\n13.9　练习\n本章的示例代码位于仓库 ThinkJavaCode 的目录 ch13 中，有关如何下载这个仓库，请参阅前言中的“使用示例代码”一节。做以下的练习前，建议你先编译并运行本章的示例。\n练习13-1\nhttp://www.sorting-algorithms.com/\n练习13-2\n这个练习旨在实现本章介绍的洗牌算法。\n(1) 在本书的代码仓库中，有一个名为 Deck.java 的文件，其中包含了本章的示例代码。确认这个文件在你使用的开发环境中能够通过编译。\nDeck\nrandomInt\nint\nlow\nhigh\nlow\nhigh\njava.util.Random\nnextInt\nrandomInt\nRandom\nswapCards\nshuffle\n练习13-3\n这个练习旨在实现本章介绍的排序算法。可用前一个练习中的文件 Deck.java，也可重新创建一个。\nindexLowest\ncompareCard\nlowIndex\nhighIndex\nselectionSort\nmerge\nDeck\nsubdeck\nselectionSort\nmerge\nmergeSort\nDeck\nselectionSort\nmerge\nDeck\nmergeSort\nselectionSort\nmergeSort\ndeck.selectionSort();      // 修改当前Deck对象\r\ndeck = deck.mergeSort();   // 将当前Deck对象替换为新的Deck对象\n练习13-4\nhttp://www.sorting-algorithms.com/insertion-sort\ninsertionSort\n练习13-5\nDeck\ntoString\nDeck\nprint\n提示\n+\njava.util.StringBuilder\n第 14 章　包含其他对象的对象\nCrazy Eights\n给每个人发 5 张或更多的牌，再发一张牌并将其翻开，作为弃牌堆的第一张牌。将余下的牌面朝下，作为储备牌。\n每个人轮流出一张牌到弃牌堆。出的牌必须与前一张牌的点数或花色相同，或者为万能牌 8。\n如果没有匹配的牌或 8 可出，玩家就必须从储备牌中取牌，直到取到匹配的牌或 8。\n储备牌取光后，就对弃牌堆进行洗牌（最上面的那张除外），并将其用作储备牌。\n一旦有人出完了手中的牌，游戏便结束，并对其他人罚分。罚多少分是根据手上余下的牌计算的：8 为 20 分，花牌 10 分，其他牌与其点数相同。\nhttps://en.wikipedia.org/wiki/Crazy_Eights\n本章的示例代码位于本书代码仓库的目录 ch14 中，有关如何下载这个仓库，请参阅前言中的“使用示例代码”一节。\nDeck\n要实现这款游戏，需要表示整副牌、弃牌堆、储备牌以及每个人手中的牌；还需要能够发牌、取牌和出牌。\nDeck\nDeck\nCard\nDeck\njava.util\nArrayList\nCard\nArrayList\n集合\nArrayList\n继承\nCardCollection\nDeck\nHand\nCardCollection\n子类\nCardCollection\n14.2　CardCollection\nCardCollection\nArrayList\npublic class CardCollection {\r\n\r\n    private String label;\r\n    private ArrayList<Card> cards;\r\n\r\n    public CardCollection(String label) {\r\n        this.label = label;\r\n        this.cards = new ArrayList<Card>();\r\n    }\r\n}\nArrayList\n<>\ncards\nCard\nArrayList\nlabel\ncards\nArrayList\nArrayList\nadd\nCardCollection\npublic void addCard(Card card) {\r\n    this.cards.add(card);\r\n}\nthis\naddCard\nthis\nthis\npublic void addCard(Card card) {\r\n    cards.add(card);\r\n}\n我们还需要提供将扑克牌从集合中删除的功能。下面的方法接受一个索引，删除指定位置的扑克牌，并将后面的扑克牌前移，以填补留下的空缺：\npublic Card popCard(int i) {\r\n    return cards.remove(i);\r\n}\npopCard\npublic Card popCard() {\r\n    int i = size() - 1;\r\n    return popCard(i);\r\n}\npopCard\nCardCollection\nsize\nArrayList\nsize\npublic int size() {\r\n    return cards.size();\r\n}\nCardCollection\nempty\nsize\n0\ntrue\npublic boolean empty() {\r\n    return cards.size() == 0;\r\n}\naddCard\npopCard\nsize\n包装器方法\ndeal\npublic void deal(CardCollection that, int n) {\r\n    for (int i = 0; i < n; i++) {\r\n        Card card = popCard();\r\n        that.addCard(card);\r\n    }\r\n}\ndeal\nthis\nthat\nn\nArrayList\n[]\nget\nset\nget\npublic Card getCard(int i) {\r\n    return cards.get(i);\r\n}\nlast\npublic Card last() {\r\n    int i = size() - 1;\r\n    return cards.get(i);\r\n}\nset\npopCard\nswapCards\npublic void swapCards(int i, int j) {\r\n    Card temp = cards.get(i);\r\n    cards.set(i, cards.get(j));\r\n    cards.set(j, temp);\r\n}\nswapCards\nshuffle\npublic void shuffle() {\r\n    Random random = new Random();\r\n    for (int i = size() - 1; i > 0; i--) {\r\n        int j = random.nextInt(i);\r\n        swapCards(i, j);\r\n    }\r\n}\nArrayList\n14.3　继承\nDeck\nHand\nDeck\npublic class Deck extends CardCollection {\r\n\r\n    public Deck(String label) {\r\n        super(label);\r\n        for (int suit = 0; suit <= 3; suit++) {\r\n            for (int rank = 1; rank <= 13; rank++) {\r\n                cards.add(new Card(rank, suit));\r\n            }\r\n        }\r\n    }\r\n}\nextends\nDeck\nCardCollection\nDeck\nCardCollection\nDeck\nCardCollection\nCardCollection\n超类\nDeck\nextends\njava.lang.Object\nDeck\nCardCollection\nCardCollection\nObject\nObject\nequals\ntoString\nDeck\nDeck\nDeck deck = new Deck(\"Deck\");\nDeck\nsuper\nsuper\nsuper\nCardCollection\nlabel\ncards\nDeck\nCard\nArrayList\nDeck\nHand\npublic class Hand extends CardCollection {\r\n\r\n    public Hand(String label) {\r\n        super(label);\r\n    }\r\n\r\n    public void display() {\r\n        System.out.println(getLabel() + \": \");\r\n        for (int i = 0; i < size(); i++) {\r\n            System.out.println(getCard(i));\r\n        }\r\n        System.out.println();\r\n    }\r\n}\nDeck\nHand\nCardCollection\ngetLabel\nsize\ngetCard\ndisplay\nHand\nCardCollection\nDeck\nCardCollection\ndisplay\n14.4　发牌\nDeck\nDeck deck = new Deck(\"Deck\");\r\ndeck.shuffle();\r\n\r\nHand hand = new Hand(\"Hand\");\r\ndeck.deal(hand, 5);\r\nhand.display();\r\n\r\nHand drawPile = new Hand(\"Draw Pile\");\r\ndeck.dealAll(drawPile);\r\nSystem.out.printf(\"Draw Pile has %d cards.\\n\",\r\n                  drawPile.size());\nCardCollection\ndealAll\nHand:\r\n5 of Diamonds\r\nAce of Hearts\r\n6 of Clubs\r\n6 of Diamonds\r\n2 of Clubs\r\n\r\nDraw Pile has 47 cards.\n当然，如果你运行这个示例，得到的那手牌可能不同，因此整副牌洗得很乱。\ndeal\npublic void deal(CardCollection that, int n) {\r\n    for (int i = 0; i < n; i++) {\r\n        Card card = popCard();\r\n        that.addCard(card);\r\n    }\r\n}\nCardCollection\nHand hand = new Hand(\"Hand\");\r\ndeck.deal(hand, 5);\nHand\nCardCollection\nHand\nCardCollection\nHand\nCardCollection\nCardCollection\nHand\nDeck\nCardCollection\nCardCollection\nHand\nHand\nHand\nCardCollection\n一个对象可以属于多种类型好像有点怪，但现实世界也存在这样的情况。所有的猫都是哺乳动物，所有哺乳动物都是动物；但并非所有的动物都是哺乳动物，并非所有的哺乳动物都是猫。\nPlayer\nCrazy Eights\nPlayer\nEights\nPlayer\npublic class Player {\r\n\r\n    private String name;\r\n    private Hand hand;\r\n\r\n    public Player(String name) {\r\n        this.name = name;\r\n        this.hand = new Hand(name);\r\n}\nPlayer\nname\nhand\nname\nthis\nPlayer\nplay\npublic Card play(Eights eights, Card prev) {\r\n    Card card = searchForMatch(prev);\r\n    if (card == null) {\r\n        card = drawForMatch(eights, prev);\r\n    }\r\n    return card;\r\n}\nEights\nprev\nplay\nsearchForMatch\ndrawForMatch\nsearchForMatch\npublic Card searchForMatch(Card prev) {\r\n    for (int i = 0; i < hand.size(); i++) {\r\n        Card card = hand.getCard(i);\r\n        if (cardMatches(card, prev)) {\r\n            return hand.popCard(i);\r\n        }\r\n    }\r\n    return null;\r\n}\nfor\nnull\npublic Card drawForMatch(Eights eights, Card prev) {\r\n    while (true) {\r\n        Card card = eights.draw();\r\n        System.out.println(name + \" draws \" + card);\r\n        if (cardMatches(card, prev)) {\r\n            return card;\r\n        }\r\n        hand.addCard(card);\r\n    }\r\n}\nwhile\nEights\nsearchForMatch\ndrawForMatch\ncardMatches\ncardMatches\nPlayer\npublic static boolean cardMatches(Card card1, Card card2) {\r\n    if (card1.getSuit() == card2.getSuit()) {\r\n        return true;\r\n    }\r\n    if (card1.getRank() == card2.getRank()) {\r\n        return true;\r\n    }\r\n    if (card1.getRank() == 8) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\nPlayer\nscore\npublic int score() {\r\n    int sum = 0;\r\n    for (int i = 0; i < hand.size(); i++) {\r\n        Card card = hand.getCard(i);\r\n        int rank = card.getRank();\r\n        if (rank == 8) {\r\n            sum -= 20;\r\n        } else if (rank > 10) {\r\n            sum -= 10;\r\n        } else {\r\n            sum -= rank;\r\n        }\r\n    }\r\n    return sum;\r\n}\nEights\n13.2 节介绍了自上而下的开发，这种程序开发方式确定高层次的目标，如洗牌，并将其分解为更小的问题，如在数组中查找最小的元素或交换两个元素。\n自下而上的开发\nCrazy Eights\n创建整副扑克牌、弃牌堆、储备牌以及表示玩家的对象。\n发牌。\n检查游戏是否结束。\n如果没有了储备牌，就将弃牌堆洗一下，并将其作为储备牌。\n取牌。\n跟踪轮到谁出牌以及从一个玩家切换到下一个玩家。\n显示游戏的状态。\n进入下一轮前等待用户。\nEights\npublic class Eights {\r\n\r\n    private Player one;\r\n    private Player two;\r\n    private Hand drawPile;\r\n    private Hand discardPile;\r\n    private Scanner in;\n这个版本只有两个玩家。本章末尾有一个练习，要求你修改这些代码，以支持更多玩家。\nScanner\npublic Eights() {\r\n    Deck deck = new Deck(\"Deck\");\r\n    deck.shuffle();\r\n\r\n    int handSize = 5;\r\n    one = new Player(\"Allen\");\r\n    deck.deal(one.getHand(), handSize);\r\n    two = new Player(\"Chris\");\r\n    deck.deal(two.getHand(), handSize);\r\n\r\n    discardPile = new Hand(\"Discards\");\r\n    deck.deal(discardPile, 1);\r\n\r\n    drawPile = new Hand(\"Draw pile\");\r\n    deck.dealAll(drawPile);\r\n\r\n    in = new Scanner(System.in);\r\n}\n接下来需要实现的是检查游戏是否结束的方法。只要有一个玩家手里没牌，游戏便结束了：\npublic boolean isDone() {\r\n    return one.getHand().empty() || two.getHand().empty();\r\n}\n没有储备牌时，我们必须将弃牌堆洗一下。完成这种任务的方法如下：\npublic void reshuffle() {\r\n    Card prev = discardPile.popCard();\r\n    discardPile.dealAll(drawPile);\r\n    discardPile.addCard(prev);\r\n    drawPile.shuffle();\r\n}\ndiscardPile\ndrawPile\ndiscardPile\ndrawPile\ndraw\nreshuffle\npublic Card draw() {\r\n    if (drawPile.empty()) {\r\n        reshuffle();\r\n    }\r\n    return drawPile.popCard();\r\n}\n要从一个玩家切换到另一个玩家，我们可以像下面这样做：\npublic Player nextPlayer(Player current) {\r\n    if (current == one) {\r\n        return two;\r\n    } else {\r\n        return one;\r\n    }\r\n}\nnextPlayer\ndisplayState\nwaitForUser\npublic void displayState() {\r\n    one.display();\r\n    two.display();\r\n    discardPile.display();\r\n    System.out.println(\"Draw pile:\");\r\n    System.out.println(drawPile.size() + \" cards\");\r\n}\r\n\r\npublic void waitForUser() {\r\n    in.nextLine();\r\n}\ntakeTurn\npublic void takeTurn(Player player) {\r\n    Card prev = discardPile.last();\r\n    Card next = player.play(this, prev);\r\n    discardPile.addCard(next);\r\n\r\n    System.out.println(player.getName() + \" plays \" + next);\r\n    System.out.println();\r\n}\ntakeTurn\nplayer.play\ntakeTurn\nplayGame\npublic void playGame() {\r\n    Player player = one;\r\n\r\n    // 不断地玩，直到有人获胜\r\n    while (!isDone()) {\r\n        displayState();\r\n        waitForUser();\r\n        takeTurn(player);\r\n        player = nextPlayer(player);\r\n    }\r\n\r\n    // 显示最终得分\r\n    one.displayScore();\r\n    two.displayScore();\r\n}\n大功告成！注意，自下而上开发的结果与自上而下类似：有一个调用辅助方法的高级方法。主要差别在于实现解决方案的顺序不同。\n14.7　类之间的关系\n本章演示了两种常见的类间关系。\n组合\nEights\nPlayer\nHand\nScanner\n继承\nHand\nCardCollection\nHand\nCardCollection\n有一个\nEights\nScanner\n是一个\nHand\nCardCollection\n对于这些关系，还有一种标准的图形表示方式，那就是 UML 类图。正如你在 10.9 节看到的，类的 UML 表示是一个方框，这个方框包含三部分：类名、属性和方法。但用于显示类之间的关系时，后两部分是可选的。\n类之间的关系用箭头表示：标准箭头表示组合关系，空三角形箭头（通常是向上的）表示继承关系。图 14-1 显示了本章定义的类以及它们之间的关系。\n图 14-1：显示本章定义的类及其关系的 UML 图\nUML 属于国际标准，因此几乎任何软件工程师看到这种图时都能够明白它所表示的设计。类图只是 UML 标准定义的众多图形表示之一。\n本章总结了本书介绍的各种技术，包括变量、方法、条件、循环、数组、对象和算法，但愿对你有所帮助。祝贺你阅读完了本书！\n14.8　术语表\n集合\nArrayList\n继承\n一种定义新类的方式，让新类包含既有类的所有实例变量和方法。\n子类\n继承或扩展既有类的类。\n超类\n被另一个类扩展的既有类。\n包装器方法\n调用另一个方法，但除此之外所做工作不多的方法。\n自下而上的开发\n一种程序开发方式，先确定并实现简单的部分，再将它们组合成更复杂的算法。\n有一个\n两个类之间的关系，其中一个类将另一个类的实例作为属性。\n是一个\n两个类之间的关系，其中一个类扩展了另一个类，即子类的实例也是超类的实例。\n14.9　练习\n本章的示例代码位于仓库 ThinkJavaCode 的目录 ch14 中，有关如何下载这个仓库，请参阅前言中的“使用示例代码”一节。做以下的练习前，建议你先编译并运行本章的示例。\n练习14-1\nPlayer.play\nPlayer\nplay\n练习14-2\n编写一个循环，在其中玩 100 次本章介绍的游戏，并记录每位玩家分别赢了多少次。如果你实现了前一个练习介绍的多种出牌策略，那么可让这些策略进行较量，看看哪种策略的效果最好。\n提示\nPlayer\nGenius\nplay\nGenius\n练习14-3\nEights\nArrayList\nnextPlayer\n练习14-4\ncardMatches\nPlayer\nCard\nCard\nCrazy Eights\nCard\nEightsCard\nmatch\nCrazy Eights\nHand\nEightsHand\nscoreHand\nEightsCard\nscoreCard\n无论你是否做了这些修改，都请绘制一个 UML 类图来显示这种继承层次结构。\n附录 A　开发工具\n集成开发环境\nA.1　安装DrJava\n要想用 Java 进行编程，最简单的方式是使用在浏览器中编译和运行 Java 代码的网站，如 jdoodle.com、compilejava.net 和 tutorialspoint.com 等。\n如果你不能在计算机上安装软件（公立学校和网吧就属于这种情况），可用这些在线开发环境来完成本书的大部分示例。\n然而，如果你要在自己的计算机上编译并运行 Java 程序，就需要：\nJava 开发包\nJava 虚拟机\n文本编辑器\n对于 JDK，我们推荐使用 Oracle 免费提供的 Java SE 标准版；对于 IDE，我们推荐使用 DrJava，这是一个用 Java 编写的开源开发环境，如图 A-1 所示。\n图 A-1：在 DrJava 中编辑程序 Hello World\n要想安装 JDK，可在网上搜索 download JDK，这将把你带到 Oracle 网站。向下滚动到 Java Platform, Standard Edition 部分，并单击 JDK 下方的 download 按钮。再选择单选按钮 Accept License Agreement，并单击用于你的操作系统的安装程序。下载安装程序后，别忘了安装！\nhttp://drjava.org\nhttp://drjava.org/docs/quickstart/\n首次运行 DrJava 时，建议你选择菜单 Edit>Preferences，并修改 Miscellaneous 下的三项设置：将 Indent Level（Tab 键对应的缩进量）设置为 4；选择复选框 Automatically Close Block Comments（自动添加块注释结束标志）；取消选择复选框 Keep Emacs-style Backup Files（保存 Emacs 风格的备份文件）。\nA.2　DrJava Interactions窗格\nDrJava 最有用的功能之一是窗口底部的 Interactions 窗格，它让你无需编写类定义再保存、编译并运行程序就能尝试运行代码，如图 A-2 所示。\n图 A-2：DrJava 中的 Interactions 窗格\nSystem.out.println\nInteractions\nmain\nSystem.out.println\nA.3　命令行界面\n命令行界面\ncd\nls\njavac\njava\njavac\nls\njava\n图 A-3：从命令行编译并运行 Hello.java\njavac\n源代码文件名\njava\n类名\n花点时间学会这种高效而优雅的、与操作系统交互的方式，将提高你的生产率。不用命令行的人都不知道自己失去的是什么。\nA.4　命令行测试\n我们在 1.8 节中说过，相比于一次性编写所有的代码，逐步编写并调试代码的做法更有效。编写实现算法的代码后，通过测试来确定不管输入如何它都能正确地工作很重要。\n本书很多地方都演示了程序测试技巧。大多数测试都基于简单的想法：程序的所做所为符合预期吗？对于简单的程序，多次运行并查看结果并不难；但反复输入相同的测试用例终将让你感到厌烦。\n通过使用命令行，可将提供输入、比较期望输出与实际输出的过程自动化。其中的基本理念是将测试用例存储在纯文本文件中，并让 Java 以为这些输入来自键盘。实现这种想法的基本步骤如下。\nConvert.java\nConvert.java\ntest.in\n193.04\ntest.exp\n193.04 cm = 6 ft, 4 in\n(4) 打开一个终端窗口，并切换到这些文件所在的目录。执行下面的命令来测试这个程序：\njava Convert < test.in > test.out\n<\n>\n重定向运算符\n顺便说一句，完全可以在 DrJava（或其他开发环境）中对程序进行编译，再从命令行运行。熟悉这两种方法后，你就可根据工作需要选择合适的工具了。\n现在可以对 test.out 和 test.exp 的内容进行比较了。如果这两个文件的内容相同，就说明程序的输出符合预期；如果不同，就说明程序存在 bug，而我们可根据实际输出对程序进行调试。所幸有一种通过命令行对文件进行比较的简单方式：\ndiff test.exp test.out\ndiff\ndiff\ndiff\ndiff\nWinMerge\nopendiff\nmeld\nmeld\n不管用哪种工具，目标都是相同的：不断调试程序，直到实际输出与预期输出相同。\nA.5　运行Checkstyle\nCheckstyle 是一个命令行工具，可用于判断源代码是否遵循了指定的风格规则，还能检查出常见的编程错误，如类和方法设计中存在的问题。\nhttp://checkstyle.sourceforge.net/\njava -jar checkstyle-*-all.jar -c /google_checks.xml *.java\n*\n通配符\nHello.java\nHello.java:93:5: Missing a Javadoc comment\n/google_checks.xml\n/sun_checks.xml\n质量\n意义\n结构\n良好的注释能够让经验丰富的程序员更轻松地找出代码中的错误；好的变量名指出了程序的意图以及数据是如何组织的；而优秀的程序既高效又正确无误。\nA.6　使用调试器进行跟踪\n调试器\n断点\n(2) 以步进方式执行代码，即每次执行一行代码并查看每行代码的作用。\n(3) 检查变量的值，看看它们在什么时候变了以及是怎么变的。\nmain\n调用栈\nmain\n调用栈的右边有多个按钮，让你能够以不同的步伐执行代码。还可以单击 Automatic Trace 按钮，让 DrJava 以每次一行的方式自动执行代码。\n使用调试器犹如让计算机大声地审读代码。程序暂停后，可通过 Interactions 窗格检查甚至修改任何变量的值。\n跟踪让你能够沿执行流程前行，并了解数据是如何在方法之间传递的。你可能预期代码会这样做，但调试器却指出它是那样做的。在这种情况下，你就知道代码可能存在什么样的错误。\nprintTwice\nmain\n可在调试代码的同时对其进行编辑，但不建议这样做，因为如果在程序暂停时添加或删除多行代码，你可能根本不知道结果是怎么来的。\nhttp://drjava.org/docs/user/ch09.html\nA.7　用JUnit进行测试\nmain\n单元测试\nfibonacci\npublic static void main(String[] args) {\r\n    if (fibonacci(1) != 1) {\r\n        System.err.println(\"fibonacci(1) is incorrect\");\r\n    }\r\n    if (fibonacci(2) != 1) {\r\n        System.err.println(\"fibonacci(2) is incorrect\");\r\n    }\r\n    if (fibonacci(3) != 2) {\r\n        System.err.println(\"fibonacci(3) is incorrect\");\r\n    }\r\n}\n这些测试代码的作用不言自明，但没必要这么长，可扩展性也不佳。另外，错误消息提供的信息也很有限。用单元测试框架可解决这些问题以及其他的问题。\nhttp://junit.org\nClass\nClassTest\nClass\nmethod\nTestClass\ntestMethod\nfibonacci\nSeries\nimport junit.framework.TestCase;\r\n\r\npublic class SeriesTest extends TestCase {\r\n\r\n    public void testFibonacci() {\r\n        assertEquals(1, Series.fibonacci(1));\r\n        assertEquals(1, Series.fibonacci(2));\r\n        assertEquals(2, Series.fibonacci(3));\r\n    }\r\n}\nextends\nSeriesTest\njunit.framework\nTestCase\n很多开发环境能够自动生成测试类和测试方法。在 DrJava 中，可选择菜单 File>New JUnit Test Case 来生成空的测试类。\nassertEquals\nTestCase\nif\nSystem.err\nassertEquals\nassertNull\nassertSame\nassertTrue\n要想在 DrJava 中直接运行 JUnit 测试，可单击工具栏中的 Test 按钮。如果所有的测试方法都通过了，右下角将出现一个绿条；否则 DrJava 将把你带到第一个失败的断言处。\nA.8　术语表\nIDE\n集成开发环境，包含用于编辑、编译和调试程序的工具。\nJDK\nJava 开发包，包含编译器、Javadoc 和其他工具。\nJVM\nJava 虚拟机，对编译得到的字节码进行解释。\n文本编辑器\n用于编辑大多数编程语言使用的纯文本文件的程序。\nJAR\nJava 归档文件，其实就是包含类和其他资源的 ZIP 文件。\n命令行界面\n一种通过执行文本命令与计算机交互的途径。\n重定向运算符\nSystem.in\nSystem.out\n通配符\n*\n调试器\n一种让你能够每次运行一条语句并查看变量值的工具。\n断点\n一行代码，到这里后调试器将暂停执行程序。\n调用栈\n有关方法调用以及每个方法返回后将在什么地方继续执行的历史记录。\n单元测试\n执行程序中的单个方法，旨在测试其正确性和（或）效率的代码。\n附录 B　Java 2D 图形\njava.awt\nhttps://docs.oracle.com/javase/tutorial/2d/\nB.1　创建图形\njava.awt.Canvas\njava.awt.Graphics\nCanvas\nGraphics\ndrawLine\ndrawRect\ndrawString\nfillOval\nimport java.awt.Canvas;\r\nimport java.awt.Graphics;\r\nimport javax.swing.JFrame;\r\n\r\npublic class Drawing extends Canvas {\r\n\r\n    public static void main(String[] args) {\r\n        JFrame frame = new JFrame(\"My Drawing\");\r\n        Canvas canvas = new Drawing();\r\n        canvas.setSize(400, 400);\r\n        frame.add(canvas);\r\n        frame.pack();\r\n        frame.setVisible(true);\r\n    }\r\n\r\n    public void paint(Graphics g) {\r\n        g.fillOval(100, 100, 200, 200);\r\n    }\r\n}\nDrawing\nCanvas\nCanvas\nsetSize\nmain\nJFrame\nDrawing\n(3) 将框架的大小调整为与画布相同，再将其显示到屏幕上。\npaint\nmain\nJFrame\nGraphics\n坐标\nx\ny\nx\ny\n图 B-1：笛卡尔儿坐标和 Java 图形坐标的差别\n像素\nGraphics\nGraphics\nCanvas\npaint\nfillOval\n/**\r\n * 用当前颜色填充一个被指定矩形内接的椭圆\r\n */\r\npublic void fillOval(int x, int y, int width, int height)\n定界框\nx\ny\n图 B-2：内接定界框的椭圆\nGraphics\nsetColor\ng.setColor(Color.red);\nsetColor\nColor.red\nColor\njava.awt.Color\nblack       blue      cyan     darkGray   gray    green\r\nlightGray   magenta   orange   pink       white   yellow\n还可通过指定红色、绿色和蓝色（GRB）分量来自定义颜色，如下所示：\nColor purple = new Color(128, 0, 128);\n(0, 0, 0)\n(255, 255, 255)\nsetBackground\nCanvas\ncanvas.setBackground(Color.white);\nB.3　绘图示例\nhttps://en.wikipedia.org/wiki/Hidden_Mickey\nRectangle\nRectangle\nfillOval\npublic void boxOval(Graphics g, Rectangle bb) {\r\n    g.fillOval(bb.x, bb.y, bb.width, bb.height);\r\n}\n下面的方法绘制米老鼠：\npublic void mickey(Graphics g, Rectangle bb) {\r\n    boxOval(g, bb);\r\n\r\n    int dx = bb.width / 2;\r\n    int dy = bb.height / 2;\r\n    Rectangle half = new Rectangle(bb.x, bb.y, dx, dy);\r\n\r\n    half.translate(-dx / 2, -dy / 2);\r\n    boxOval(g, half);\r\n\r\n    half.translate(dx * 2, 0);\r\n    boxOval(g, half);\r\n}\n第 1 行绘制脸；接下来的 3 行创建一个较小的矩形。然后，我们将这个矩形向左上方平移，用作左耳的定界框，再将它向右平移，用作右耳的定界框。结果如图 B-3 所示。\n图 B-3：用 Java 图形绘制的隐藏的米奇\nRectangle\ntranslate\nB.4　术语表\nAWT\n抽象窗口工具包——用于创建图形用户界面的 Java 包。\n坐标\n指定二维图形窗口中位置的值。\n像素\n坐标的度量单位。\n定界框\n一种指定矩形区域坐标的常见方式。\nRGB\n一种基于红、绿、蓝的颜色模型。\nB.5　练习\n本附录的示例代码位于仓库 ThinkJavaCode 的目录 ap02 中，有关如何下载这个仓库，请参阅前言中的“使用示例代码”一节。建议你先编译并运行这些示例，再动手做下面的练习。\n练习B-1\n绘制一面日本国旗：宽度比高度长的白色背景上有一个红色圆。\n练习B-2\n修改 Mickey.java，在每个耳朵上反复绘制两个耳朵，直到最小的耳朵的宽度只有 3 像素为止。\n提示\n图 B-4：我们称之为“米老鼠”的递归形状\n练习B-3\nhttps://en.wikipedia.org/wiki/Moire_pattern\npaint\n(2) 修改这个程序，增大或缩小相邻圆的间距，再看看结果。\n(3) 修改这个程序，使其绘制以屏幕中点为圆心的同心圆，如图图 B-5（左）所示。相邻圆的间距必须足够小，这样才能出现摩尔干涉效果。\nradial\n(5) 几乎任何图案都能形成摩尔干涉效果。自己研究研究，看看你能创建哪些能够形成摩尔干涉效果的图案。\n图 B-5：展示摩尔干涉的图案\n附录 C　调试\n虽然有关调试的建议贯穿本书，但我们认为将它们放在一个附录中会很有帮助。每当你在调试过程中陷入困境时，都应该重温这个附录。\n哪种调试策略是最佳的呢？这取决于你面临的错误类型。\n编译时错误\n运行时错误\nStackOverflowError\n逻辑错误\n接下来的几节将介绍不同错误类型的相关调试技巧；有些技巧适用于特定类型的错误，对其他类型的错误可能不太管用。\nC.1　编译时错误\n最佳的调试方式是不用调试，因为你将错误扼杀在了摇篮中。为此，可采用 6.2 节中介绍的渐进开发，其中的关键是先编写一个可运行的简单程序，再每次添加少量的代码，这样发生错误时，你就会非常清楚它们出现在什么地方。\n尽管如此，你可能还是会遭遇下面的情形。对于每种情形，我们都提供了一些处理建议。\nC.1.1　编译器显示大量的错误消息\n编译器显示 100 条错误消息时，并不意味着程序存在 100 个错误。编译器遇到错误时，通常会暂时反应不过来。过了第一个错误后，它会尝试再次理清思路，但有时会错报错误。\n只有第一条错误消息是确实可靠的。因此我们建议你每次只修复一个错误，并立即再次编译程序。你可能发现，添加一个分号或大括号就消除了 100 个错误。\nC.1.2　编译器显示怪异的错误消息，怎么都消除不掉\n首先，仔细阅读错误消息。错误消息可能包含简洁的专业术语，但通常隐藏着重要的信息。\n即便没有提供其他信息，消息也至少指出了问题出现在程序的什么地方。实际上，它指出的是编译器阅读到什么地方时发现了问题，但错误并非一定就在那里。将编译器提供的信息作为参考，如果在编译器所说的地方没有发现错误，就扩大搜索范围。\n错误通常出现在错误消息指出的位置的前面，但也可能出现在其他地方。例如，如果错误消息指出方法调用有问题，实际的错误很可能出现在方法定义中。\n如果不能迅速找到错误，可先缓口气，再在整个程序中查找。为此，要先确保正确地缩进了程序代码，这样更容易发现语法错误。\n然后，开始查找常见的语法错误。\n(1) 检查所有的小括号和方括号都是成对的且嵌套正确。所有的方法定义都必须嵌套在类定义中。所有的程序语句必须位于方法定义中。\n(2) 别忘了，Java 区分大小写。\n(3) 检查语句末尾的分号。另外，大括号后面不需要分号。\n(4) 确保代码中的所有字符串的引号都是成对的；确保使用了双引号来括起字符串，并使用了单引号来括起字符。\n(5) 对于每条赋值语句而言，确保左边的类型与右边的类型相同。确保表达式的左边是变量名或其他可赋值的东西（如数组元素）。\n(6) 确保每个方法调用指定的实参的类型和排列顺序是正确的，且用来调用方法的对象的类型也是正确的。\nvoid\n没有\n(8) 调用实例方法时，确保调用它的对象的类型是正确的；在类外面调用其静态方法时，确保用句点表示法指定了类名。\nthis\nx\nx\n如果还是没有找到错误，请进入下一节。\nC.1.3　怎么做都无法让程序通过编译\n如果编译器说存在错误，但你找不出来，可能是因为你和编译器看的代码不同。请检查开发环境，确保你编辑的程序就是编译器编译的程序。\n程序有多个版本时，经常会出现这样的情况。你编辑的是一个版本，而编译的是另一个版本。\n如果你不确定是不是这样的，可在程序开头故意添加一个显而易见的语法错误，再重新编译。如果编译器没有发现新添的错误，就很可能是开发环境的设置有问题。\n二分调试\n备份当前调试的文件。如果调试的是 Bob.java，就创建副本并将其命名为 Bob.java.old。\n将 Bob.java 的代码删除约一半，再重新编译。\n如果程序能够通过编译，就说明错误发生在被删除的代码中。将删除的代码恢复一半，并再次进行编译。\n如果程序不能通过编译，那么错误肯定出在刚恢复的代码中。将刚恢复的代码删除一半，并再次进行编译。\n找到并修复错误后，再逐步恢复被删除的代码。\n这种做法一点都不优雅，但找到错误的速度可能比你想象得快，而且非常可靠。也适用于其他编程语言！\nC.1.4　按编译器说的做了，但还是不管用\nGolfer\njava.lang.Comparable\nint compareTo(java.lang.Object)\nGolfer\nGolfer\nObject\ncompareTo\n可别让编译器牵着鼻子走。错误消息表明存在错误，但推荐的解决之道并不可靠。\nC.2　运行时错误\n导致运行时错误的原因并非总是那么明显，但在程序中添加打印语句通常能找出原因。\nC.2.1　程序挂起\n如果程序停止运行，看起来什么都不做，我们就说它“挂起”了。这通常意味着遭遇了无限循环或无限递归。\n如果你怀疑问题出在某个循环上，可在该循环前面添加一条显示“进入循环”的打印语句，并在它后面添加一条显示“退出循环”的打印语句。\n运行程序。如果你看到了第一条消息，但没有看到第二条，就知道程序在什么地方卡壳了。为解决这种问题，请参阅“无限循环”一节。\nStackOverflowError\nStackOverflowError\n如果上述两个建议都不管用，可能是因为你没有搞明白程序的执行流程。在这种情况下，可参阅“执行流程”一节。\n1. 无限循环\n如果你认为程序包含无限循环并知道是哪一个，可在这个循环末尾添加打印语句，以显示条件变量的值以及条件的值。\n例如：\nwhile (x > 0 && y < 0) {\r\n    // 修改x\r\n    // 修改y\r\n\r\n    System.out.println(\"x: \" + x);\r\n    System.out.println(\"y: \" + y);\r\n    System.out.println(\"condition: \" + (x > 0 && y < 0));\r\n}\nfalse\nx\ny\n2. 无限递归\nStackOverflowError\n如果你知道无限递归是哪个方法导致的，可检查它是否包含基线条件。必须存在某种条件，让方法不再进行递归调用而是返回。如果没有，就需要重新审视算法并找出基线条件。\n如果有基线条件，但程序好像满足不了这个条件，可在方法开头添加显示形参的打印语句。这样的话，在程序运行期间，每当这个方法被调用时，你都将看到几行输出并获悉形参的值。如果形参没有逐渐接近基线条件，你也许能够搞明白其中的原因。\n3. 执行流程\nfoo\nfoo\n还可显示每个方法收到的实参。这样的话，你可以在程序运行时检查实参的值是否合理，还能发现最常见的错误之一——实参的指定顺序不正确。\nC.2.2　程序运行时出现异常\n出现异常时，Java 会显示一条消息，其中包含异常的名称、出现异常的代码的行号以及“栈跟踪”。栈跟踪包含当时运行的方法和方法调用链。\n你应该先检查错误发生的地方，并看看能不能找出其中的原因。\nNullPointerException\nnull\nnull\nnull\nnull\nNullPointerException\nint[] array = new Point[5];\r\nSystem.out.println(array[0].x);\nArrayIndexOutOfBoundsException\narray.length - 1\n然后，在程序中往后回溯，确定数组和索引来自何方。找到最近的赋值语句，看看其所作所为是否正确。如果数组或索引为形参，那么就跳转到调用方法的地方，看看这些值来自何方。\nStackOverflowError\n参见前面的“无限递归”一节。\nFileNotFoundException\n这意味着 Java 没有找到要查找的文件。如果你使用的是基于项目的开发环境，如 Eclipse，可能必须将这个文件导入项目。否则，请确保这个文件存在且路径正确。这种问题与文件系统相关，可能难以追查。\nArithmeticException\n算术运算的执行出现了问题，如除以零。\nC.2.3　添加了很多打印语句，输出都泛滥成灾了\n用打印语句帮助调试带来的一个问题是，最终的输出可能泛滥成灾。解决之道有两个：要么简化输出，要么简化程序。\n要想简化输出，可将不再有帮助的打印语句删除或注释掉、合并打印语句或设置输出的格式使其易于理解。开发程序时，应编写代码来生成简洁而信息丰富的消息，对程序的所作所为进行跟踪。\n较小的\n另外，对代码进行清理：删除多余或实验性部分，并重新组织程序使其更易阅读。例如，如果你怀疑错误出在程序中的一个多层嵌套的部分，可用更简单的结构重新编写这部分；如果你怀疑错误出现在一个很大的方法中，可将这个方法分成多个小方法，再分别进行测试。\n在确定最简单的测试用例的过程中，常常能够发现导致 bug 的线索。例如，如果你发现程序在数组包含偶数个元素时没问题，但包含奇数个元素时出现问题，这可能就获得了找出原因的线索。\n重新组织程序可帮助你找出微妙的 bug。如果修改程序时发现，原本以为这样的修改不会有任何影响，但结果并非如此，这便透露出了蛛丝马迹。\nC.3　逻辑错误\nC.3.1　程序不管用\n逻辑错误难以发现，因为编译器和解释器不会提供有关这种错误的任何信息。只有知道程序该如何做时，你才能知道程序没有这样做。\n首先，你需要在代码和程序的实际行为之间建立联系。你需要就程序的实际行为作出假设。下面是你需要回答的一些问题。\n存在程序该做却没有做的事情吗？找出执行这项功能的代码片段，确定它在你认为该执行的时候执行了。参见前面的“执行流程”一节。\n出现了原本不该发生的事情吗？在程序中找到执行这项功能的代码，看看它是不是在不该执行的时候执行了。\n是否存在带来意外影响的代码片段？确保你搞明白了这些代码，尤其是调用了 Java 库中的方法时。阅读这些方法的相关文档，并用简单的测试用例来尝试使用它们。它们的功能可能不是你想的那样。\n要编写程序，你需要建立有关代码行为的心理模型。如果代码的行为不符合预期，有问题的可能不是程序，而是你的心理模型。\n要想校正你的心理模型，最佳的方式是将程序分成多个部分（通常是类和方法），再分别测试它们。一旦找出心理模型与实际情况的偏差，你就能把问题给解决了。\n下面是需要检查的一些常见逻辑错误。\ndouble\n==\nif(d == 1.23)\nif(Math.abs(d - 1.23)< .000001)\n==\nequals\nequals\n继承可能带来微妙的逻辑错误，因为你可能在不知不觉间运行了继承而来的代码。请参阅前面的“执行流程”一节。\nC.3.2　冗长表达式的结果出乎意料\n你完全可以编写复杂的表达式，只要它们易于理解，但调试起来可能很麻烦。通常而言，最好将复杂表达式分解成一系列给临时变量赋值的赋值语句。\nrect.setLocation(rect.getLocation().translate(\r\n                 -rect.getWidth(), -rect.getHeight()));\n前面的示例可重写为下面这样：\nint dx = -rect.getWidth();\r\nint dy = -rect.getHeight();\r\nPoint location = rect.getLocation();\r\nPoint newLocation = location.translate(dx, dy);\r\nrect.setLocation(newLocation);\n第二个版本更容易理解，这要部分归功于变量名提供了额外的说明。这个版本调试起来也更容易，因为你可以检查临时变量的类型并显示它们的值。\nx\ndouble y = x / 2 * Math.PI;\nx\n如果你对运算顺序没有把握，可查看相关文档，也可用括号来明确地指定。\ndouble y = x / (2 * Math.PI);\n这个版本是正确的，对不记得运算顺序的人来说也更容易理解。\nC.3.3　方法的返回值出乎意料\n如果你在返回语句中包含复杂的表达式，就根本没有机会在返回前显示这个表达式的值。\npublic Rectangle intersection(Rectangle a, Rectangle b) {\r\n    return new Rectangle(\r\n        Math.min(a.x, b.x), Math.min(a.y, b.y),\r\n        Math.max(a.x + a.width, b.x + b.width)\r\n            - Math.min(a.x, b.x)\r\n        Math.max(a.y + a.height, b.y + b.height)\r\n            - Math.min(a.y, b.y));\r\n}\n不应将整个表达式放在一条语句中，而应使用一系列临时变量：\npublic Rectangle intersection(Rectangle a, Rectangle b) {\r\n    int x1 = Math.min(a.x, b.x);\r\n    int y2 = Math.min(a.y, b.y);\r\n    int x2 = Math.max(a.x + a.width, b.x + b.width);\r\n    int y2 = Math.max(a.y + a.height, b.y + b.height);\r\n    Rectangle rect = new Rectangle(x1, y1, x2 - x1, y2 - y1);\r\n    return rect;\r\n}\nx1\ny1\nC.3.4　打印语句什么都不显示\nprintln\nprint\nprint\nprintln\nC.3.5　陷入了绝境，无法自拔\n首先，离开计算机一会儿。计算机发射的电波会影响人的大脑，让人出现如下症状：\n气馁和愤怒；\n怪异的想法（“计算机讨厌我。”）和迷信（“这个程序只在我将帽子反戴时才能正确地运行。”）；\n酸葡萄心理（“这个程序真不怎样。”）。\n如果你出现了上述任何症状，赶快起来走一走。冷静下来后再来研究程序。程序当前的行为是什么样的？导致这种行为的原因可能是什么？程序最后一次正确地运行之后，你都做了些什么？\n找出有些 bug 就是需要时间。人在放松时常常容易找出 bug，如坐公交车、洗澡和躺在床上时。\nC.3.6　必须得有人帮我\n每个人都会遇到这样的情况，即便是最优秀的程序员，也有陷入困境的时候。有时候，你需要别人的帮助。\n找人帮忙前，务必尝试本附录介绍的所有方法。\n你的程序应尽可能简单，并使用尽可能简单的输入来引发错误；你应在合适的地方添加打印语句，且这些语句的输出应易于理解；你对问题有足够的了解，能够简练地进行描述。\n帮忙的人来了后，向他们提供所需的信息。\nbug 是什么类型的？编译时错误、运行时错误还是逻辑错误？\n这种错误发生前，你做了什么？你最后编写的是哪些代码行？或者哪个测试用例未通过？\n如果错误发生在编译时或运行时，显示的是什么错误消息？它指出程序的什么地方有问题？\n你采取了哪些措施？得出了什么样的结论？\n等你向人说明完问题时，你可能已经找到了答案。鉴于这种现象非常普遍，有人推荐使用“橡皮鸭调试法”。这种调试法的步骤如下。\n(1) 买个标准款橡皮鸭。\n(2) 当你面对问题无计可施时，将橡皮鸭放在前面的桌子上，并对它说，“橡皮鸭，我深陷困境，情况是这样的……”。\n(3) 向橡皮鸭描述面临的问题。\n(4) 发现解决方案。\n(5) 向橡皮鸭致谢。\nhttps://en.wikipedia.org/wiki/Rubber-duck-debugging\nC.3.7　终于找到bug了！\nbug 找到后，如何修复通常来说是显而易见的，但并非总是如此。有些看起来是 bug 的东西其实表明你没有理解程序或你使用的算法有问题。在这种情况下，你可能需要重新审视算法或调整心理模型。可暂时离开计算机，理清思路、手工执行测试用例或绘制计算图。\n修复 bug 后，不要立即投入到再造新 bug 的编程过程中。花点时间想想这是什么样的 bug、你为何会犯这样的错误、这种错误有何特征以及如何更快地找出它。这样的话，再遇到类似的情况时，你就能更快找到 bug，乃至再也不让这样的 bug 出现。\n作者简介\nAllen B. Downey 是欧林学院的计算机教授。曾任教于韦尔斯利女子学院、科尔比学院和加州大学伯克利分校，拥有加州大学伯克利分校计算机博士学位以及麻省理工学院学士和硕士学位。\nChris Mayfield 是詹姆斯麦迪逊大学的计算机助理教授，致力于计算机教育和职业发展的研究；拥有普渡大学计算机博士学位以及犹他大学计算机和德语学士学位。\n封面简介\n本书封面上的动物为红尾黑凤头鹦鹉，也叫班克斯黑凤头鹦鹉——这是以 18 世纪的英国植物学家约瑟夫 · 班克斯命名的。这种大型鸟类分布在澳大利亚，栖息于森林、草原和河岸等众多地方，通常在桉树上筑巢。\n顾名思义，红尾黑凤头鹦鹉的羽毛为黑色，只有雄鸟的尾部有鲜艳的红色斑纹。这种鸟类长约 2 英尺，重 1~2 磅。与其他黑凤头鹦鹉科鸟类一样，红尾黑凤头鹦鹉的喙庞大并呈流线型，头上有羽冠，脚上有四个脚趾——两个向前、两个向后，因此能够用一只脚抓住树枝，另一只脚抓住其他物体。有趣的是，红尾黑凤头鹦鹉大多惯用左脚。\n红尾黑凤头鹦鹉主要以桉树的种子为食，偶尔也吃些坚果、水果、昆虫和谷物。这种鸟类会成群地在食物丰富的地方飞翔，发出的声音极大，但在人前通常非常胆怯。\n红尾黑凤头鹦鹉在森林中筑巢和觅食，因此易受滥砍滥伐的影响；在澳大利亚东南部，滥砍滥伐已经让一些红尾黑凤头鹦鹉面临生存威胁。另外，虽然在澳大利亚饲养红尾黑凤头鹦鹉必须有专门的许可证，但它们依然受到非法走私的威胁。因为这种鸟类被圈养时能够活很长时间，所以需求非常旺盛。\nanimals.oreilly.com\nWood's Illustrated Natural History\n看完了\n如果您对本书内容有疑问，可发邮件至contact@turingbook.com，会有编辑或作译者协助答疑。也可访问图灵社区，参与本书讨论。\n如果是有关电子书的建议或问题，请联系专用客服邮箱：ebook@turingbook.com。\n在这里可以找到我们：\n微博 @图灵教育 : 好书、活动每日播报\n微博 @图灵社区 : 电子书和好文章的消息\n微博 @图灵新知 : 图灵教育的科普小组\n微信 图灵访谈 : ituring_interview，讲述码农精彩人生\n微信 图灵教育 : turingbooks 　　\n091507240605ToBeReplacedWithUserId\n",
  "factionName": "Java编程思维",
  "newest": 10,
  "comments": [],
  "source": [],
  "index": "2"
},{
  "_id": "0019ea08-2aae-4e2e-9799-be94376e1c41",
  "headerImage": "https://wk-gulimall.oss-cn-beijing.aliyuncs.com/ProgramBook/201a17c5-2853-47cb-871a-d01a0a1e0c88.jpg",
  "updateTime": {
    "$date": "2023-01-23T17:00:42.351Z"
  },
  "author": "刘遄",
  "des": "本书作者刘遄（Liu Chuán）从事于Linux运维技术行业，高中时期便因兴趣的驱使而较早地接触到了Linux系统并开始学习运维技术，并且在2012年获得红帽工程师RHCE 6版本证书，在2015年初又分别获得红帽工程师RHCE 7版本证书与红帽架构师认证RHCA顶级证书。\n尽管如此，但依然深知水平有限且技术一般，若不是得益于良师益友的无私帮助，肯定不能如此顺利地取得上述成绩。并且，作为一名普通的技术人，我亲身经历过半夜还在培训班的心酸，体验过拥堵6小时车程的无奈，也翻看过市面上十几本如同嚼蜡般的Linux技术书籍，这让我更加坚定了写作本书的信念。此刻，我正是怀揣着一颗忐忑的心，尽自己最大的努力把有用的知识分享给读者，希望你们能够少走一些弯路，更快地入门Linux系统。\n窃以为，一名技术高超的导师不应该仅仅是技术的搬运工，而应该是优质知识的提炼者，所以在写作本书的过程中，我不希望也不会将自己了解掌握的所有技术知识都写到书里，借此来炫技，而是从真正贴近于新人学习特点的角度出发，主动摒弃了不实用的部分，并把重点、难点反复实践，以加深读者对理论基础的理解，并彻底掌握生产环境中用到的技术内容。\n本书基于最新的Linux系统RHEL 7编写而成，而且配套软件及资料完全免费，课程面向Linux新手。本书会从零基础带领读者入门Linux系统，然后渐进式地提高内容难度，使其匹配生产环境对运维人员的要求。而且，本书每章都配套有大量的图、表、命令示例以及课后习题，以达到增强读者学习兴趣与加深记忆的效果。最后，本书以及配套资源相较于当前的RHCE培训，至少要多出40%的内容，只要您能每天坚持学习，相信这绝对是您体验最佳、进步最快的一次学习经历。\n最后想说的是，我的写作初心其实并不高雅，只是在还债，还十几年来中国有如此多的培训机构赚了那么多钱，但却没有培训机构真正给学员提供一本好教材的债，而这应该是我们的学员早就应该享受的服务，不能再选择性失明了。而到了2017年，我的写作初衷也融入了一点小私心，除了运营好《Linux就该这么学》图书的在线学习网站http://www.linuxprobe. com/，服务更多的学员和读者之外，还要把我们的免费开源图书做到远超其他培训机构收费教材的水平，并坚持做中国开源站点的道德典范，不欺骗，不作恶，保持最纯净的技术交流环境，而我们想要得到的也很简单——如果您认可了刘遄老师的付出并满意我们的服务，还请把本书告诉身边的朋友，让更多的人知道我们在做的这件很酷的事。\n学习是件苦差事\n我不想回避这个问题——学习是件痛苦的事情。如果说学习Linux真的很简单，那必是骗子的谎言，起码这不能给您带来高薪。在每次起床后的几分钟时间里，大脑都会陷入斗争状态——是该聊会天呢，还是要追个美剧呢，还是打一局英雄联盟呢，还是看一下那该死的刘遄写的那本可怕的Linux教材呢？这个时候，请不要忘记自己最初的梦想。十年后的你，一定会感激现在拼命努力学习的自己。身为作者，我的使命就是让本书对得起你为此花费的时间、精力和金钱，让你每学完一个章节都是一次进步。\n稻盛和夫先生在《活法》中有段一直激励着我的话，现在转送给正在阅读本书的你：\n“工作马马虎虎，只想在兴趣和游戏中寻觅快活，充其量只能获得一时的快感，绝不能尝到从心底涌出的惊喜和快乐，但来自工作的喜悦并不像糖果那样——放进嘴里就甜味十足，而是需要从苦劳与艰辛中渗出，因此当我们聚精会神，孜孜不倦，克服艰辛后的成就感，世上没有哪种喜悦可以类比”。\n“更何况人类生活中工作占据了较大的比重，如果不能从劳动中、工作中获得充实感，那么即使从别的地方找到快乐，最终我们仍然会感到空虚和缺憾”。\n开源共享精神\n简单来说，开源软件的特点就是把软件程序与源代码文件一起打包提供给用户，让用户在不受限制地使用某个软件功能的基础上还可以按需进行修改，或编制成衍生产品再发布出去。用户具有使用自由、修改自由、重新发布自由以及创建衍生品的自由。这也正好符合了黑客和极客对自由的追求，因此国内外开源社区的根基都很庞大，人气也相当高。\n坦白来讲，每位投身于Linux行业的技术人或者程序员只要听到开源项目就会由衷地感到自豪，这是一种从骨子里带有的独特情怀。开源的企业不单纯是为了利益，而是互相扶持，努力服务好更多的用户。开源软件最重要的特性有下面这些。\n低风险：\n高品质：\n低成本：\n更透明：\n但是，如果开源软件为了单纯追求“自由”而牺牲程序员的利益，这将会影响程序员的创造激情，因此世界上现在有60多种被开源促进组织（Open Source Initiative）认可的开源许可协议来保证开源工作者的权益。对于那些只知道一味抄袭、篡改、破解或者盗版他人作品的不法之徒，终归会在某一天收到法院的传票。对于准备编写一款开源软件的开发人员，也非常建议先了解一下当前最热门的开源许可协议，选择一个合适的开源许可协议来最大限度保护自己的软件权益。\nGNU GPL（GNU General Public License，GNU通用公共许可证）：\n复制自由：\n传播自由：\n收费传播：\n修改自由：\nBSD（Berkeley Software Distribution，伯克利软件发布版）许可协议：\n如果再发布的软件中包含源代码，则源代码必须继续遵循BSD许可协议。\n如果再发布的软件中只有二进制程序，则需要在相关文档或版权文件中声明原始代码遵循了BSD协议。\n不允许用原始软件的名字、作者名字或机构名称进行市场推广。\nApache许可证版本（Apache License Version）许可协议：\n该软件及其衍生品必须继续使用Apache许可协议。\n如果修改了程序源代码，需要在文档中进行声明。\n若软件是基于他人的源代码编写而成的，则需要保留原始代码的协议、商标、专利声明及其他原作者声明的内容信息。\n如果再发布的软件中有声明文件，则需在此文件中标注Apache许可协议及其他许可协议。\nMPL（Mozilla Public License，Mozilla公共许可）许可协议：\nMIT（Massachusetts Institute of Technology）许可协议：\n为什么学习Linux系统\n早在20世纪70年代，UNIX系统是开源而且免费的。但是在1979年时，AT&T公司宣布了对UNIX系统的商业化计划，随之开源软件业转变成了版权式软件产业，源代码被当作商业机密，成为专利产品，人们再也不能自由地享受科技成果。\n于是在1984年，Richard Stallman面对于如此封闭的软件创作环境，发起了GNU源代码开放计划并制定了著名的GPL许可协议。1987年时，GNU计划获得了一项重大突破——gcc编译器发布，这使得程序员可以基于该编译器编写出属于自己的开源软件。随之，在1991年10月，芬兰赫尔辛基大学的在校生Linus Torvalds编写了一款名为Linux的操作系统。该系统因其较高的代码质量且基于GNU GPL许可协议的开放源代码特性，迅速得到了GNU计划和一大批黑客程序员的支持。随后Linux系统便进入了如火如荼的发展阶段。\n1994年1月，Bob Young在Linux系统内核的基础之上，集成了众多的源代码和程序软件，发布了红帽系统并开始出售技术服务，这进一步推动了Linux系统的普及。1998年以后，随着GNU源代码开放计划和Linux系统的继续火热，以IBM和Intel为首的多家IT企业巨头开始大力推动开放源代码软件的发展。到了2017年年底，Linux内核已经发展到了4.13版本，并且Linux系统版本也有数百个之多，但它们依然都使用Linus Torvalds开发、维护的Linux系统内核。RedHat公司也成为了开源行业及Linux系统的带头公司。\n在讲课时，我经常会问同学们一个问题：“为什么学习Linux系统？”很多学生为了让我高兴，直接就说“因为Linux系统是开源的，所以要去学习”。其实这个想法是完全错误的！开源的操作系统少说有100个，开源的软件至少也有十万个，为什么不去逐个学习？所以上面谈到的开源特性只是一部分优势，并不足以成为您付出精力去努力学习的理由。\n对于用户来讲，开源精神仅具备锦上添花的效果，因此正确的学习动力应该源自于：Linux系统是一款优秀的软件产品，具有类似UNIX的程序界面，而且继承了UNIX的稳定性，能够较好地满足工作需求。\n大多数读者应该都是从微软的Windows系统开始了解计算机和网络的，因此肯定会有这样的想法“Windows系统很好用啊，而且也可足以满足日常工作需求呀”。客观来讲，Windows系统确实很优秀，但是在安全性、高可用性与高性能方面却难以让人满意。您应该见过下面这张图片。\n想必读者现在已经能猜到，为什么要在需要长期稳定运行的网站服务器上、在处理大数据的集群系统中以及需要协同工作的环境中采用Linux系统了。通过下图也可以看出Linux系统相较于Windows系统的具体优势。\n常见的Linux系统版本\n在介绍常见的Linux系统版本之前，首先需要区分Linux系统内核与Linux发行套件系统的不同。\nLinux系统内核指的是一个由Linus Torvalds负责维护，提供硬件抽象层、硬盘及文件系统控制及多任务功能的系统核心程序。\nLinux发行套件系统是我们常说的Linux操作系统，也即是由Linux内核与各种常用软件的集合产品。\n全球大约有数百款的Linux系统版本，每个系统版本都有自己的特性和目标人群，下面将可以从用户的角度选出最热门的几款进行介绍。\n注：\n　\n本书全篇将以“Linux系统”来替代“Linux发行套件系统”这个词。\n红帽企业版Linux（RedHat Enterprise Linux，RHEL）\n社区企业操作系统（Community Enterprise Operating System，CentOS）：\nFedora：\nopenSUSE：\nGentoo：\nDebian：\nUbuntu：\n现在国内大多数Linux相关的图书都是围绕CentOS系统编写的，作者大多也会给出围绕CentOS进行写作的一系列理由，但是很多理由都站不住脚，根本没有剖析到CentOS系统与RHEL系统的本质关系。CentOS系统是通过把RHEL系统释放出的程序源代码经过二次编译之后生成的一种Linux系统，其命令操作和服务配置方法与RHEL完全相同，但是去掉了很多收费的服务套件功能，而且还不提供任何形式的技术支持，出现问题后只能由运维人员自己解决。经过这般分析基本上可以判断出，选择CentOS的理由只剩下——免费！当人们大举免费、开源、正义的旗帜来宣扬CentOS系统的时候，殊不知CentOS系统其实早在2014年年初就已经被红帽公司“收编”，当前只是战略性的免费而已。再者说，根据GNU GPL许可协议，我们同样也可以免费使用RHEL系统，甚至是修改其代码创建衍生产品。开源系统在自由程度上没有任何差异，更无关道德问题。\n本书是基于最新的RHEL 7系统编写的，书中内容及实验完全通用于CentOS、Fedora等系统。也就是说，当您学完本书后，即便公司内的生产环境部署的是CentOS系统，也照样可以搞得定。更重要的是，本书配套资料中的ISO镜像与红帽RHCSA及RHCE考试基本保持一致，因此更适合备考红帽认证的考生使用。\n随书配备的ISO镜像文件下载地址：http://www.linuxprobe.com/tools\n深度评解红帽RHCSA、RHCE、RHCA认证：http://www.linuxprobe.com/redhat-certificate\n优秀的RHEL 7系统\n注：\n　\n本小节的内容是我在2015年写给学员的一篇文章，现在RHEL 7系统已经经过近三年的迭代更新，此时再回看这篇文章，发现我的预测还是很准确吧。当前，国内大多数机房都已经部署了RHEL 7系统，国内外多家银行机构、保险公司系统也纷纷上线CentOS 7或RHEL 7系统，但我依然想引用这篇文章来帮助读者了解RHEL 7系统，而且我也深信这篇文章同样也会适用于未来的RHEL 8系统。\n2014年年末，RedHat公司推出了当前最新的企业版Linux系统——RHEL 7，彼时国内外各大媒体都给了不少特写镜头，行业也给予了硕大的期待。但是，时至今日RHEL 7系统的市场占有率却一直不温不火，于是有人开始对RHEL 7系统的未来表示担心，甚至有人还拿出各种论调来唱衰Linux系统，觉得开源厂商已经过了事业最高点，要在服务器领域让步于Windows系统了。这些话其实并没必要去反驳，任何一个产品都会有其拥趸和黑粉，时间会向所有人证明一切。我们现在只是来单纯地聊一聊这个RHEL 7系统。\n在正式开聊之前，希望读者对Linux系统特性和运维领域有基本的了解，知道Linux系统在服务器领域中占据着不可小觑的市场份额，认识到RedHat厂商对Linux系统及整个开源行业的重要影响，更知道CentOS系统其实是RHEL系统的衍生品。如果以前使用过一段时间的RHEL 7系统，我们就更能顺畅地讨论“红帽Linux系统是否是一个失败的产品”这个问题。\n我们先来看一个烫手的热议问题：“为什么半年过去了，RHEL 7系统的市场份额依然不温不火？要不要返回去学习老版本的Linux系统？”甚至有阴谋论说美国在使用新版本的Linux系统来搜集全球信息，告诫我们千万不要去碰。这个问题必须要回应，否则更多的阴谋论会层出不穷，甚至会让国内某些认知能力欠缺的媒体对开源行业产生误解甚至曲解。\n基于前面提到的与读者共有的经验共识和篇幅限制，下面的论证速度会比较快，也会很有意思。首先，RHEL是企业版的服务器系统而不是用来玩耍折腾的桌面机系统，更何况作为桌面操作系统的Windows 7在2009年7月14日发布之后，整整用了3年才开始真正普及，难道在2009年到2013年间，Windows 7就是失败的产品吗？再者，RHEL 7系统创新式地集成了Docker虚拟化技术，支持XFS文件系统，兼容微软的身份管理，并采用systemd作为系统初始化进程，其性能和兼容性相较于之前版本都有了很大的改善，很明显是一款非常优秀的操作系统。最后，其实单从纳入OpenStack和Docker的决策上来讲，就应该相信红帽的开发团队不是在闭门造车。因此应该重新考虑到底是哪里出了问题。\n运维人员在心里经常会想：“现在的环境跑得好好的，为什么要换呢？”重新部署生产环境不是说装上操作系统万事大吉，也不是把软件随便安装上就能拍屁股走人的，还要考虑升级带来的风险。\n日后的生产环境出了问题，谁来负责？\n旧的软件依然能否与新系统兼容？\n新的系统或软件是否有bug？\n安全性如何，审计怎么做？\n之前购买的第三方技术支持是否可以具备相应的能力？\n升级后是否会影响到某些软件的版权，是否需要重新付费？\n不习惯新系统带来的变化怎么办？\n费力升级后对自己有什么好处？\n……\n客观来讲，这次RHEL 7系统的改变实在太大，最重要的是它采用了systemd作为初始化进程。这样一来，几乎之前所有的运维自动化脚本都需要修改。那么，到底还要不要升级到RHEL 7？当然，也不是说服务器机房中的生产环境从不更新换代，当工作需求超过了当前版本的能力范围时，就必须要进行升级。比如，rsyslogd日志记录服务在RHEL 6系统中的版本是5.8，而现在最新的版本已经是8.1。这两个版本之间差了3个大的主版本号，其功能就有了很大的差距，您觉得会一直用旧的版本吗？\n早在2014年年初，Fedora系统首次采用了systemd系统初始化进程，当时我就断言RHEL 7系统也会使用systemd，所以当即更新了自己的培训课程。这也让身在其他培训机构还在学习init参数的用户新生艳羡。所以，不论是学习Linux还是编程语言，都应该选择当前稳定且最新的版本作为学习环境。\n稳定：\n最新：\n我每次在公开场合讲座时都会表达这样一个观点：“我们并不是因为开源而喜欢Linux，而是因为Linux系统真的非常优秀，开源精神仅仅是锦上添花而已。”我们在前文中已经狠狠地肯定了Linux系统对运维行业甚至是对世界的影响。大家要做的就是去相信我对运维行业未来发展的判断，然后放手来学习吧。\n了解红帽认证\n红帽公司成立于1993年，是全球首家收入超10亿美元的开源公司，总部位于美国，分支机构遍布全球。红帽公司作为全球领先的开源和Linux系统提供商，其产品已被业界广泛认可并使用，尤其是RHEL系统在业内拥有超高的Linux系统市场占有率。红帽公司除了提供操作系统之外，还提供了虚拟化、中间件、应用程序、管理和面向服务架构的解决方案。\n红帽认证是由红帽公司推出的Linux认证，该认证被认为是Linux行业乃至整个IT领域价值最高的认证之一。红帽认证考试全部采用上机形式，在考察学生基础理论能力的同时还考察了实践动手操作以及排错能力。红帽公司针对红帽认证制定了完善的专业评估与认证标准，其认证主要包括红帽认证系统管理员（RHCSA）、红帽认证工程师（RHCE）与红帽认证架构师（RHCA）。\n2014年6月10日，红帽公司在发布新版红帽企业版系统（RHEL 7）的当天即在红帽英文官网更新了其对RHCSA与RHCE培训政策的调整，考生只有先通过红帽RHCSA认证后才能考取红帽RHCE认证。\n红帽认证进阶等级图\n红帽认证系统管理员（Red Hat Certified System Administrator，RHCSA）属于Linux系统的初级认证，比较适合Linux爱好者。该认证要求考生对Linux系统有一定的了解，并且能够熟练使用Linux命令来完成以下任务：\n管理文件、目录、文档以及命令行环境；\n使用分区、LVM逻辑卷管理本地存储；\n安装、更新、维护、配置系统与核心服务；\n熟练创建、修改、删除用户与用户组，并使用LDAP进行集中目录身份认证；\n熟练配置防火墙以及SELinux来保障系统安全。\n红帽认证管理员（RHCSA）证书示例\n红帽认证工程师（Red Hat Certified Engineer，RHCE）属于Linux系统的中级水平认证，难度相对RHCSA认证来讲更大，而且要求考生必须已获得RHCSA认证。该认证适合有基础的Linux运维管理员，主要考察对下列服务的管理与配置能力：\n熟练配置防火墙规则链与SElinux安全上下文；\n配置iSCSI（互联网小型计算机系统接口）服务；\n编写Shell脚本来批量创建用户、自动完成系统的维护任务；\n配置HTTP/HTTPS网络服务；\n配置FTP服务；\n配置NFS服务；\n配置SMB服务；\n配置SMTP服务；\n配置SSH服务；\n配置NTP服务。\n红帽认证工程师（RHCE）证书示例\n红帽认证架构师（Red Hat Certified Architect，RHCA）属于Linux系统的最高级别认证，是公认的Linux操作系统顶级认证，目前中国仅有不到1000人（2017年更新数据）持有该认证。考生需要在获得RHCSA与RHCE认证后再完成5门课程的考试才能获得RHCA认证，因此难度最大，备考时间最长，费用也最高（考试费约在1.8万元～2.1万元人民币）。该认证考察的是考生对红帽卫星服务、红帽系统集群、红帽虚拟化、系统性能调优以及红帽云系统的安装搭建与维护能力。\n红帽认证架构师（RHCA）证书示例\nRHCA高分技巧\n红帽RHEL 7版本的RHCA认证需要完成至少5门考试。这5门考试的时间不同，但均为210分合格（70%）。而且红帽公司非常注重RHCA架构师认证的实用性，所以课程总是在随行业趋势而不断调整。\n下表为2017年最新版的考试课程。欲取得红帽RHCA认证，您必须通过以下任意5门认证考试。\n考试代码\n认证名称\nEX210\n红帽 OpenStack 认证系统管理员考试\nEX220\n红帽混合云管理专业技能证书考试\nEX236\n红帽混合云存储专业技能证书考试\nEX248\n红帽认证 JBoss 管理员考试\nEX280\n红帽平台即服务专业技能证书考试\nEX318\n红帽认证虚拟化管理员考试\nEX401\n红帽部署和系统管理专业技能证书考试\nEX413\n红帽服务器固化专业技能证书考试\nEX436\n红帽集群和存储管理专业技能证书考试\nEX442\n红帽性能调优专业技能证书考试\n本书组织结构\n第1章，部署虚拟环境安装Linux系统：\n第2章，新手必须掌握的Linux命令：\n第3章，管道符、重定向与环境变量：\n第4章，Vim编辑器与Shell命令脚本：\n第5章，用户身份与文件权限：\n第6章，存储结构与磁盘划分：\n第7章，使用RAID与LVM磁盘阵列技术：\n第8章，iptables与firewalld防火墙：\n第9章，使用ssh服务管理远程主机：\n第10章，使用Apache服务部署静态网站：\n第11章，使用vsftpd服务传输文件：\n第12章，使用Samba或NFS实现文件共享：\n第13章，使用BIND提供域名解析服务\n第14章，使用DHCP动态管理主机地址：\n第15章，使用Postifx与Dovecot部署邮件系统：\n第16章，使用Squid部署代理缓存服务：\n第17章，使用iSCSI服务部署网络存储：\n第18章，使用MariaDB数据库管理系统：\n第19章，使用PXE+Kickstart无人值守安装服务：\n第20章，使用LNMP架构部署动态网站环境：\n感谢你们相信并选择我\n首先，感谢广大读者从众多Linux图书中最终选择了本书，感谢你们的厚爱与信任。相信本书不会让你们失望的。\n其次，感谢跟随刘遄老师一起努力打拼的各位成员，他们是（以加入团队时间排序）：逄增宝、岳永、张宏宇、冯琪、黄烨婧、冯振华、张振宇、唐资富、刘峰、王辉、苏西云、李帅、陶武杰、王浩、郭建鹏、周晓雪、郝大发、倪家兴、郑帅、姜显赫、高军、王毅、任维国、张雄、周阳、程伟、任倩倩、吴向平、华世发。感谢你们相信我，为了我们共同的事业而奋勇向前，如果没有你们的帮助和支持，就不会有现在的成绩。在过去两年中，我们从一个每天只有十几人次访问的小博客，发展到了每天将近一万人次访问的公众站点；在两年内更是接连开通了近30个QQ技术交流群，群内读者已超过5万人；微信公众号也从0做到了10万粉丝，这些都是此前中国任何一本技术类电子图书没有达到的高度和成就。尤其在最近一年，我们的发展速度远远领先于同行业所有的资讯网站和教育机构，优质图书内容与读者口碑让我们走的每一步都如此扎实。现在我们可以很自豪地讲：“我们用努力留住了用户，用户看到了我们的付出。”\n再次，感谢人民邮电出版社的傅道坤编辑。我们在2015年末初次接触后傅老师便主动提起出版本书的想法，随后一起用了近2年的时间共同打磨本书。感谢傅老师一直以来给予的信任和中肯实用的建议。感谢北京联合大学应用科技学院王廷梅院长在我研究生进修教育学期间的照顾和悉心培育，是您引导我步入了教育学和计算机科学与技术专业。不忘母校，不忘联大。\n最后也是最重要的，感谢我的父母和妻子。当我在2015年说想要写一本Linux技术图书的时候，感谢你们相信了我。感谢我的妻子能够理解我的压力，一起来协助管理在线培训班及招生工作，让我有了更多的时间来写作。如果没有你们的信任和陪伴，我不敢想象自己现在会是什么样子。\n读者服务\n本书是一本注重实用性的Linux技术自学图书，自电子版公布后日均阅读量近万次。本书以及后续的进阶篇图书将继续一如既往地免费、完整地提供给各位读者。当前，我们正在世界各地部署图书配套站点的镜像服务器，旨在用最快的网站响应速度满足您心中那个求知的小宇宙。此外，我们的团队成员在完善、更新本书内容以及配套软件的同时，还将为您收集、整理值得每天一看的“新闻资讯”和“技术干货”。当然，也欢迎您到我们的QQ技术群（http://www.linuxprobe.com/club）中寻找技术大牛！\n而这一切的便利与服务，只差您现在的一个选择，赶紧拿起手机扫描下面的微信二维码吧。\n",
  "factionName": "Linux就该这么学",
  "newest": 10,
  "comments": [],
  "source": [],
  "index": "5"
},{
  "_id": "56f59a08-23b7-4c71-95f4-6f7543dc4ce0",
  "headerImage": "https://wk-gulimall.oss-cn-beijing.aliyuncs.com/ProgramBook/43ad0994-1549-48ef-ab8f-e2e31890ca5b.jpg",
  "updateTime": {
    "$date": "2023-01-23T17:00:43.524Z"
  },
  "author": "陆凌牛",
  "des": "近年来，随着智能手机与HTML 5的不断普及，JavaScript脚本语言的重要性也随之不断提升，IT业界涌现了大量学习与善用JavaScript脚本语言的工程师，其中许多工程师对任何服务器端开发语言均一无所知。很多工程师提出，如果能够让服务器端与客户端均使用一种脚本语言，则无疑可以减少服务器端的开发难度，提高服务器端的开发效率。另一方面，由于近几年许多JavaScript引擎中均内置了JIT（Just In Time）编译器，使JavaScript引擎的处理速度得到了大幅度提高，JavaScript脚本语言的运行速度不会逊色于任何服务器端开发语言。\n据此现状，2009年8月，IT业界制定了CommonJS标准，用于标准化服务器端JavaScript脚本语言，制定服务器端JavaScript脚本语言中所需要实现的处理。\n同年，美国人Ryan Dahl推出了第一个遵循CommonJS标准的服务器端JavaScript脚本语言开发框架——Node.js。在Node.js内部，运行的是Google开发的高性能V8JavaScript脚本语言，该语言可以运行在服务器端。Node.js的一个最重要的特性是通过单线程实现异步处理环境。通常，提及异步处理，开发者们首先会联想到的是服务器端多线程环境，在Node.js中，通过事件环与非阻塞型I/O机制实现服务器端的异步处理。\n为了帮助国内的Web开发者更好地学习Node.js开发框架，笔者特此推出本书，希望国内的Web开发者们能够通过学习本书尽早地运用Node.js框架开发出高效的Web服务器以及运行于该Web服务器中的Web应用程序。\n读者对象\n根据不同使用需要，本书适用于如下读者：\n·对Web网站或Web应用程序的开发技术感兴趣或者打算从事Web网站或Web应用程序开发的技术人员。\n·Web网站或Web应用程序的开发者（包括Web前端开发工程师及后端开发工程师）。\n·有关Web网站或Web应用程序开发项目的项目管理人员。\n·开设相关课程的大专院校及培训机构。\n如何阅读本书\n本书内容分三大部分展开。\n第一部分：\n第二部分：\n第三部分：\n在本书的每一章中，每一个正在阐述的理论点均使用代码实例进行具体形象地说明，每个实例中所涉及的理论知识都以通俗易懂的语言进行阐述，大部分实例均使用图片来形象说明该实例的运行效果。本书所有实例代码都经笔者亲自测试运行成功，提供给读者学习使用。每个实例的详细代码及其使用到的脚本文件、各种资源文件都可在华章公司网站（www.hzbook.com）的本书页面上下载。读者可以对这些代码进行修改，以便观察各种不同效果，加深对实例代码的理解。\n勘误和支持\n由于时间及水平方面的原因，书中难免会出现一些错误或者不准确的地方，恳请读者批评指正。笔者QQ号码为240824399，联系邮箱为240824399@qq.com。欢迎读者通过QQ或E-mail与笔者联系，真诚期待能够听到读者的反馈意见。\n致谢\n感谢机械工业出版社华章公司的编辑杨福川和姜影，感谢杨福川老师的魄力和远见，感谢姜影老师的细心编辑与校对，感谢二人在这半年多的时间中始终支持我的写作，是他们的鼓励和帮助引导我顺利完成全部书稿。\n谨以此书献给众多热爱Node.js开发框架的朋友们，以及中国IT界从事Web网站及Web应用程序开发的全体同行。\n",
  "factionName": "Node.js权威指南",
  "newest": 10,
  "comments": [],
  "source": [],
  "index": "4"
},{
  "_id": "35e3c3ce-f2ce-49b2-9c8c-73a168d5ca64",
  "headerImage": "https://wk-gulimall.oss-cn-beijing.aliyuncs.com/ProgramBook/e5a00029-11be-4a57-b983-1d274cdc7022.jpg",
  "updateTime": {
    "$date": "2023-01-23T17:00:44.928Z"
  },
  "author": "刘宇宙,",
  "des": "什么是Python，你为什么要使用它？\nPython是一种解释型的、面向对象的、带有动态语义的高级程序设计语言。这里有很多术语，你可以在阅读本书的过程中逐渐弄懂。\nPython是一种使你在编程时能够保持自己风格的程序设计语，使用它你可以使用清晰易懂的程序来实现你想要的功能。并且如果你之前没有任何编程经历，那么既简单又强大的Python就是你入门的完美选择。\n伴随着云计算、大数据等技术的迅速崛起，市场对Python人才的需求和市场人才的匮乏，让长期沉默的Python语言一下子备受众人的关注，本书可说是应运而生，另外，目前Python广泛使用的是2.7版本，新版本Python 3.5带来了很多新特性，本书是以Python 3.5版本编写而成的，对于想学习和了解Python 3.5的使用和特性的读者，本书可以说是最佳选择。\n本书的特色\n本书专门针对Python新手量身定做，是编者学习和使用Python开发过程中的体会和经验总结，涵盖了实际开发中所有的重要知识点，内容详尽，代码可读性及可操作性强。\n本书主要介绍了Python语言的类型和对象、操作符和表达式、编程结构和控制流、函数、序列、多线程、正则表达式、面向对象编程、文件操作、网络编程、邮件收发、数据库操作等，并安排了Python爬虫、数据处理项目范例，各章还安排了调试、问题解答、温故知、牛九小试等章节实例等内容，以帮助读者学会处理程序异常、解答学习困惑、巩固知识、学以致用。\n本书的另一个特色是，使用通俗易懂的描述和丰富的示例代码，并结合日常生活中的一些小事件，使本书读起来尽可能生动有趣，让复杂的问题以简单的形式展现出来，使读者学来轻松，充分感受到学习Python的乐趣和魅力。\n本书的内容\n本书共分18章，各章内容安排如下：\n第1章主要介绍Python的起源、应用场合、前景以及Python 3相对于Python 2的一些新特性。\n第2章主要介绍Python的基础知识，为后续章节学习相关内容做铺垫。\n第3章将重点介绍列表和元组。\n第4章将重点介绍字符串的格式化、分割、搜索等方法。\n第5章将介绍字典，字典是一种通过名字引用值的数据结构。\n第6章从import语句开始介绍，然后逐步深入介绍条件语句、循环语句以及列表推导式等一些更深层次的语句。\n第7章主要介绍函数，函数是组织好的、可重复使用的，用来实现单一或相关联功能的代码段。\n第8章主要介绍Python面向对象编程的特性，Python从设计之初就是一门面向对象语言，它提供一些语言特性支持面向对象编程。\n第9章将带领读者学习如何处理各种异常，以及创建和自定义异常。\n第10章将具体讲解Python中日期和时间的使用。\n第11章主要介绍正则表达式的基本使用。\n第12章主要介绍如何使用Python在硬盘上创建、读取和保存文件。\n第13章主要介绍Python中的多线程编程。\n第14章主要介绍如何使用Python语言发送和接收邮件。\n第15章将重点介绍Python在网络编程方面的特性。\n第16章将重点介绍在Python 3.5中使用PyMySQL连接数据库，并实现简单的增、删、改、查。\n第17章将根据前面所学讲解一个爬虫的实战项目。\n第18章将结合大数据的相关思维，使用已有数据做一些简单的数据分析。\n读者对象\nPython 3.x初学者。\n想学习和了解Python的程序员。\nPython网课、培训及大专院校教学用书。\n致谢\n在本书交稿之际，感谢清华大学出版社的王金柱编辑，在本书编写的过程中，王编辑给予了很多指导和修改意见。同时感谢家人和朋友在写作期间给予的安静写作环境，让笔者不被更多琐事打扰，从而专心于写作。感谢你们，没有你们的帮助与关心，本书不能如期完成。\n技术群及问题解答方式\nPython技术服务qq群：634027520\nCSDN技术博客：youzhouliu\n技术问答email：jxgzyuzhouliu@163.com\n编者\n2017年3月\n",
  "factionName": "Python 3.5从零开始学",
  "newest": 10,
  "comments": [],
  "source": [],
  "index": "3"
},{
  "_id": "39eaf9fa-cc15-4ffb-a368-fb1fc9527f5e",
  "headerImage": "https://wk-gulimall.oss-cn-beijing.aliyuncs.com/ProgramBook/835a1ddf-2f13-4761-8d38-5288c72f57df.jpg",
  "updateTime": {
    "$date": "2023-01-23T17:00:47.626Z"
  },
  "author": "(美)Mar",
  "des": "本书是学习Python编程语言的入门书籍。Python是一种很流行的开源编程语言，可以在各种领域中用于编写独立的程序和脚本。Python免费、可移植、功能强大，而且使用起来相当容易。来自软件产业各个角落的程序员都已经发现，Python对于开发者效率和软件质量的关注，这无论在大项目还是小项目中都是一个战略性的优点。\n无论你是编程初学者，还是专业开发人员，本书的目标是让你快速掌握核心Python语言基础。阅读本书后，你会对Python有足够的了解，能够将其应用于所从事的领域中。\n本书设计成一本教程，主要关注核心Python语言本身，而不是其特定的应用程序。因此，它作为一个两卷本的合集中的第一本：\n·《Learning Python》，也就是这本书，介绍Python本身。\n·《Programming Python》，另外一本书，介绍在学习了Python之后可以用它来做什么。\n也就是说，《Programming Python》这本基于应用的图书选择了本书所省略的话题，介绍了Python在Web、图形用户界面（GUI）和数据库这样的常用领域的作用。此外，《Python Pocket Reference》一书提供了本书所没有的额外参考资料，可将它作为本书的补充。\n本书在策划之初就力求向读者展示比众多程序员初次学习这门语言的时候更深层次的话题。并且，本书基于一个带有测试和练习的3天的Python培训课程，所以可以作为该语言的一个自学教程。\n本书第4版从以下3个方面做出了修改：\n·覆盖了Python 3.0和Python 2.6，本书强调Python 3.0，但是对Python 2.6中的不同之处给出了提示。\n·包含了一些新的章节，主要介绍高级的核心语言话题。\n·重新组织了一些已有的材料，并且使用新的示例扩展它们以便更清楚。\n我在2009年撰写本书这一版时，Python分为两支——Python 3.0是新兴的版本并且不兼容地修改了该语言；Python 2.6保持与大量已有的Python代码向后兼容。尽管Python 3被视作是Python的未来，Python 2仍然使用广泛并且会在未来的几年内与Python 3并列地得到支持。尽管只是同一种语言的不同版本，但Python 3.0几乎无法运行为之前版本编写的代码（单单print从语句修改为函数，听上去更合理，但是，它几乎影响到所有已经编写好的Python程序）。\n版本的划分使得程序员和图书作者都陷入了两难的境地。尽管编写一本好像Python 2不存在而只介绍Python 3的图书很容易，但这可能无法满足大量基于已有代码的Python用户的需求。大量已有代码都是针对Python 2编写的，并且它们不会很快过时。尽管现在的初学者更关注Python 3，但如果他们必须使用过去编写的代码，那么就必须熟悉Python 2。所有的第三方库和扩展都移植到Python 3可能还需要数年时间，所以Python 2这一分支可能不完全是临时性的。\n为了解决这一分歧并且满足所有潜在读者的需求，本书的这一版更新为覆盖Python 3.0和Python 2.6（以及Python 3.X和Python 2.X系列的后续发布）。本书针对使用Python 2编程的程序员、使用Python 3的程序员，以及介于这二者之间的程序员。\n也就是说，你可以使用本书来学习任何的Python版本。尽管这里主要关注Python 3.0，但Python 2.6的不同之处和工具也都针对使用旧代码的程序员给出了提示。尽管这两个版本大部分是相同的，但它们还是在一些重要的方面有所不同，对此我将指出两者的区别。\n例如，在大多数示例中，我们使用Python 3.0的print调用，但是，我也将介绍Python 2.6的print语句，以便使你能够理解较早的代码。我还广泛地介绍了新功能，例如Python 3.0中的nonlocal语句和Python 2.6以及Python 3.0中的字符串的format方法，当较早的Python中没有这样的扩展时，我将会指出来。\n如果你初次学习Python并且不需要使用任何遗留代码，我鼓励你从Python 3.0开始，它清理了这一语言中长久以来的一些瑕疵，同时保留了所有最初的核心思想并且添加了一些漂亮的新工具。\n当你阅读本书时，很多流行的Python库和工具可能也支持Python 3.0了，特别是在未来的Python 3.1版本中，可以预期文件I/O性能会有较大的提升。如果你使用基于Python 2.X的一个系统，将会发现本书解决了你所关心的问题，并且将帮助你在未来过渡到Python 3.0。\n此外，本版也介绍了其他的Python 2和Python 3的发布版本，尽管一些旧的Python 2.X代码可能无法运行本书的所有示例。例如，尽管在Python 2.6和Python 3.0中都有类装饰器，但我们无法在还没有这一功能的旧Python 2.X中使用它。参见前言中的表0-1和表0-2，它们概括了Python 2.6和Python 3.0中的变化。\n注意：就在付梓前不久，本书中还添加了关于未来的Python 3.1版的一些突出的扩展的提示，如：字符串format方法调用中的逗号分隔符和自动字段编号、with语句中的多环境管理器语法、针对数字的新方法等。由于Python 3.1的主要目标是优化，本书也直接应用这一新发布。事实上，由于Python 3.1在Python 3.0后接踵而来，并且最新的Python通常是最好的可用Python，在本书中，术语\"Python 3.0\"通常指的是Python 3.0引入的但在整个Python 3.X版本中都将存在的语言变化。\n",
  "factionName": "Phthon学习手册：第4版",
  "newest": 10,
  "comments": [],
  "source": [],
  "index": "3"
},{
  "_id": "707f5e28-e885-4baa-9c75-9504554923f4",
  "headerImage": "https://wk-gulimall.oss-cn-beijing.aliyuncs.com/ProgramBook/c5ef14ab-f79d-45f3-9036-a8c7f9b3c253.jpg",
  "updateTime": {
    "$date": "2023-01-23T17:00:49.381Z"
  },
  "author": "Richer",
  "des": "如果你手里（或者你的电子阅读器里）有这本书，可以说，这是一个幸运的巧合。毕竟，每年有几百万册图书印刷出来，供数百万读者阅读，而你恰好选择了这一本。可以说，正是机器学习算法引领你来阅读这本书（或者说是把这本书引领到你面前）。而我们作为本书的作者，很高兴看到你愿意了解更多的“怎么做”和“为什么”。本书大部分内容都将涉及“怎么做”。例如，怎么处理数据才能让机器学习算法最大限度地利用它们？怎么选择正确的算法来解决手头的问题？我们偶尔也会涉及“为什么”。例如，为什么正确评估很重要？为什么在特定情形下一个算法比另一个算法的效果更好？我们知道，要成为该领域的专家还有很多知识要学。毕竟，本书只介绍了一些“怎么做”和极小一部分“为什么”。但在最后，我们希望这些内容可以帮你“启航”，然后快速前行。",
  "factionName": "机器学习系统设计",
  "newest": 10,
  "comments": [],
  "source": [],
  "index": "5"
},{
  "_id": "c2ffee81-cbdc-4491-be83-f33af89b0177",
  "headerImage": "https://wk-gulimall.oss-cn-beijing.aliyuncs.com/ProgramBook/0cdfb4e9-5385-4f21-ba72-4dfdd9c2064b.jpg",
  "updateTime": {
    "$date": "2023-01-23T17:00:50.501Z"
  },
  "author": "Brown,",
  "des": "说起架构，想必很多人会认为它离自己太远，我做的事情还远到不了架构这么高的层次。那么什么是架构呢？正如本书作者所做的调查一样，不同的人会给出不同的见解。 我们不妨从平时的项目中来观察一下，技术选型是怎么出来的？团队的分工协作是如何进行的？项目质量和进度是怎么得到保障的？ 是的，你会发现，在任何一个项目中，总有些人会在这些事情上付出努力。从他们身上可以看到哪些不一样的特质？他们看起来都很积极，好像整个项目就是他们在负责；他们让事情得到解决，最终让项目得以交付。 可以认为，项目中出现的类似行为都是在对架构的思考，思考架构会是从被动服务到主动服务的Owner 意识养成过程，会让我们Get things done！而最终完成的好坏及是否有方法论支撑则是另外讨论的范畴，这也正是本书要为大家呈现的内容！ 如果你刚接触项目不久，建议由浅入深，从分清楚什么是库什么是框架开始，带着问题在本书中寻找答案！如果你已经验丰富，同样可以认真思考书中每一部分后面的问题进行自我对照，看看与作者的建议是否有共鸣之处！ 从现在开始，认真且有效地去规划完成自己负责的事情！",
  "factionName": "程序员必读之软件架构",
  "newest": 10,
  "comments": [],
  "source": [],
  "index": "5"
},{
  "_id": "f7d804ac-12a4-47ab-8b75-767b09e60603",
  "headerImage": "https://wk-gulimall.oss-cn-beijing.aliyuncs.com/ProgramBook/a0c216d9-601f-4522-85e7-c055ac44f89a.jpg",
  "updateTime": {
    "$date": "2023-01-23T17:00:51.427Z"
  },
  "author": "Turnbu",
  "des": "本书适合希望实施Docker或基于容器的虚拟化技术的开发者、系统管理员和有意用DevOps的人员阅读。\n要阅读本书，读者需要具备一定的Linux/Unix技能，并熟悉命令行、文件编辑、软件包安装、服务管理和基本的网络知识。\n注意\n本书专注于1.9或更高版本的Docker，该版本不与早期版本向下兼容。实际上，在生产环境中，也推荐使用1.9或更高版本。\n致谢\n感谢我的合伙人及好友Ruth Brown，感谢你迁就我进行本书的写作。\n感谢Docker公司的团队，感谢你们开发出Docker，并在本书写作期间提供无私的帮助。\n感谢#docker频道和Docker邮件列表里的朋友们。\n感谢Royce Gilbert，感谢你不仅提供超赞的技术插图，还为本书英文版设计了封面。\n感谢Abhinav Ajgaonkar，感谢你提供自己的Node.js和Express示例应用程序。\n感谢本书的技术审校团队，你们让我时刻保持头脑清醒，并指出了书中的愚蠢错误。\n感谢Robert P. J. Day，感谢你在本书发布后提供了极详细的勘误表。\n本书中有3张配图是由Docker公司提供的。\nTM\n技术审稿人团队\nScott Collier\nScott Collier是一位高级主任系统工程师，就职于Red Hat的系统设计及工程团队。该团队根据从销售、市场以及工程团队收集到的数据，甄别并提供高价值的解决方案，并为内外部用户开发参考架构。Scott是Red Hat认证构架师（RHCA），具有超过15年的IT从业经验，他现在专注于Docker、OpenShift以及Red Hat系列产品。\n除了思考分布式构架之外，Scott喜欢跑步、登山、露营，还喜欢陪妻子和3个孩子在得克萨斯州的奥斯汀享受烧烤。他的技术文章以及相关信息可以在http://colliernotes.com上找到。\nJohn Ferlito\nJohn是一位连续创业者，同时也是高可用性、可扩展性基础设备专家。John现在在自己创建的Bulletproof公司担任CTO，这是一家提供关键任务的云服务商，同时，John还兼任提供综合视频服务的Vquence公司的CTO。\n在空闲时间，John投身自由及开源软件（Free and Open Source Soft，FOSS）社区。他是linux.conf.au 2007会议的联合发起人，也是2007年悉尼Linux用户委员会（Sydney Linux User Group，SLUG）的委员。他做过大量的开源项目，如Debian、Ubuntu、Puppet以及Annodex套件。读者可以在他的个人博客（http://inodes.org/blog）上查看他的文章。John拥有新南威尔士大学的工程学士荣誉学位（计算机科学类）。\nPaul Nasrat\nPaul Nasrat就职于Google公司，是一位网站可靠性工程师，同时也是Docker的贡献者。他在系统工程领域做了大量的开源工具，包括启动加载器、包管理以及配置管理等。\nPaul做过各种系统管理和软件开发的工作。他曾在Red Hat担任软件工程师，还在ThoughtWorks公司担任过基础设备专家级顾问。Paul在各种大会上做过演讲，既有DevOps活动早期在2009年敏捷大会上关于敏捷基础设备的演讲，也有在小型聚会和会议上的演讲。\n技术插图作家\nRoyce Gilbert（ksuroyce@yahoo.com）是本书技术插图的作者，在他超过30年的从业经验中，他做过CAD设计、计算机支持、网络技术、项目管理，还曾为多家世界500强企业提供商务系统分析，包括安然（Enron）、康柏（Compaq）、科氏（Koch）和阿莫科（Amoco）集团。Royce在位于堪萨斯州曼哈顿的堪萨斯州立大学担任系统/业务分析员。他业余时间在自己的Royce艺术工作室进行创作，是一位独立艺术家和技术插画家。他和38岁的妻子在堪萨斯州的弗林特山上修复了一间有127年历史的石头老屋，并以此为居所，过着平静的生活。\n校对者\n[1]\n排版约定\ninline code statement\n下面是代码块：\n代码清单0-1　示例代码块\nThis is a code block\n过长的代码行会换行。\n代码及示例\nhttp://www.dockerbook.com/code/index.html\nhttps://github.com/jamtur01/dockerbook-code\n说明\n[2]\n勘误\n如果读者发现任何错误，请用电子邮件与我联系，我的邮箱是james+errata@ lovedthanlost.net。\n版本\n本书是The Docker Book一书v1.9.1版的中文版。\n[1]\n[2]\n",
  "factionName": "第一本Docker书",
  "newest": 10,
  "comments": [],
  "source": [],
  "index": "5"
},{
  "_id": "9630ee74-f215-436a-a27b-e7727b41797f",
  "headerImage": "https://wk-gulimall.oss-cn-beijing.aliyuncs.com/ProgramBook/ed26de6d-1da8-4108-8f39-22fc079262e7.jpg",
  "updateTime": {
    "$date": "2023-01-23T17:00:52.637Z"
  },
  "author": "T.Hein",
  "des": "就像《黑客帝国》里面的Trinity所说的：\n“Neo，是这个问题驱使着我们，是这个问题带你来到这儿。”\n你知道这个问题，我也是。\n作为本书的作者，我们将回答引领你到此的问题：\n我能够使用某个算法解决我的问题吗？如果可以，那么怎么实现呢？\n你也许并不需要理解一个算法为什么是正确的。如果你需要，那么请看看其他的资料，例如1180页的算法圣经——《算法导论》，作者是Thomas H.Cormen等（2001）。在那本书中你会了解到推论、定理以及证明；你也会从一些练习题和逐步递进的样例中看到算法是如何执行的。也许你会惊奇地发现，在算法导论中你找不到任何的实际代码，仅仅是一些伪代码的片段，伪代码是无数的算法教科书用来阐述算法的高级描述手段。在课堂上，这些教科书是非常重要的，但是在实际软件开发中，它们却起不到应有的作用，因为这些书假定伪代码都能够直接变成实际代码。\n我们希望经验丰富的程序员在寻找问题的解决方案时，能够频繁参考本书。作为一名程序员，你每天要解决的问题都能在这里找到解决方案。在软件中，算法是决定成败的关键因素，在这里你能够了解到哪些决定能够改善关键算法的性能，也能够找到适合你的需求和解决方案的实际代码。\n所有的算法都有实现，并且都使用测试工具经过仔细测试，以确保其正确性。而且，它们有足够的代码文档，能在这本书的代码库附录中找到它们。我们严格地遵照一系列的原则来设计算法、实现算法，以及编写这本书。如果这些原则对你很有意义，那么这本书也会同样有用。\n为了计算最大网络流，一个实践者应该做些什么才能将图P-1的Ford-Fulkerson算法描述转换成实际代码呢？\n图　P-1　教科书中常见的伪代码\n图中的算法描述来自于维基百科（http://en.wikipedia.org/wiki/Ford_Fulkerson），这个描述与《算法导论》上的伪代码极其相似。最好还是不要期望一个软件的开发者能够根据这个Ford-Fulkerson算法的描述开发出实际的代码。翻到第8章，对比一下我们的代码。我们只使用有注释的，并且是精心设计过的代码。在你自己写的代码或者软件系统中使用我们提供的现成代码，或者这些代码的逻辑吧。\n一些算法教科书确实有完整的C或者Java代码。但是这些教科书的目的通常是教初学者编程语言，或者是解释如何实现抽象数据类型。而且代码都只是在页面的狭窄边栏，作者通常都会忽略注释和错误处理，或者使用在实际应用中不会用到的快捷方法。我们相信程序员能够从有注释的，并且是精心设计过的代码中学到更多的东西，这就是我们为什么做如此多的工作来开发算法的实际解决方案。\n",
  "factionName": "算法技术手册",
  "newest": 10,
  "comments": [],
  "source": [],
  "index": "5"
},{
  "_id": "5f5542f9-e5c1-479d-a5e7-587296ff00e4",
  "headerImage": "https://wk-gulimall.oss-cn-beijing.aliyuncs.com/ProgramBook/85f29e2f-6837-47da-9178-4d4b8af7908a.jpg",
  "updateTime": {
    "$date": "2023-01-23T17:00:53.606Z"
  },
  "author": "王晓华, ",
  "des": "程序员与算法，这是一个永恒的话题，无论在哪个论坛，只要出现此类主题的帖子，一定会看到两种针锋相对的观点的“激烈碰撞”。其实泡过论坛的人都知道，两种观点“激烈辩论”的惨烈程度往往可以上升到互相问候先人的高度，即使是技术论坛也不例外。在准备此书之前，我在博客的“算法系列”专栏已经陆陆续续地写了有一年多的时间，在此期间，不断有读者问我：“程序员必须会算法吗？”我实在不想让我的博客成为喷满各种口水的是非之地，所以一般不正面回答，只是笼统地说些“各行各业情况都不尽相同”之类的话，避免站队。\n程序员对算法通常怀有复杂的感情，算法很重要是大家的共识，但是是否每个程序员都必须学算法是主要的分歧点。本书是想重新定义程序员对算法的理解，并不想通过说教的方式给出到底是学还是不学的结论。很多人可能觉得像人工智能、视频与音频处理以及数据搜索与挖掘这样高大上的内容才能称为算法，往往觉得算法深不可测。但是这些其实都不是具体的算法，而是一系列算法的集合，这里面既有各种大名鼎鼎的算法，比如神经网络、遗传算法、离散傅里叶变换算法以及各种插值算法，也有不起眼的排序和概率计算的算法。你必须深入地了解它们，才会领略到算法的实质——解决问题。忽视这一点，片面地或抽象地理解算法，就会使对算法的理解变得形而上学。在我的博客里就有人留言质疑：“穷举也算是算法？”且不说搜索和枚举是算法的基础设计模式之一，单就那么多的NPC问题（比如著名的汉密尔顿回路问题，至今还没有找到多项式时间的算法），实际上，从只有穷举算法和其他随机搜索算法才能求解这一点看，任何人都不能小看它。\n狭隘的算法定义会将自己局限在一个小角落里，从而错过了整个色彩缤纷的算法世界。本书将带你开启一段算法之旅，在这里，你将会看到各种构造算法的基础方法，比如贪婪法、分治法、动态规划法，等等，也可以通过一个个示例看到如何应用这些算法来解决实际问题。通过对“爱因斯坦的思考题”“三个水桶等分水”“妖怪与和尚过河问题”等趣味智力题的计算机求解算法设计，你可以领会到算法设计的三个关键问题，以及对这些问题的处理方法，为以后解决这样的问题提供举一反三的基础。\n在生活中，凡是有乐趣的地方就有算法。本书将介绍生活中无处不在的算法。在历法计算的章节里，你会看到霍纳法则（Horner's rule）的使用和求解一元高次方程的牛顿迭代法；音频播放器上跳动的频谱，背后是离散傅里叶变换算法；DOS时代著名的PCX图像文件格式使用的RLE压缩算法是如此简单，但是却非常有效；RSA加密算法的光环之下是朴实的欧几里得算法、蒙哥马利算法和米勒-拉宾算法；华容道游戏求解的简单穷举算法中还蕴藏着对棋盘状态的哈希算法……遗传算法神秘不可测，但是用遗传算法求解0-1背包问题只用了60多行代码。事实上，抛开对遗传算法的深层次研究和在各种专业领域内的扩展应用，单就算法原理来说，它就是这么简单。深蓝战胜卡斯特罗之后，人类棋手在与计算机的博弈中就完全处于下风，人工智能真的这么神奇？人工智能确实是个神奇的领域，但就计算机下棋这件事来说，却并不怎么神奇，算法的基本原理简单得让人难以置信，看看第23章你就知道了。\nO\nn\nO\nn\n2\nO\nn\nO\nn\n程序员谈到算法言必称一些高大上的词汇，但是这些专有名词大部分人是用不到的，以至于人们常常认为算法不过如此，不会又如何？这种思想变得极端就会让人忽视算法的基础设计能力，这才是最要命的。在我们维护的网络设备上，用户的数据关系错综复杂，一个对线性表进行二重循环都想不到的人又怎么可能会维护这些数据？我希望程序员们提高基础的算法能力，先从培养兴趣开始或许是一个不错的切入点。\n本书挑选的算法例子，都围绕着“趣”字展开，都是简单且在生活中常见的算法，可能有些是你还没有意识到的。我上学的时候曾经做过一个MP3播放器程序，你可能觉得这主要就是利用一些音频解码算法吧？是的，这个是主要部分，但是一个功能完整的播放程序还用了很多你想不到的算法：为增加频谱显示和均衡器功能，使用了离散傅里叶变换算法；为计算频率功率谱，使用了加权平均值算法；为了匹配硬件输出设备与解码算法的性能差异，需要一个有多个缓冲区的队列管理音频数据块，这就引入了滑动窗口算法；为提供按照专辑名称或作者名称排序功能，使用了快速排序算法；为了平滑均衡器调节对音频的影响，使用了三次样条曲线插值算法；为了在两首歌曲之间切换时压制刺耳的杂音（通过填充一些舒适噪声的方式实现），还使用了正弦信号发生器算法。这些你都没有想到吧？其实还有更多的例子，比如大型项目管理软件中的工作节点排序功能和关键路径功能，背后支撑它们的却是简单的有向图拓扑排序算法。这是不是很有趣？生活中处处都是算法，程序员又怎么可能与算法绝缘？\nhttp://blog.csdn.net/orbit/\nwww.iTuring.cn/book/1605\n",
  "factionName": "算法的乐趣 ",
  "newest": 10,
  "comments": [],
  "source": [],
  "index": "5"
},{
  "_id": "ba1e58c4-34ef-469c-a559-2466783572a4",
  "headerImage": "https://wk-gulimall.oss-cn-beijing.aliyuncs.com/ProgramBook/17f57286-eaa9-4fb6-9340-6b50dad5b7f0.jpg",
  "updateTime": {
    "$date": "2023-01-23T17:00:55.031Z"
  },
  "author": "秦小波, ",
  "des": "JavaScript是目前比较流行的Web开发语言。随着移动互联网、云计算、Web 3.0和客户端开发概念的升温，JavaScript语言不断成熟和普及，并被广泛应用于各种B/S架构的项目和不同类型的网站中。对于JavaScript初学者、网页设计爱好者以及Web应用开发者来说，熟练掌握JavaScript语言是必需的。\nJavaScript语言的最大优势在于灵活性好，适应能力强。借助各种扩展技术、开源库或框架，JavaScript能够完成Web开发中各种复杂的任务，提升客户端用户体验。\n作为资深的Web开发人员，笔者已经习惯了与高性能的编程语言和硬件打交道，因此一开始并没有对JavaScript编程有太高的期望。后来才发现，JavaScript实际上是一种优秀且高效的编程语言，而且随着浏览器对其更好的支持、JavaScript语言本身的性能提升，以及新的工具库加入，JavaScript不断变得更好。JavaScript结合HTML 5等为Web开发人员提供了真正可以发挥想象力的空间。Node.js等新技术则为使用JavaScript对服务器进行编程描绘了非常美好的未来。\n但是，在阅读网上大量散存的JavaScript代码时，笔者能明显感觉到很多用户正在误入“歧途”：编写的代码逻辑不清，结构混乱，缺乏编程人员应有的基本素养。这种现状一般都是用户轻视JavaScript语言所致。还有很多用户属于“半路出家”，误认为JavaScript就是一种“玩具语言”，没有以认真的态度对待和学习这门语言，书写代码也很随意。因此，笔者萌生了写一本以提高JavaScript代码编写质量为目的的书籍，在机械工业出版社华章公司杨福川编辑的鼓励和指导下，经过近半年的策划和准备，终于鼓起勇气动笔了。\n",
  "factionName": "编写高质量代码之JS",
  "newest": 10,
  "comments": [],
  "source": [],
  "index": "4"
},{
  "_id": "608d7650-df93-4471-b079-eb979769e90b",
  "headerImage": "https://wk-gulimall.oss-cn-beijing.aliyuncs.com/ProgramBook/55ab4221-6664-4758-b2e7-c609dcb47319.jpg",
  "updateTime": {
    "$date": "2023-01-23T17:00:55.784Z"
  },
  "author": "齐伟",
  "des": "这是一本学习材料，是为编程“零基础”的朋友学习Python提供的类似教材的学习材料，所以，内容会有庞杂琐碎之感，但这对于“零基础”的读者来讲是不可缺少的。所以，不要把这本书当作“开发手册”来用。\n本书虽然是以“零基础”起步，但是并不打算仅仅涉及一些浅显的入门知识，当然基础知识是必不可少的，还想为“零基础”的朋友多提供一些知识，一些所谓高级的内容，既满足了好奇心，也可以顺势深入研究。当然，真正的深入还需要读者自己努力。\n“敬畏上帝是智慧的开端”。在本书的编写过程中，一直惶恐于能否所言无误，但水平有限，错误难免，敬请读者指出，并特别建议，对有异议的地方，请使用Google网站搜索更多的资料进行比较阅读，也可以跟我联系，共同探讨。为了便于进行技术交流，我创建了一个QQ群（群号：26913719），专供本书读者研讨技术问题。\n完成本书是一个比较漫长的过程，在这个过程中，得到了很多朋友的帮助，在这里对他们表示感谢，并将他们的名号列在下面：\n李航、令狐虫、github641、dongm2ez、wdyggh、codexc、winecat、solarhell、ArtinHuang、吴优。\n在本书编辑过程中，电子工业出版社的编辑高洪霞、黄爱萍为本书的面世做出了极大的努力，对她们的工作表示诚挚感谢。\n最后，要感谢我的妻子，在本书的写作过程中，她给了我很多鼓励，还协助我检查文本内容。\n希望这本书能够为有意学习Python的读者提供帮助。\n齐伟\n2016年1月\n",
  "factionName": "跟老齐学Python：从入门到精通",
  "newest": 10,
  "comments": [],
  "source": [],
  "index": "3"
},{
  "_id": "380333f7-f9c8-4691-b269-f34d101b616a",
  "headerImage": "https://wk-gulimall.oss-cn-beijing.aliyuncs.com/ProgramBook/1d967fef-2238-4d86-a12b-22abbbf1e596.jpg",
  "updateTime": {
    "$date": "2023-01-23T17:00:57.178Z"
  },
  "author": "ePUBw.",
  "des": "Life is short. You need Python.\n——Bruce Eckel\n上边这句话是Python社区的名言，翻译过来就是“人生苦短，我用Python”。\n我和Python结缘于一次服务器的调试，从此便一发不可收拾。我从来没有遇到一门编程语言可以如此干净、简洁，如果你有处女座情节，你一定会爱上这门语言。使用Python，可以说是很难写出丑陋的代码。我从来没想过一门编程语言可以如此简单，它太适合零基础的朋友踏入编程的大门了，如果我有一个八岁的孩子，我一定会毫不犹豫地使用Python引导他学习编程，因为面对它，永远不缺乏乐趣。\nPython虽然简单，其设计却十分严谨。尽管Python可能没有C或C++这类编译型语言运行速度那么快，但是C和C++需要你无时无刻地关注数据类型、内存溢出、边界检查等问题。而Python，它就像一个贴心的仆人，私底下为你都一一处理好，从来不用你操心这些，这让你可以将全部心思放在程序的设计逻辑之上。\n有人说，完成相同的一个任务，使用汇编语言需要1000行代码，使用C语言需要500行，使用Java只需要100行，而使用Python，可能只要20行就可以了。这就是Python，使用它来编程，你可以节约大量编写代码的时间。\n既然Python如此简单，会不会学了之后没什么实际作用呢？事实上你并不用担心这个问题，因为Python可以说是一门“万金油”语言，在Web应用开发、系统网络运维、科学与数字计算、3D游戏开发、图形界面开发、网络编程中都有它的身影。目前越来越多的IT企业，在招聘栏中都有“精通Python语言优先考虑”的字样。另外，就连Google都在大规模使用Python。\n好了，我知道过多的溢美之词反而会使大家反感，所以我必须就此打住，剩下的就留给大家自己体验吧。\n接下来简单地介绍一下这本书。一年前，出版社的编辑老师无意间看到了我的一个同名的教学视频，建议我以类似的风格撰写一本书。当时我是受宠若惊的，也很兴奋。刚开始写作就遇到了不小的困难——如何将视频中口语化的描述转变为文字。当然，我希望尽可能地保留原有的幽默和风趣——毕竟学习是要快乐的。这确实需要花不少时间去修改，但我觉得这是值得的。\n本书不假设你拥有任何一方面的编程基础，所以本书不但适合有一定编程基础，想学习Python3的读者，也适合此前对编程一无所知，但渴望用编程改变世界的朋友！本书提倡理解为主，应用为王。因此，只要有可能，我都会通过生动的实例来让大家理解概念。虽然这是一本入门书籍，但本书的“野心”可并不止于“初级水平”的教学。本书前半部分是基础的语法特性讲解，后半部分围绕着Python3在爬虫、Tkinter和游戏开发等实例上的应用。编程知识深似海，没办法仅通过一本书将所有的知识都灌输给你，但我能够做到的是培养你对编程的兴趣，提高你编写代码的水平，以及锻炼你的自学能力。最后，本书贯彻的核心理念是：实用、好玩，还有参与。\n本书对应的系列视频教程，可以在http://blog.fishc.com/category/python下载得到，也可扫描以下二维码关注微信号进行观看。\n微信扫描书中对应二维码，亦可观看相关视频。\n编者\n2016年7月\n第1章　就这么愉快的开始吧\n1.1　获得Python\n我观察到这么一个现象：很多初学的朋友都会在学习论坛上问什么语言才是最好的？他们的目的很明确，就是要找一门“最好”的编程语言，然后持之以恒地学习下去。没错，这种“执子之手，与子偕老”的专一精神是我们现实社会所推崇的。但在编程的世界里，我们并不提倡这样。我们更提倡“存在即合理”，当前热门的编程语言都有其存在的道理，它们都有各自擅长的领域和适用性。因此我们没办法去衡量哪一门语言才是最好的。\nPython的语法是非常精简的，对于一位完美主义者来说，Python将是他爱不释手的伙伴。Python社区的目标就是构造完美的Python语言！本书将使用Python3来进行讲解，而Python3不完全兼容Python2的语法，这样做无疑会让大多数程序员心生怨愤且喋喋不休，因为他们用Python2写的大量代码经过层层调试已经趋近完美，并已部署到服务器或应用上了。Python3对Python2的语法不兼容，意味着他们的这些应用需要进行转换和重新调试……但是，Python社区仍旧坚持推出全新的Python3。只有勇敢地割掉与时代发展不相符的瑕疵部分，才能缔造出真正的完美体验！\n工欲善其事，必先利其器。我们要成为“大牛”，要用Python去拯救世界，要做的第一件事就是要下载一个Python的安装程序并成功地将它安装到你的计算机上。\n安装Python非常容易，你可以在它的官网找到最新的版本并下载（注：本书所需要的程序、例子均附带在本书配套资源中），地址是http://www.python.org。\n如图1-1所示，进入Python官网后找到Download字样，下载最新版本的Python即可。\n如果是其他操作系统（例如，Mac OS X），在页面下方可以找到对应的下载地址，如图1-2所示。\n此处演示的是本书截稿前的最新版本Python 3.4.3（32位）（注：这里建议大家安装32位版，因为本书第16章安装Pygame时需要32位版本的Python），一般大家下载最新版本即可。安装Python3非常简单，打开下载好的安装包，按照默认选项安装即可。\n图1-1　下载Python3\n图1-2　下载Python3\n1.2　从IDLE启动Python\nIDLE是一个Python Shell，shell的意思就是“外壳”，从基本上说，就是一个通过输入文本与程序交互的途径。像Windows的cmd窗口，像Linux那个黑乎乎的命令窗口，它们都是shell，利用它们，就可以给操作系统下达命令。同样，可以利用IDLE这个shell与Python进行互动。\n>>>这个提示符含义是：Python已经准备好了，在等着输入Python指令呢。如图1-3所示，可以看到Python已经按照我们的要求去做了，在屏幕上打印（注：这里打印的意思是“打印”到屏幕上）I love fishc.com这个充满浓浓爱意的字符串，这说明什么？没错，这说明我们是“爱鱼C”的，也说明了我们跟Python的第一次亲密接触是有感觉的，她完全能够理解我的想法。\n图1-3　在Python的IDLE中输入命令\n1.3　失败的尝试\n像下面这样输入，Python就会“笨笨地”出错：\n其实Python3哪里是“笨”，她只是小气，所以显得蠢萌蠢萌的。我们仿佛听到她在说：为什么此时此刻你跟我在一起还想着前任？为什么你跟我在一起还想着其他女人，小C她哪点儿比我好，她还要加分号呢，我可不用！\n大家看到上边的代码中井号（#）后边加了段中文，井号起到的作用是注释，也就是说，井号后边的内容是给人们看的，并不会被当作代码运行。\n1.4　尝试点儿新的东西\n尝试点儿新的东西，在IDLE中输入print(5+3)或者直接输入5+3：\n看起来Python还会做加法！这并不奇怪，因为计算机最开始的时候就是用来计算的，任何编程语言都具备计算能力，那接下来看看Python在计算方面有何神奇。\n不妨再试试计算1234567890987654321 * 9876543210123456789：\n怎么样？如果C语言实现起来费劲，要九曲十八弯地利用数组做大数运算，在这里Python轻而易举就完成了！\n还有呢，大家试试输入print(＂Well water＂+＂River＂)：\n可以看到，井水和河水又友好地在一起生活了，祝它们幸福吧！\n1.5　为什么会这样\n再试试print(＂I love python\\n＂ * 3)：\n哇，字符串和数字还可以做乘法，结果是重复显示N个字符串。既然乘法可以，那不妨试试加法。print(＂I love python\\n＂+3)：\n失败了！这是为什么呢？大家不妨课后自己思考一下。\n第2章　用Python设计第一个游戏\n2.1　第一个小游戏\n有读者可能会说：“哇，小甲鱼（注：作者）！你开玩笑呢？这么快就教我们开发游戏啦？难道你不打算先讲讲变量、分支、循环、条件、函数等常规的内容？”\n没错的，大家如果继续学下去就会发现，本书的教学会围绕着一个个个性鲜明的实例来展开，跟着本书完成这些实例的编写，你会发觉不知不觉中那些该掌握的知识，已经化作你身体的一部分了！这样的学习方式才能充满快乐并让你一直期待下一章节的到来。\n好，今天来讲一下“植物大战僵尸”这款游戏的编写……但这是不可能的，因为虽然说Python容易入门，但像“植物大战僵尸”这类游戏要涉及碰撞检测、边缘检查、画面刷新和音效等知识点比较多，需要将这些基础知识累积完成才能开始讲。\n目前对于我们所掌握的基础……貌似只有print()这个BIF，哦，BIF的概念甚至还没讲解……不过请淡定，这一点儿也不影响我们今天的节奏！\n那么今天是一个什么样的节奏呢？今天打算讲一个文字游戏……\n先来看下这段代码，并试图猜测一下每条语句的作用：\n在这里要求大家都动动手，亲自输入这些代码，你需要做的是：\n打开IDLE。\n选择File->New Window命令（或者你可以直接按Ctrl+N键，在很多地方这个快捷键都是新建一个文件的意思）。\n按照上边的格式填入代码。\n按快捷键Ctrl+S，将源代码保存为名为p2_1.py的文件。\n输完代码一起来体验一下，F5走起（也可以选择Run->Run Module命令）！\n程序执行结果如下：\n提示\nTab按键的使用：\n（1）缩进。\n（2）IDLE会提供一些建议，例如输入pr TAB会显示所有可能的命令供你参考。\nOK，我们是看到程序成功跑起来了，但坦白说，这玩意儿配叫游戏吗？呃……没事啦，咱慢慢改进，好，我们说下语法。\n有C-like语言（一切语法类似C语言的编程语言称为C-like语言）编程经验的朋友可能会受不了，变量呢？声明呢？怎么直接就给变量定义了呢！有些真正零基础的读者可能还不知道什么是变量，不怕，随着本书内容的展开，大家很快就能掌握相关的知识。有些读者可能发现这个小程序没有任何大括号，好多编程语言都用大括号来表示循环、条件等的作用域，而在Python这里是没有的。在Python中，只需要用适当缩进来表示即可。\n2.2　缩进\n缩进是Python的灵魂，缩进的严格要求使得Python的代码显得非常精简并且有层次。但是，在Python里对待代码的缩进要十分小心，因为如果没有正确地使用缩进，代码所做的事情可能和你的期望相差甚远（就像在C语言里括号打错了位置）。\n如果在正确的位置输入冒号（：），IDLE会在下一行自动进行缩进。正如方才的代码，在if和else语句后边加上冒号（：），然后按下回车，第二行开始的代码会自动进行缩进。if条件下边有两个语句分别有缩进，那么说明这两个语句是属于if条件成立后所需要执行的语句，换句话说，如果if条件不成立，那么两个缩进的语句就不会被执行。\n提示\nif…else…是一个条件分支，if后边跟的是条件，如果条件成立，就执行以下缩进的所有内容；如果条件不成立，有else的话就执行else下缩进的所有内容。条件分支的内容在后边还会做详细的介绍。\n2.3　BIF\n接下来学习一个新的名词：BIF。\nBIF就是Built-in Functions，内置函数的意思。什么是内置函数呢？为了方便程序员快速编写脚本程序（脚本就是要代码编写速度快快快！），Python提供了非常丰富的内置函数，只需要直接调用即可，例如print()是一个内置函数，它的功能是“打印到屏幕”，就是说把括号里的内容显示到屏幕上。input()也是一个BIF，它的作用是接收用户输入并将其返回，在上方的代码中，用temp这个变量来接收。Python的变量是不需要事先声明的，直接给一个合法的名字赋值，这个变量就生成了。\n提示\n在IDLE中输入dir(__builtins__)可以看到Python提供的内置函数列表。\nhelp()这个BIF用于显示BIF的功能描述：\n有些读者可能会说，太多BIF学不过来记不过来怎么办？看不懂英文说明怎么办？Python3的资料太少怎么办？大家不用担心，在接下来的每一个环节，作者都会教大家几个常用的BIF的用法，然后在课后作业（注：每节课对应的课后作业需要在鱼C论坛完成：http://bbs.fishc.com/forum-243-1.html）中强化大家的记忆。所以，大家只要严格跟着作者的脚步走，课后练习坚持自己独立完成，相信即使觉得自己记性很差的朋友，也可以做到倒背如流！\n第3章　成为高手前必须知道的一些基础知识\n3.1　变量\n在改进小游戏之前，有些必须掌握的知识需要来讲解一下。\n当你把一个值赋值给一个名字时，它会存储在内存中，把这块内存称为变量（variable）。在大多数语言中，都把这种行为称为“给变量赋值”或“把值存储在变量中”。\n不过，Python与大多数其他计算机语言的做法稍有不同，它并不是把值存储在变量中，而更像是把名字“贴”在值的上边。所以有些Python程序员会说Python没有变量，只有名字。变量就是一个名字，通过这个名字，可以找到我们想到的东西。\n看个例子：\n变量为什么不叫“恒量”而叫变量？正是因为它是可变的！再看另一个例子：\n上面的例子先创建一个变量，名字叫x，给它初始化赋值为3，然后又给它赋值为5（此时3就被5替换掉），接下来创建另外一个变量y，并初始化赋值为8，最后创建第三个变量z，它的值是变量x和y的和。\n同样的方式也可以运用到字符串中：\n这种字符串加字符串的语法，在Python里称为字符串的拼接。\n需要注意的地方：\n在使用变量之前，需要对其先赋值。\n变量名可以包括字母、数字、下划线，但变量名不能以数字开头，这跟大多数高级语言一样——受C语言影响，或者说Python这门语言本身就是由C语言写出来的。\n字母可以是大写或小写，但大小写是不同的。也就是说，fishc和FishC对于Python来说是完全不同的两个名字。\n等号（=）是赋值的意思，左边是名字，右边是值，不可写反了。\n变量的命名理论上可以取任何合法的名字，但作为一个优秀的程序员，请尽量给变量取一个专业一点儿的名字。\n3.2　字符串\n到目前为止，我们所认知的字符串就是引号内的一切东西，我们也把字符串叫作文本，文本和数字是截然不同的。\n如果直接让两个数字相加，那么Python会直接将数字相加后的结果告诉你：\n但是如果在数字的两边是加上了引号，就变成了字符串的拼接，这正是引号带来的差别：\n要告诉Python你在创建一个字符串，就要在字符两边加上引号，可以是单引号或者双引号，Python表示在这一点上不挑剔。但必须成对，你不能一边用单引号，另一边却花心地用上双引号结尾，这样Python就不知道你到底想干嘛了：\n这就有点像你一边跟Python说我爱你，一边却搂着小C，所以，面对这么完美的语言，我们不写别扭的语法！\n那如果字符串内容中需要出现单引号或双引号怎么办？\n像上边这样写Python会误会你的意思，从而产生错误。\n有两种方法。第一种比较常用，就是使用转义符号（\\）对字符串中的引号进行转义：\n还有一种方法就是利用Python既可以用单引号也可以用双引号表示字符串这一特点，只要用上不同的引号表示字符串，那么Python就不会误解你的意思啦。\n3.3　原始字符串\n听起来好像反斜杠是一个好东西，但不妨试试打印C:\\now：\n打印结果并不是我们预期的，原因是反斜杠（\\）和后边的字符（n）恰好转义之后构成了换行符（\\n）。这时候有朋友可能会说：“用反斜杠来转义反斜杠不就可以啦？”嗯，不错，可以用反斜杠对自身进行转义：\n但如果对于一个字符串中有很多个反斜杠，我们就不乐意了。毕竟，这不仅是一个苦差事，还可能使代码变得混乱。\n不过大家也不用怕，因为在Python中有一个快捷的方法，就是使用原始字符串。原始字符串的使用非常简单，只需要在字符串前边加一个英文字母r即可：\n在使用字符串时需要注意的一点是：无论是否原始字符串，都不能以反斜杠作为结尾（注：反斜杠放在字符串的末尾表示该字符串还没有结束，换行继续的意思，下一节会讲这个内容）。如果你坚持这样做就会报错：\n大家不妨考虑一下：如果非要在字符串的结尾加个反斜杠，有什么办法可以灵活实现吗？\n3.4　长字符串\n如果希望得到一个跨越多行的字符串，例如：\n从明天起，做一个幸福的人\n喂马，劈柴，周游世界\n从明天起，关心粮食和蔬菜\n我有一所房子，面朝大海，春暖花开\n从明天起，和每一个亲人通信\n告诉他们我的幸福\n那幸福的闪电告诉我的\n我将告诉每一个人\n给每一条河每一座山取一个温暖的名字\n陌生人，我也为你祝福\n愿你有一个灿烂的前程\n愿你有情人终成眷属\n愿你在尘世获得幸福\n我只愿面朝大海，春暖花开\n嗯，看得出这是一首非常有文采的诗，那如果要把这首诗打印出来，用学过的知识，就不得不使用多个换行符：\n如果行数非常多，又会给我们带来不小的困扰了……好在Python总是设身处地地为我们着想——只需要使用三重引号字符串（＂＂＂内容＂＂＂）就可以轻松解决问题：\n最后需要提醒大家的是，编程的时候，时刻要注意Speak English！初学者最容易犯的错误（没有之一）就是误用了中文的标点符号。切记：编程中使用的标点符号都是英文的！\n3.5　改进我们的小游戏\n不得不承认，之前的小游戏真的是太简单了。有很多朋友为此提出了不少的建议，小甲鱼做了一下总结，大概有以下几个方面需要改进：\n（1）当用户猜错的时候程序应该给点提示，比如告诉用户当然输入的值比答案是大了还是小了。\n（2）每运行一次程序只能猜一次，应该提供多次机会给用户猜测，至少要三次嘛，人非圣贤，孰能一击即中，你说是吧？！\n（3）每次运行程序，答案可以是随机的。因为程序答案固定，容易导致答案外泄，比如小红玩了之后知道正确答案是8，就可能会把结果告诉小明，小明又会乱说。所以希望游戏的答案可以是随机的。\n这些挑战对于如此聪明的读者来说一定不成问题，让我们抄起家伙（Python）一个个来解决掉！\n3.6　条件分支\n第一个改进要求：当用户猜错的时候程序应该给点提示，比如告诉用户当然输入的值比答案是大了还是小了。程序改进后（假如答案是8）：\n如果用户输入3，程序应该提示比答案小了。\n如果用户输入9，程序应该提示比答案大了。\n这就涉及一个比较的问题了，作为初学者，可能不大熟悉计算机是如何进行比较吧？但我想大家都一定认识大于号（>）、小于号（<）以及等于号（==）（注：在Python中，用两个连续等号表示等于号，用单独一个等号表示赋值，还记得吧？那不等于呢？嗯，不等于这个有点特殊，用感叹号和一个等号搭配来表示）。\n另外，还需要掌握Python的比较操作符有：\n在IDLE中输入两个数以及比较操作符，Python会返回比较后的结果：\n这里1和3进行比较，判断1是否小于3，在小于号左右分别留了一个空格，这不是必需的，但代码量一多，看上去会美观很多。Python是一个注重审美的编程语言，这就跟人一样，人长得怎样是天生的，一般无法改变，但人的气质修养是可以从每个细小动作看出来的，人们说心灵美才是美，指的就是这一方面。程序也一样，你可以不修边幅、邋邋遢遢，只求不出错误，但别人阅读你的代码时很难受，他就不愿跟你一起合作开发，要是你的代码工整，注释得当，远远看上去犹如大家之作，那结果肯定不用说啦！\n大家还记得if-else吧？如果程序仅仅只是一个命令清单的话，那么他只需要笔直地一条路走到黑，但至少觉得应该把程序设计得更聪明点——可以根据不同的条件执行不同的任务，这就是条件分支。\nif 条件: 条件为真(True)执行的操作 else: 条件为假(False)执行的操作\n那现在让我们把第1个要求的代码写出来吧：\n3.7　while循环\n第1个要求实现了，可是用户还不高兴，他们会抱怨道：“为什么我要不停地重新运行你这个程序呢？难道你不能每次运行多给几次输入的机会吗？”（我们这个程序还好，几次尝试就可以成功了，但如果范围扩大为1～100，那么尝试的次数就要随之增加，总让用户不断地重新打开程序，这种程序的体验未免就太差了哈！）\n第2个改进要求：程序应该提供多次机会给用户猜测，专业点来讲就是程序需要重复运行某些代码。\n下面介绍Python的while循环语法。\nwhile 条件: 条件为真(True)执行的操作\n非常简单，对吧？Python一向就是这么简单，那一起来修改代码吧：\n聪明的读者可能已经发现了，这么改的话，程序的意思是只有用户输入正确的数字循环才能结束。这好像跟我们的第2个要求有点不同了，所以大家不妨边思考边动手，看怎么改才是正确的。\n给大家一点提示，大家思考一下如何修改，这里我给大家的提示是：使用and逻辑操作符。Python的逻辑操作符可以将任意表达式连接在一起，并得到一个布尔类型的值。布尔类型只有两个值：True和False，就是真与假，来看下面的例子：\n很明显，1>2这个条件是个伪命题，所以and的结果为假。用and逻辑操作符运行，只有当两边的条件均为真时，结果才能是True，否则为False，大家可以自己多做几次实验来证明。\n3.8　引入外援\n第3个改进要求：每次运行程序，答案是随机的。需要怎么实现呢？需要引入外援：random模块。\n等等，模块这个名字怎么那么熟悉？\n啊哈！想起来了，每次写完程序的时候，都要按一下快捷键F5运行，那里就显示着RUN MODULE，我们编写的程序实际上就是一个模块，只是我们目前还没有发觉。\n那这个random module里边有一个函数叫作randint()，它会返回一个随机的整数。可以利用这个函数来改造我们的游戏：\n3.9　闲聊数据类型\n所谓闲聊，也称为gossip，就是一点小事可以聊上半天。下面就来聊一聊Python的数据类型。\n在此之前，你可能已经听说过，咱这个Python的变量是没有类型的。对，没错，小甲鱼也曾经说过，Python的变量更像是名字标签，想贴哪儿就贴哪儿。通过这个标签，就可以轻易找到变量在内存中对应的存放位置了。\n但这绝不是说Python就没有数据类型这回事。大家还记得'520'和520的区别吗？\n没错，带了引号的，无论是双引号还是单引号或者是三引号，都是字符串；而不带引号的，就是数字。字符串相加叫作拼接，咳咳，不是拼爹，是拼接！数字相加就会得到两个数字的和：\nPython有很多重要的数据类型，不过这里不会一下子全都扔给大家。因为一来你肯定一下子记不了那么多；另外现在所要掌握的知识还不需要这么多的数据类型来配合实现。所以，每个阶段所学习的内容都是必要的，我们也只学习那些必要的内容。\nPython的字符串类型已经简单讲过，后边还会对字符串进行深入的探讨，所以大家别吐槽小甲鱼怎么都是浅尝辄止，没有那回事儿！咱只是分阶段逐步渗透，逐层进行消化，一下子说太深入，大家消化不了，教学也会变成纯理论化（小甲鱼知道死板的模式是大家最讨厌的）。\n今天来介绍一些Python的数值类型又包含整型、浮点型、布尔类型、复数类型等。\n3.9.1　整型\n整型说白了就是平时所见的整数，Python3的整型已经与长整型进行了无缝结合，现在的Python3的整型类似于Java的BigInteger类型，它的长度不受限制，如果说非要有个限制，那只限于计算机的虚拟内存总数。所以用Python3很容易进行大数计算。\n3.9.2　浮点型\n浮点型就是平时所说的小数，例如圆周率3.14是浮点型，例如地球到太阳的距离大约1.5亿千米，也是浮点型。Python区分整型和浮点型的唯一方式，就是看有没有小数点。\n谈到浮点型，不得不说下E记法。E记法也就是平时所说的科学计数法，用于表示特别大和特别小的数：\n对于地球到太阳的距离1.5亿千米，如果转换成米的话，那就是一个非常大的数了（150 000 000 000），但是如果你用E记法就是1.5e11（大E和小e都可以）。\n4\n3.9.3　布尔类型\n布尔类型事实上是特殊的整型，尽管布尔类型用True和False来表示“真”与“假”，但布尔类型可以当作整数来对待，True相当于整型值1，False相当于整型值0，因此下边这些运算都是可以的（最后的例子报错是因为False相当于0，而0不能作为除数）。\n当然把布尔类型当成1和0来参与运算这种做法是不妥的，这跟你把羊驼当成是一种马一样，所以大家知道就好，千万别在实际应用中这么去做！\n3.9.4　类型转换\n接下来介绍几个跟数据类型紧密相关的函数：int()、float()和str()。\nint()的作用是将一个字符串或浮点数转换为一个整数：\n注意了，如果是浮点数转换为整数，那么Python会采取“截断”处理，就是把小数点后的数据直接砍掉，注意不是四舍五入哦！\nfloat()的作用是将一个字符串或整数转换成一个浮点数（就是小数啦）：\nstr()的作用是将一个数或任何其他类型转换成一个字符串：\n3.9.5　获得关于类型的信息\n有时候可能需要确定一个变量的数据类型，例如用户的输入，当需要用户输入一个整数，但用户却输入一个字符串，就有可能引发一些意想不到的错误或导致程序崩溃！\n现在告诉大家一个好消息，Python其实提供了一个函数，可以明确告诉我们变量的类型，这就是type()函数：\n当然，通向罗马的道路非常多，无须在一棵树上吊死，查看Python的帮助文档，它更建议我们使用isinstance()这个BIF来确定变量的类型。这个BIF有两个参数：第一个是待确定类型的数据；第二个是指定一个数据类型。\nisinstance()会根据两个参数返回一个布尔类型的值，True表示类型一致，False表示类型不一致：\n3.10　常用操作符\n3.10.1　算术操作符\n和绝大多数编程语言一样，Python的算术操作符大部分和我们理解的一样，注意，这里说的是大部分，不是全部：\n+ - * / % ** //\n前边四个就不用介绍啦，加减乘除，大家都懂。不过有点小技巧倒不是大家都知道。\n例如，当你想对一个变量本身进行算术运算的时候，你是不是会觉得写a=a+1或b=b–3这类操作符特别麻烦？没错，在Python中可以做一些简化：\n如果使用过Python2.x版本的读者可能会发现，咱Python的除法变得有些不同了。包括很多编程语言，整数除法一般都是采用floor的方式，有些书籍称为地板除法（注：因为floor的翻译就是地板的意思）。地板除法的概念是：计算结果取比商小的最大整型，也就是舍弃小数的意思（注：例如3/2等于1）。但是在这里我们发现，即使是进行整数间的除法，但是答案是自动返回一个浮点型的精确数值，也就是Python用真正的除法代替了地板除法。\n那有些朋友不乐意了，他说“萝卜青菜各有所爱，我就喜欢原来的除法，我觉着整数除以整数就应该得到一个整数嘛。”Python团队也为此想好了后路，就是大家看到的双斜杠，它执行的就是地板除法的操作，不过要注意一点的是，无论是整数运算还是浮点数运算，都会执行地板除法：\n关于Python3在除法运算上的改革，支持的和谩骂的几乎各占一半，有些人支持这种做法，因为Python的除法运算从一开始的设计就有失误，但有些人又不想因此修改自己的海量代码，而剩下的人则想要真正的除法。无论怎样，Python团队是秉承着追求完美和卓越的思维去一次次改进Python这门编程语言，所以小甲鱼说Python3已经是非常棒的版本了。\n百分号（%）表示求余数的意思：\n3.10.2　优先级问题\n当一个表达式存在着多个运算符的时候，就可能会发生以下对话。\n加法运算符说：“我先到的，我先计算！”\n乘法运算符说：“哥我干一次够你翻几个圈了，哥先来！”\n减法运算符说：“你糊涂了，我现在被当成负号使用，没有我，你们再努力，结果也是得到相反的数！”\n除法运算符这时候默默地说：“抢吧抢吧，老娘我除以零，大不了大家同归于尽！”\n呃！为了防止以上矛盾的出现，我们规定了运算符的优先级，当多个运算符同时出现在一个表达式的时候，严格按照优先级规定的级别来进行运算。\n先乘除，后加减，如有括号先运行括号里边的。没错，从小学我们就学到了运算符优先级的精髓，在编程中也是这么继承下来的。例如：\n-3 * 2 + 5 / - 2 - 4\n相当于\n(-3) * 2 + 5 / (-2) - 4\n其实这个多做练习自然就记住了，不用刻意去背。当然在适当的地方加上括号强调一下优先级小甲鱼觉得会是更好的方案。\nPython还有一个特殊的乘法，就是双星号（**），也称为幂运算操作符。例如3 ** 2，双星号左侧的3称为底数，右侧的2称为指数，把这样的算式叫作3的2次幂，结果就是3 * 3==9。\n[1]\n3.10.3　比较操作符\n比较操作符包括：\n这个之前讲过了，比较操作符根据表达式的值的真假返回布尔类型的值。这里不重复讲解，列举出来给大家回顾一下而已。\n3.10.4　逻辑操作符\n逻辑操作符包括：\nand or not\nand操作符之前已经学习过，在实例中也多次使用，当只有and操作符左边的操作数为真，且右边的操作符同时为真的时候，结果为真。\nor操作符跟and操作符不同，or操作符只需要左边或者右边任意一边为真，结果都为真；只有当两边同时为假，结果才为假。\nnot操作符是一个一元操作符，它的作用是得到一个和操作数相反的布尔类型的值：\n噢，对了，你可能会看到这样的表达式：\n这在其他编程语言一般是不合法的，但在Python中是行得通的，它事实上被解释为：\n最后，将目前接触的所有操作符的优先级合并在一起，如图3-1所示。\n图3-1　Python操作符优先级\n[1]\n第4章　了不起的分支和循环\n4.1　分支和循环\n有人说，了不起的C语言，因为“机器码生汇编，汇编生C，C生万物”，它几乎铸造了如今IT时代的一切，它是一切的开端，并且仍然没被日新月异的时代所淘汰。\n有人可能会反对，因为首先C语言不是世界上第一门编程语言，它仍然要被降级为汇编语言再到机器语言才能为计算机所理解。\n这话题扯得有点太远了，小甲鱼想说的是，其实很多初学者会对编程语言有一种莫名其妙的崇拜感？所以呢，他们必须要找出一门全世界公认最牛的语言再来学习好它。\n其实，世界上根本没有最优秀的编程语言，只有最合适的语言，面对不同的环境和需求，就会有不同的编程工具去迎合。\n今天的主题是“了不起的分支和循环”，为什么小甲鱼不说C语言，不说Python了不起，却毫不吝啬地对分支和循环这两个知识点那么“崇拜”呢？\n大家在前面也接触了最简单的分支和循环的使用，那么小甲鱼希望大家思考一下：如果没有分支和循环，我们的程序会变成怎样？\n没错，就会变成一堆从上到下依次执行、毫无趣味的代码！还能实现算法吗？当然不能！\n幸好，所有能称得上编程语言的，都应该拥有分支和循环这两种实现。接下来从游戏的角度来谈谈，“打飞机”游戏相信大家非常熟悉了，如图4-1所示。\n那么现在就从打飞机来解释一般游戏的组成和架构。\n首先进入游戏，很容易发现其实就是进入一个大循环，虽然小甲鱼现在跟大家讨论的是打飞机，但基本上每一个游戏的套路都是一样的，甚至操作系统的消息机制使用的也是同样一个大循环来完成的。游戏中，只要没有触发死亡机制（注：这个游戏的死亡机制是撞到敌机），敌机都会不断地生成，这足以证明整个游戏就是在一个循环中执行的。\n接下来来看一下分支的概念，分支也就是所习惯使用的if条件判断，在条件持续保持成立或不成立的情况下，我们都执行固定的流程。一旦条件发生了改变，原来成立的条件就变成不成立，那么程序就走入另一条路了。就好比如拿我们的飞机去撞击敌机……如图4-2所示。\n另外，大家有没有发现，小飞机都是一个样子的？嗯，这说明它们来自于同一个对象的复制品，Python是面向对象的编程，对象这个概念无时无刻不融入在Python的血液里，只是暂时还没有接触这个概念，所以有些朋友还意识不到，不用急，以后会详细讲解这个概念的。\n图4-1　打飞机游戏\n图4-2　打飞机游戏结束界面\n最后我要不要告诉大家这个小游戏就只是用了几个循环和if条件就写出来啦？没错，编程其实就是这么简单。当然大家要达到自己可以动手写一个界面小游戏的水平，还需要掌握更多的知识！现在需要大家一起来动手，按照刚才看到的小游戏，请拿出纸和笔，将它的实现逻辑尝试给勾画出来（可以使用文字描述，现在只谈框架，不谈代码）。\n参考框架如下：\n加载背景音乐 播放背景音乐 我方飞机诞生 interval = 0 while True: if 用户是否单击了关闭按钮: 退出程序 interval += 1 if interval == 50: 小飞机诞生 小飞机移动一个位置 屏幕刷新 interval = 0 if 用户鼠标产生移动: 我方飞机中心位置 = 用户鼠标位置 屏幕刷新 if 我方飞机与小飞机发生肢体接触: 我方挂,播放撞机音乐 修改我方飞机图案 打印＂GAME OVER＂ 停止背景音乐\n4.2　课堂小练习\n前面教大家如何正确打飞机，其要点就是：判断和循环，判断就是应不应该做某事，循环就是持续做某事。条件分支，也就是判断，习惯用到的是if-else的搭配，而循环就用我们已经掌握了的while语句。\n现在来考考大家：按照100分制，90分以上成绩为A，80～90为B，60～80为C，60以下为D。现在要求你写一个程序，当用户输入分数，自动转换为A、B、C或D的形式打印。\n如果是这样写，条件多了可能会有诸多不便，你完全可以偷懒一下：\n4.3　结果分析\n假设输入的分数是98，按照第一种方法是第一次判断成立，接着打印字母A，但接着会进行第二、三、四、五次判断，然后条件都不符合，退出程序。\n若采用第二、第三种方法，那么在第一次判断成立并打印字母A后，接着不需要再进行任何判断就可以直接退出程序。可见虽然是很简单的例子，但就输入的98来说，假设每一次判断会消耗一个CPU时间，那么第一种方法比第二和第三种方法多消耗了400%的时间！\n所以要实现一个程序事实上并不难，但作为一个优秀的程序员，你必须要形成良好的编程思维。而Python这门语言本身就可以锻炼你这方面的能力。不信？来看下一个问题：Python可以有效避免“悬挂else”。\n4.4　Python可以有效避免“悬挂else”\n什么叫“悬挂else”？举个例子，初学C语言的朋友可能很容易被以下代码欺骗。\n在这个例子中，虽然else是想和外层的if匹配，但事实上按照C语言的就近匹配原则这个else是属于内层if的。由于初学者的一不小心，就容易导致BUG的出现。这就是著名的“悬挂else”。\n而Python的缩进使用强制规定使得代码必须正确对齐，让程序员来决定else到底属于哪一个if。限制你的选择从而减少了不确定性，Python鼓励你第一次就写出正确的代码。所以在Python中制造出“悬挂else”的问题是不可能的。而且，强制使用正确的缩进，Python的代码变得整洁易读，这就是大家都喜欢Python的原因。\n4.5　条件表达式（三元操作符）\n我们说“多少元”操作符的意思是这个操作符有多少个操作数。例如赋值操作符“=”是二元操作符，所以它有左边和右边两个操作数。例如“-”是一元操作符，它表示负号，因为只有一个操作数。那么三元操作符就应该有三个操作数咯？没错的，你猜对了。\n其实Python的作者一向推崇简洁编程理念，所以很长一段时间Python都没有三元操作符这么个概念（因为Python觉得三元操作符使得程序结构变复杂了），但是Python社区的小伙伴们表达了极大的诉求，所以最终Python的作者为Python加入了这个三元操作符。有了这个三元操作符的条件表达式，你可以使用一条语句来完成以下的条件判断和赋值操作：\n那么将上边的代码用传说中的三元操作符表示应该是怎样的呢？\n三元操作符语法：\na = x if条件else y\n表示当条件为True的时候，a的值赋值为x，否则赋值为y。\n所以，上面的例子可以改进为：\n4.6　断言\n断言（assert）的语法其实有点像是if条件分支语句的“近亲”，所以就放在一块来讲了。assert这个关键字称为“断言”，当这个关键字后边的条件为假的时候，程序自动崩溃并抛出AssertionError的异常。\n什么情况下需要这样的代码呢？当我们在测试程序的时候就很好用，因为与其让错误的条件导致程序今后莫名其妙地崩溃，不如在错误条件出现的那一瞬间实现“自我毁灭”：\n一般来说，可以用它在程序中置入检查点，当需要确保程序中的某个条件一定为真才能让程序正常工作时，assert关键字就非常有用了。\n4.7　while循环语句\nPython的while循环跟if条件分支类似，在条件为真的情况下，执行一段代码，不同的是，只要条件为真，while循环会一直重复执行那段代码，把这段代码称为循环体。\nwhile条件: 循环体\n4.8　for循环语句\n[1]\n一起来实验一下：\n4.9　range()\nfor循环其实还有一个小伙伴：range()内建函数。\n语法：\nrange([start, ]stop[, step = 1])\n这个BIF有三个参数，其中用中括号括起来的两个表示这两个参数是可选的。step=1表示第三个参数的默认值是1。零基础的朋友因为还没有学到函数，对于参数这个概念可能不理解，没事，暂时你就认为是函数的装备，函数有了装备攻击力什么的都会相应增加。\nrange这个BIF的作用是生成一个从start参数的值开始，到stop参数的值结束的数字序列。常与for循环混迹于各种计数循环之间。\n只传递一个参数的range()，例如range（5），它会将第一个参数默认设置为0，生成0～5的所有数字（注：包含0但不包含5）。\n传递两个参数的range()：\n传递三个参数的range()：\nrange()可以说是跟for循环最适合做搭档的小伙伴，当然，for循环魅力很大，它还有其他各式各样的小伙伴配合实现各种乱七八糟的功能，这个在讲解列表和元组的时候再介绍给大家吧。\n4.10　break语句\nbreak语句的作用是终止当前循环，跳出循环体。举个例子：\n程序运行后，只有当用户输入“小甲鱼是帅哥”的时候，才会执行break语句，也就是跳出while循环体：\n4.11　continue语句\ncontinue语句的作用是终止本轮循环并开始下一轮循环（这里要注意的是：在开始下一轮循环之前，会先测试循环条件）。举个例子：\n大家不妨在不运行程序的情况下目测一下这个程序会打印出什么？\n[1]\n第5章　列表、元组合字符串\n5.1　列表：一个“打了激素”的数组\n有时候需要把一堆东西暂时存储起来，因为它们有某种直接或者间接的联系，需要把它们放在某种“组”或者“集合”中，因为将来可能用得上。很多接触过编程的朋友都知道或者听说过数组。数组这个概念呢，就是把一大堆同种类型的数据挨个儿摆在一块儿，然后通过数组下标进行索引。但数组有一个基本要求，就是你所放在一起的数据必须类型一致。由于Python的变量没有数据类型，也就是说，Python是没有数组的。但是呢，Python加入了更为强大的列表。\nPython的列表有多强大？如果把数组比作是一个集装箱的话，那么Python的列表就是一个工厂的仓库了。列表真的非常有用，基本上所有的Python程序都要使用到列表，包括之前的打飞机游戏，里边的小飞机可以全部扔到一个列表中统一管理。\n5.1.1　创建列表\n创建列表和创建普通变量一样，用中括号括起一堆数据就可以了，数据之间用逗号隔开，这样一个普普通通的列表就创建成功了：\n我们说列表是打了激素的数组不是没有道理的，可以创建一个鱼龙混杂的列表：\n可以看到上边这个列表里有整型、字符串、浮点型数据，甚至还可以包含着另一个列表。当然，如果实在想不到要往列表里边塞什么数据的时候，可以先创建一个空列表：\n5.1.2　向列表添加元素\n列表相当灵活，所以它的内容不可能总是固定的，现在就来教大家如何向列表添加元素吧。要向列表添加元素，可以使用append()方法：\n可以看到，参数6已经被添加到列表number的末尾了。有读者可能会问，这个方法调用怎么跟平时的BIF内置函数调用不一样呢？嗯，因为append()不是一个BIF，它是属于列表对象的一个方法。\n中间这个“.”，大家暂时可以理解为范围的意思：append()这个方法是属于一个叫作number的列表对象的。关于对象的知识，咱暂时只需要理解这么多，后边再给大家介绍对象。同理，我们可以把数字7和8添加进去，但是我们发现似乎不能用append()同时添加多个元素：\n这时候就可以使用extend()方法向列表末尾添加多个元素：\n哎呀，怎么又报错了呢？！嗯，其实小甲鱼是故意的。extend()方法事实上使用一个列表来扩展另一个列表，所以它的参数应该是一个列表：\n好，我们又再一次向世界证明我们成功了！但是又发现了一个问题，到目前为止，我们都是往列表的末尾添加数据，那如果我想“插队”呢？\n当然没问题，想要往列表的任意位置插入元素，就要使用insert()方法。insert()方法有两个参数：第一个参数代表在列表中的位置，第二个参数是在这个位置处插入一个元素。不妨来试一下，让数字0出现在列表number的最前边：\n等等，不是说好插入到第一个位置吗？怎么插入后0还是排在1的后边呢？其实是这样的：凡是顺序索引，Python均从0开始，同时这也是大多数编程语言约定俗成的规范。那么大家知道为什么要用0来表示第一个数吗？\n是因为计算机本身就是二进制的，在二进制的世界里只有两个数：0和1，当然，0就是二进制里的第一个数了，所以嘛，秉承着这样的传统，0也就习惯用于表示第一个数。所以，正确的做法应该是：\n5.1.3　从列表中获取元素\n跟数组一样，可以通过元素的索引值（index）从列表获取单个元素，注意，列表索引值是从0开始的：\n那按照这个方法让“李狗蛋”和“鸭蛋”的位置互调：\n5.1.4　从列表删除元素\n从列表删除元素，这里也介绍三种方法：remove()、del和pop()。先演示一下用remove()删除元素：\n使用remove()删除元素，你并不需要知道这个元素在列表中的具体位置，只需要知道该元素存在列表中就可以了。如果要删除的东西根本不在列表中，程序就会报错：\nremove()方法并不能指定删除某个位置的元素，这时就要用del来实现：\n注意，del是一个语句，不是一个列表的方法，所以你不必在它后边加上小括号()。另外，如果你想删除整个列表，还可以直接用del加列表名删除：\n最后，演示用pop()方法“弹出”元素：\n大家看到了，pop()方法默认是弹出列表中的最后一个元素。但这个pop()方法其实还可以灵活运用，当你为它加上一个索引值作为参数的时候，它会弹出这个索引值对应的元素：\n5.1.5　列表分片\n利用索引值，每次可以从列表获取一个元素，但是人总是贪心的，如果需要一次性获取多个元素，有没有办法实现呢？利用列表分片（slice），可以方便地实现这个要求：\n很简单对吧？只不过是用一个冒号隔开两个索引值，左边是开始位置，右边是结束位置。这里要注意的一点是，结束位置上的元素是不包含的。利用列表分片，得到一个原来列表的拷贝，原来列表并没有发生改变。\n列表分片也可以简写，我们说过Python就是以简洁闻名于世，所以你能想到的“便捷方案”，Python的作者以及Python社区的小伙伴们都已经想到了，并付诸实践，你要做的就是验证一下是否可行：\n如果没有开始位置，Python会默认开始位置是0。同样道理，如果要得到从指定索引值到列表末尾的所有元素，把结束位置省去即可。如果没有放入任何索引值，而只有一个冒号，将得到整个列表的拷贝。\n再一次强调：列表分片就是建立原列表的一个拷贝（或者说副本），所以如果你想对列表做出某些修改，但同时还想保持原来的那个列表，那么直接使用分片的方法来获取拷贝就很方便了。\n5.1.6　列表分片的进阶玩法\n分片操作实际上还可以接收第三个参数，其代表的是步长，默认情况下（不指定它的时候）该值为1，来试试将其改成2会有什么效果？\n如果将步长改成2，那么每前进两个元素才取一个出来。其实还可以直接写成list1[：：2]。如果步长的值是负数，例如-1，结果会怎样呢？不妨试试看：\n是不是很有意思？这里步长设置为-1，就相当于复制一个反转的列表。\n5.1.7　一些常用操作符\n此前学过的大多数操作符都可以运用到列表上：\n我们发现列表还是挺聪明的，竟然会懂得比较大小。那如果列表中不止一个元素呢？结果又会如何？\n怎么会这样？list1列表的和是123+456=579，按理应该比list2列表的和234+123=357要大，为什么list1>list2还会返回False呢？\n思考片刻后得出结论：Python的列表原来并没有我们想象中那么“智能”（注：在后边讲“魔法方法”的章节会教大家如何把列表改变得更加聪明），当列表包含多个元素的时候，默认是从第一个元素开始比较，只要有一个PK赢了，就算整个列表赢了。字符串比较也是同样的道理（字符串比较的是第一个字符对应的ASCII码值的大小）。\n我们知道字符串可以用加号（＋）来进行拼接，用乘号（*）来复制自身若干次。它们在列表身上也是可以实现的：\n加号（＋）也叫连接操作符，它允许我们把多个列表对象合并在一起，其实就相当于extend()方法实现的效果。一般情况下建议大家使用extend()方法来扩展列表，因为这样显得更为规范和专业。另外，连接操作符并不能实现列表添加新元素的操作：\n所以如果要添加一个元素到列表中，用什么方法？嗯，可以用append()或者insert()方法，希望大家还记得。乘号（*）也叫重复操作符，重复操作符可以用于列表中：\n当然复合赋值运算符也可以用于列表：\n另外有个成员关系操作符大家也不陌生，我们是在谈for循环的时候认识它的，成员关系操作符就是in和not in！\n之前说过列表里边可以包含另一个列表，那么对于列表中的列表元素，能不能使用in和not in测试呢？试试便知：\n可见，in和not in只能判断一个层次的成员关系，这跟break和continue语句只能作用于一个层次的循环是一个道理。那要判断列表里边的列表的元素，应该先进入一层列表：\n顺便说一下，前面提到使用索引号去访问列表中的值，那么对于列表中的列表，应该如何访问呢？\n大家应该猜到了，其实跟C语言访问二维数组的方法相似：\n5.1.8　列表的小伙伴们\n接下来认识一下列表的小伙伴们，那么列表有多少小伙伴呢？不妨让Python自己告诉我们：\n产生了一个熟悉又陌生的列表，很多熟悉的方法似曾相识，例如append()、extend()、insert()、pop()、remove()都是学过的。现在再给大家介绍几个常用的方法。\ncount()这个方法的作用是计算它的参数在列表中出现的次数：\nindex()这个方法会返回它的参数在列表中的位置：\n可以看到，这里是返回第一个目标（1）在list1中的位置，index()方法还有两个参数，用于限定查找的范围。因此可以这样查找第二个目标在list1的位置：\nreverse()方法的作用是将整个列表原地翻转，就是排最后的放到最前边，排最前的放到最后，那么排倒数第二的就排在第二，以此类推：\nsort()这个方法是用指定的方式对列表的成员进行排序，默认不需要参数，从小到大排队：\n那如果需要从大到小排队呢？很简单，先调用sort()方法，列表会先从小到大排好队，然后调用reverse()方法原地翻转就可以啦。\n[1]\nfunc和key参数用于设置排序的算法和关键字，默认是使用归并排序，算法问题不在这里讨论，有兴趣的朋友可以看一下小甲鱼另一本不错的教程：《数据结构和算法》（C语言）。这里要讨论sort()方法的第三个参数：reverse，没错，就是刚刚学的那个reverse()方法的那个reverse。不过这里作为sort()的一个默认参数，它的默认值是sort(reverse=False)，表示不颠倒顺序。因此，只需要把False改为True，列表就相当于从大到小排序：\n5.1.9　关于分片“拷贝”概念的补充\n上一节提到使用分片创建列表的拷贝：\n看似一样，对吧？但事实上呢？利用列表的一个小伙伴做以下修改，大家看看差别：\n可以看到list1已经从小到大排好了序，那list2和list3呢？使用分片方式得到的list2很有原则、很有格调，并不会因为list1的改变而改变，这个原理我待会儿跟大家说；接着看list3……看，真正的墙头草是list3，它竟然跟着list1改变了，这是为什么呢？\n不知道大家还记不记得在讲解变量的时候说过，Python的变量就像一个标签，就一个名字而已……还是给大家画个图好理解，如图5-1所示。\n图5-1　拷贝列表\n这下大家应该明白了吧，为一个列表指定另一个名字的做法，只是向同一个列表增加一个新的标签而已，真正的拷贝是要使用分片的方法。这个也是初学者最容易混淆的地方，大家以后写代码时一定要注意哦。\n5.2　元组：戴上了枷锁的列表\n早在三百多年前，孟德斯鸠在《论法的精神》里边就提到“一切拥有权力的人都容易滥用权力，这是万古不变的一条经验。”但是凡是拥有大权力的人，都想用自身的实践证明孟德斯鸠是一个只会说屁话的家伙，但是他们好像都失败了……\n由于列表过分强大，Python的作者觉得这样似乎不妥，于是发明了列表的“表亲”——元组。\n元组和列表最大的区别就是你可以任意修改列表中的元素，可以任意插入或者删除一个元素，而对元组是不行的，元组是不可改变的（像字符串一样），所以你也别指望对元组进行原地排序等高级操作了。\n5.2.1　创建和访问一个元组\n元组和列表，除了不可改变这个显著特征之外，还有一个明显的区别是，创建列表用的是中括号，而创建元组大部分时候用的是小括号（注意，我这里说的是大部分）：\n访问元组的方式与列表无异：\n也使用分片的方式来复制一个元组：\n如果你试图修改元组的一个元素，那么抱歉，Python会很不开心：\n我很好奇如果问你，列表的标志性符号是中括号（[]），那么元组的标志性符号是什么？你会怎么回答呢？\n小甲鱼相信百分之九十的朋友都会不假思索地回答：小括号啊，有部分比较激进的朋友还可能会补充一句“小甲鱼你傻啊？”\n好吧，这个问题其实也是大部分初学者所忽略和容易上当的，我们实验一下：\n还记得type()方法吧，作用是返回参数的类型，这里它返回说temp变量是整型（int）。再试试：\n噢，发现了吧？就算没有小括号，temp还是元组类型，所以逗号（，）才是关键，小括号只是起到补充的作用。但是你如果想要创建一个空元组，那么你就直接使用小括号即可：\n所以这里要注意的是，如果要创建的元组中只有一个元素，请在它后边加上一个逗号（，），这样可以明确告诉Python你要的是一个元组，不要拿什么整型、浮点型来忽悠你：\n为了证明逗号（，）起到了决定性作用，再给大家举个例子：\n5.2.2　更新和删除元组\n有朋友可能会说，刚才不是你自己说“元组是板上钉钉不能修改的吗”？你现在又来谈更新一个元组，小甲鱼你这不是自己打脸吗？\n大家不要激动……我们只是讨论一个相对含蓄的做法（直接在同一个元组上更新是不可行的，除非你学习了后边的“魔法方法”章节）。不知道大家还记不记得以前是如何更新一个字符串的？没错，是通过拷贝现有的字符串片段构造一个新的字符串的方式解决的，对元组也是使用同样的方法：\n上面的代码需要在“小鸭”和“小猪”中间插入“小甲鱼”，那么通过分片的方法让元组拆分为两部分，然后再使用连接操作符（＋）合并成一个新元组，最后将原来的变量名（temp）指向连接好的新元组。不妨可以把这样的做法称为“狸猫换太子”。在这里就要注意了，逗号是必需的，小括号也是必需的！\n在谈到列表的时候，小甲鱼跟大家说有三个方法可以删除列表里边的元素，但是对于元组是不可变的原则来说，单独删除一个元素是不可能的，当然你可以用刚才小甲鱼教给大家更新元组的方法，间接地删除一个元素：\n如果要删除整个元组，只要使用del语句即可显式地删除一个元组：\n其实在日常使用中，很少使用del去删除整个元组，因为Python的回收机制会在这个元组不再被使用到的时候自动删除。\n最后小结一下哪些操作符可以使用在元组上，拼接操作符和重复操作符刚刚演示过了，关系操作符、逻辑操作符和成员关系操作符in和not in也可以直接应用在元组上，这跟列表是一样的，大家自己实践一下就知道了。关于列表和元组，我们今后会谈得更多，目前，就先聊到这里。\n5.3　字符串\n或许现在又回过头来谈字符串，有些朋友可能会觉得没必要。\n其实关于字符串，还有很多你可能不知道的秘密，由于字符串在日常使用中是如此常见，因此小甲鱼抱着负责任的态度在本节把所知道的都倒出来跟大家分享一下。\n关于创建和访问字符串，前面已经介绍过了。不过学了列表和元组，我们知道了分片的概念，事实上也可以应用于字符串之上：\n接触过C语言的朋友应该知道，在C语言中，字符串和字符是两个不同的概念（C语言用单引号表示字符，双引号表示字符串）。但在Python并没有字符这个类型，在Python看来，所谓字符，就是长度为1的字符串。当要访问字符串的其中一个字符的时候，只需用索引列表或元组的方法来索引字符串即可：\n字符串跟元组一样，都是属于“一言既出、驷马难追”的家伙。所以一旦定下来就不能直接对它们进行修改了，如果必须要修改，我们就需要委曲求全……\n但是大家要注意，这种通过拼接旧字符串的各个部分得到新字符串的方式并不是真正意义上的改变原始字符串，原来的那个“家伙”还在，只是将变量指向了新的字符串（旧的字符串一旦失去了变量的引用，就会被Python的垃圾回收机制释放掉）。\n像比较操作符、逻辑操作符、成员关系操作符等的操作跟列表和元组是一样的，这里就不再啰唆了。\n5.3.1　各种内置方法\n列表和元组都有它们的方法，大家可能觉得列表的方法已经非常多了，其实字符串更多呢。表5-1总结了字符串的所有方法及对应的含义。\n表5-1　Python字符串的方法\n续表\n这里选几个常用的给大家演示一下用法，首先是casefold()方法，它的作用是将字符串的所有字符变为小写：\ncount(sub[, start[, end]])方法之前试过了，就是查找sub子字符串出现的次数，可选参数（注：在Python文档中，用方括号（[]）括起来表示为可选）start和end表示查找的范围：\n如果要查找某个子字符串在该字符串中的位置，可以使用find(sub[, start[, end]])或index(sub[, start[, end]])方法。如果找到了，则返回值是第一个字符的索引值；如果找不到，则find()方法会返回-1，而index()方法会抛出异常（注：异常是可以被捕获并处理的错误，目前你可以认为就是错误）：\n今后你可能会在很多文档中看到join(sub)的身影，程序员喜欢用它来连接字符串，但它的用法也许会让你感到诧异。join是以字符串作为分隔符，插入到sub字符串中所有的字符之间：\n为什么说“程序员喜欢用join()来连接字符串”，我们不是有很好用的连接符号（＋）吗？这是因为当使用连接符号（＋）去拼接大量的字符串时是非常低效率的，因为加号连接会引起内存复制以及垃圾回收操作。所以对于大量的字符串拼接来说，使用join()方法的效率要高一些：\nreplace(old, new[, count])方法如其名，就是替换指定的字符串：\nsplit(sep = None, maxsplit = G1)跟join()正好相反，split()用于拆分字符串：\n5.3.2　格式化\n前面介绍了Python字符串大部分方法的使用，但唯独漏了一个format()方法。因为小甲鱼觉得format()方法跟本节的话题如出一辙，都是关于字符串的格式化，所以放一块来讲解。\n那什么是字符串的格式化，又为什么需要对字符串进行格式化呢？举个小例子给大家听：某天小甲鱼召开了鱼C国际互联安全大会，到会的朋友有来自世界各地的各界精英人士，有小乌龟、喵星人、旺星人，当然还有米奇和唐老鸭。哇噻，那气势简直跟小甲鱼开了个动物园一样……但是问题来了，大家交流起来简直是鸡同鸭讲，不知所云！但是最后聪明的小甲鱼还是把问题给解决了，其实也很简单，各界都找一个翻译就行了，统一都翻译成普通话，那么问题就解决了……最后我们这个大会当然取得了卓越的成功并记入了吉尼斯动物大全。举这个例子就是想跟大家说，格式化字符串，就是按照统一的规格去输出一个字符串。如果规格不统一，就很可能造成误会，例如十六进制的10跟十进制的10或二进制的10完全是不同的概念（十六进制10等于十进制16，二进制10等于十进制2）。字符串格式化，正是帮助我们纠正并规范这类问题而存在的。\n1．format()\nformat()方法接受位置参数和关键字参数（位置参数和关键字参数在函数章节有详细讲解），二者均传递到一个叫作replacement字段。而这个replacement字段在字符串内由大括号（{}）表示。先看一个例子：\n怎么回事呢？仔细看，字符串中的{0}、{1}和{2}应该跟位置有关，依次被format()的三个参数替换，那么format()的三个参数就叫作位置参数。那什么是关键字参数呢，再来看一个例子：\n{a}、{b}和{c}就相当于三个标签，format()将参数中等值的字符串替换进去，这就是关键字参数啦。另外，你也可以综合位置参数和关键字参数在一起使用：\n但要注意的是，如果将位置参数和关键字参数综合在一起使用，那么位置参数必须在关键字参数之前，否则就会出错：\n如果要把大括号打印出来，你有办法吗？没错，这跟字符串转义字符有点像，只需要用多一层大括号包起来即可（要打印转义字符（\\），只需用转义字符转义本身（\\\\））：\n位置参数“不打印”没有被输出，这是因为{0}的特殊功能被外层的大括号（{}）剥夺，因此没有字段可以输出。注意，这并不会产生错误哦。最后来看另一个例子：\n可以看到，位置参数{1}跟平常有些不同，后边多了个冒号。在替换域中，冒号表示格式化符号的开始，“.2”的意思是四舍五入到保留两位小数点，而f的意思是浮点数，所以按照格式化符号的要求打印出了3.14。\n2．格式化操作符：%\n刚才讲的是字符串的格式化方法，现在来谈谈字符串所独享的一个操作符：%，有人说，这不是求余数的操作符吗？是的，没错。当%的左右均为数字的时候，那么它表示求余数的操作；但当它出现在字符中的时候，它表示的是格式化操作符。表5-2列举了Python的格式化符号及含义。\n表5-2　Python格式化符号及含义\n下面给大家举几个例子参考：\nPython还提供了格式化操作符的辅助指令，如表5-3所示。\n表5-3　格式化操作符的辅助指令\n同样给大家举几个例子供参考：\n3．Python的转义字符及含义\nPython的部分转义字符已经使用了一段时间，是时候来给它做个总结了，见表5-4。\n表5-4　转义字符及含义\n5.4　序列\n聪明的你可能已经发现，小甲鱼把列表、元组和字符串放在一块儿来讲解是有道理的，因为它们之间有很多共同点：\n都可以通过索引得到每一个元素。\n默认索引值总是从0开始（当然灵活的Python还支持负数索引）。\n可以通过分片的方法得到一个范围内的元素的集合。\n有很多共同的操作符（重复操作符、拼接操作符、成员关系操作符）。\n我们把它们统称为：序列！下面介绍一些关于序列的常用BIF（内建方法）。\n1．list([iterable])\nlist()方法用于把一个可迭代对象转换为列表，很多朋友经常听到“迭代”这个词，但要是让你解释的时候，很多朋友就含糊其词了：迭代……迭代就是for循环嘛……\n这里小甲鱼帮大家科普一下：所谓迭代，是重复反馈过程的活动，其目的通常是为了接近并到达所需的目标或结果。每一次对过程的重复被称为一次“迭代”，而每一次迭代得到的结果会被用来作为下一次迭代的初始值……就目前来说，迭代还就是一个for循环，但今后会介绍到迭代器，那个功能，那叫一个惊艳！\n好了，这里说list()方法要么不带参数，要么带一个可迭代对象作为参数，而这个序列天生就是可迭代对象（迭代这个概念实际上就是从序列中泛化而来的）。还是通过几个例子给大家讲解吧：\n事实上这个list()方法大家自己也可以动手实现对不对？很简单嘛，实现过程大概就是新建一个列表，然后循环通过索引迭代参数的每一个元素并加入列表，迭代完毕后返回列表即可。大家课后不妨自己动动手来尝试一下。\n2．tuple([iterable])\ntuple()方法用于把一个可迭代对象转换为元组，具体的用法和list()一样，这里就不啰唆了。\n3．str(obj)\nstr()方法用于把obj对象转换为字符串，这个方法在前面结合int()和float()方法给大家讲过，还记得吧？\n4．len(sub)\nlen()方法用于返回sub参数的长度：\n5．max(…)\nmax()方法用于返回序列或者参数集合中的最大值，也就是说，max()的参数可以是一个序列，返回值是该序列中的最大值；也可以是多个参数，那么max()将返回这些参数中最大的一个：\n6．min(…)\nmin()方法跟max()用法一样，但效果相反：返回序列或者参数集合中的最小值。这里需要注意的是，使用max()方法和min()方法都要保证序列或参数的数据类型统一，否则会出错。\n人家说：外行看热闹，内行看门道。分析一下这个错误信息。Python这里说“TypeError：unorderable types：str()>int()”，意思是说不能拿字符串和整型进行比较。这说明了什么呢？\n你看，str()>int()，说明max()方法和min()方法的内部实现事实上类似于之前提到的，通过索引得到每一个元素，然后将各个元素进行对比。所以不妨根据猜想写出可能的代码：\n由此可见，Python的内置方法其实也没啥了不起的，有些我们也可以自己实现，对吧？所以只要认真跟着本书的内容学习下去，很多看似如狼似虎的问题，将来都能迎刃而解！\n7．sum(iterable[, start])\nsum()方法用于返回序列iterable的总和，用法跟max()和min()一样。但sum()方法有一个可选参数（start），如果设置该参数，表示从该值开始加起，默认值是0：\n8．sorted(iterable, key=None, reverse=False)\nsorted()方法用于返回一个排序的列表，大家还记得列表的内建方法sort()吗？它们的实现效果一致，但列表的内建方法sort()是实现列表原地排序；而sorted()是返回一个排序后的新列表。\n9．reversed(sequence)\nreversed()方法用于返回逆向迭代序列的值。同样的道理，实现效果跟列表的内建方法reverse()一致。区别是列表的内建方法是原地翻转，而reversed()是返回一个翻转后的迭代器对象。你没看错，它不是返回一个列表，是返回一个迭代器对象：\n10．enumerate(iterable)\nenumerate()方法生成由二元组（二元组就是元素数量为二的元组）构成的一个迭代对象，每个二元组是由可迭代参数的索引号及其对应的元素组成的。举个例子你就明白了：\n11．zip(iter1[, iter2[...]])\nzip()方法用于返回由各个可迭代参数共同组成的元组，举个例子比较容易理解：\n[1]\n第6章　函数\n6.1　Python的乐高积木\n小时候大家应该都玩过乐高积木，只要通过想象和创意，可以用它拼凑出很多神奇的东西。随着学习的深入，编写的代码日益增加并且越来越复杂，所以需要找一个方法对这些复杂的代码进行重新组织。这么做的目的是使得代码更为简单易懂。我们说优秀的东西永远是经典的，而经典的东西永远是简单的。不是说复杂不好，要能够把复杂的东西简单化才能成为经典。\n为了使得程序的代码更为简单，就需要把程序分解成较小的组成部分。这里会教大家三种方法来实现，分别是函数、对象和模块。\n6.1.1　创建和调用函数\n函数就是把代码打包成不同形状的乐高积木，以便可以发挥想象力进行随意拼装和反复使用。此前接触的BIF就是Python帮我们封装好的函数，用的时候很方便，根本不需要去想实现的原理，这就是把复杂变简单。\n因为这几部分内容奠定了Python编程者的基本功底，所以小甲鱼在这几部分的准备上是花足了心思的，大家不要嫌啰唆——经常变着花样儿重复出现的内容肯定是最重要的。\n简单来讲，一个程序可以按照不同功能的实现，分割成许许多多的代码块，每一个代码块就可以封装成一个函数。在Python中创建一个函数用def关键字：\n注意，在函数名后边要加上一对小括号哦。这对小括号是必不可少的，因为有时候需要在里边放点东西，至于放什么，小甲鱼先卖个关子，待会儿告诉你。\n我们创建了一个函数，但是从来都不去调用它，那么这个函数里的代码就永远也不会被执行。这里教大家如何调用一个函数。调用一个函数也非常简单，直接写出函数名加上小括号即可：\n函数的调用和运行机制：当函数myFirstFunction()发生调用操作的时候，Python会自动往上找到def myFirstFunction()的定义过程，然后依次执行该函数所包含的代码块部分（也就是冒号后边的缩进部分内容）。只需要一条语句，就可以轻松地实现函数内的所有功能。假如我想把刚才的内容打印3次，我只需要调用3次函数即可：\n6.1.2　函数的参数\n现在可以来谈谈括号里是什么东西了！其实括号里放的就是函数的参数。在函数刚开始被发明出来的时候，是没有参数的（也就是说，小括号里没有内容），很快就引来了许多小伙伴们的质疑：函数不过是对做同样内容的代码进行打包，这样跟使用循环就没有什么本质不同了。\n所以，为了使每次调用的函数可以有不同的实现，加入了参数的概念。例如，你封装了一个开炮功能的函数，默认武器是大炮，那用来打飞机是没问题的，但是你如果用这个函数来打小鸟，除非是愤怒的小鸟，否则就有点奇葩了。有了参数的实现，就可以轻松地将大炮换成步枪。总而言之，参数就是使得函数可以实现个性化：\n刚才的例子只有一个参数，使用多个参数，只需要用逗号隔开即可：\n那有些读者要问了，到底Python的函数支持多少参数呢？实际上你想要有多少个参数就可以有多少个参数，就像Windows的某些API函数就有十几个参数。但是建议大家自己定义的函数参数尽量不要太多，函数的功能和参数的意义也要相应写好注释，这样别人来维护你的程序才不会那么费劲！\n6.1.3　函数的返回值\n有些时候，需要函数为我们返回一些数据来报告执行的结果，譬如刚才提到具有开炮功能的函数，炮弹发射了之后到底是打中了没有？你总得有个交代吧。所以，我们的函数需要返回值。其实也非常简单，只需要在函数中使用关键字return，后边跟着的就是指定要返回的值：\n6.2　灵活即强大\n有时候，评论一种编程语言是否优秀，往往是看它是否灵活。灵活并非意味着无所不能、无所不包，那样就会显得庞大和冗杂。灵活应该表现为多变，比如前面学到的参数，函数因参数而灵活。如果没有参数，一个函数就只能死板地完成一个功能、一项任务。\n6.2.1　形参和实参\n参数从调用的角度来说，分为形式参数（parameter）和实际参数（argument）（注：本书后边简称为形参和实参）。跟绝大多数编程语言一样，形参指的是函数创建和定义过程中小括号里的参数，而实参则指的是函数在被调用的过程中传递进来的参数。举个例子：\nmyFristFunction(name)的name是形参，因为它只是代表一个位置、一个变量名；而调用myFirstFunction（＂小甲鱼＂）传递的＂小甲鱼＂是实参，因为它是一个具体的内容，是赋值到变量名中的值！\n6.2.2　函数文档\n给函数写文档是为了让别人可以更好地理解你的函数，所以这是一个好习惯。有些读者可能不理解为什么自己写的函数要跟别人分享呢？因为在实际开发中，个人的工作量和能力确实相当有限，因此中大型的程序永远都是团队来完成的。大家的代码要相互衔接，就需要先阅读别人提供的文档，因此适当的文档说明非常重要。而函数文档的作用是描述该函数的功能，当然，这是写给人看的：\n我们看到，在函数开头写下的字符串是不会打印出来的，但它会作为函数的一部分存储起来。这个称为函数文档字符串，它的功能跟注释是一样的。\n那有读者可能会说，既然一样，搞那么复杂干啥呀？其实也不是完全一样，函数的文档字符串可以通过特殊属性__doc__获取（注：__doc__两边分别是两条下划线）：\n另外，想用一个函数却不确定其用法的时候，会通过help()函数来查看函数的文档。因此，对我们自己的函数也可以依法炮制：\n6.2.3　关键字参数\n普通的参数叫位置参数，通常在调用一个函数的时候，粗心的程序员很容易会搞乱位置参数的顺序，以至于函数无法按照预期实现。因此，有了关键字参数。使用关键字参数，就可以很简单地解决这个潜在的问题，来看个例子：\n关键字参数其实就是在传入实参时指定形参的变量名，尽管使用这种技巧要多打一些字，但随着程序规模越来越大、参数越来越多，关键字参数起到的作用就越明显。毕竟宁可多打几个字符，也不希望出现料想不及的BUG。\n6.2.4　默认参数\n初学者很容易搞混关键字参数和默认参数，默认参数是在定义的时候赋予了默认值的参数：\n使用默认参数的话，就可以不带参数去调用函数。所以，它们之间的区别是：关键字参数是在函数调用的时候，通过参数名指定要赋值的参数，这样做就不怕因为搞不清参数的顺序而导致函数调用出错；而默认参数是在参数定义的过程中，为形参赋初值，当函数调用的时候，不传递实参，则默认使用形参的初始值代替。\n6.2.5　收集参数\n这个名字听起来比较新鲜，其实大多数时候它也被称作可变参数。发明这种机制的动机是函数的作者有时候也不知道这个函数到底需要多少个参数……听起来有点令人不解，但确实有这类情况。这时候，仅需要在参数前边加上星号（*）即可：\n其实大家仔细思考后也不难理解，Python就是把标志为收集参数的参数们打包成一个元组。不过这里需要注意一下，如果在收集参数后边还需要指定其他参数，在调用函数的时候就应该使用关键参数来指定，否则Python就都会把你的实参都列入收集参数的范畴。举个例子：\n建议大家如果你的参数中带有收集参数，那么可将其他参数设置为默认参数，这样不容易出错：\n星号（*）其实既可以打包又可以“解包”。“解包”又是怎么回事呢？举个例子，假如你需要将一个列表a传入test参数的收集参数* param中，那么调用test(a)时便会出错，此时需要在a前边加上个星号（*）表示实参需要“解包”后才能使用：\nPython还有另一种收集方式，就是用两个星号（**）表示。跟前面的介绍不同，两个星号的收集参数表示为将参数们打包成字典的形式。字典的概念还没有接触，所以在后边讲解字典的章节中再给大家介绍吧。\n6.3　我的地盘听我的\n6.3.1　函数和过程\n在很多编程语言中，函数和过程其实是区分开的。一般认为函数（function）是有返回值的，而过程（procedure）是简单、特殊并且没有返回值的。也就是说，函数是干完事儿必须写报告的“苦逼”，而过程是完事后拍拍屁股一走了之的“小混蛋”。\nPython严格来说只有函数，没有过程！此话怎讲？有些朋友可能会说，在没有介绍return之前，Python的函数不也没有返回值吗？此言差矣，为了让大家更好地理解“Python严格来说只有函数，没有过程！”这句话，大家一起看看下面的例子：\n调用print(hello())之后打印了两行文字，第一行我们当然知道是hello()函数执行的，第二行的None是怎么回事？没错，大家猜对了。当不写return语句的时候，默认Python会认为函数是return None的。所以说Python所有的函数都有返回值。\n6.3.2　再谈谈返回值\n在许多编程语言中，我们说一个函数是整型，其实我们的意思是指这个函数会返回一个整型的返回值。而Python不这么干，Python可以动态确定函数的类型，而且函数还能返回不同类型的值。还记得以前说过“Python没有变量，只有名字”这句话吗？只需知道Python会返回一个东西，然后拿来用就可以了。另外，Python似乎还可以同时返回多个值：\nPython可以利用列表打包多种类型的值一次性返回。当然，你也可以直接用元组的形式返回多个值：\n6.3.3　函数变量的作用域\n其实这里要谈的是函数变量的作用域，也许你早已经听说了局部变量和全局变量，也许你早已经熟练于其他编程语言的变量作用域的细节，但无论如何这里你要认真学，因为这是重点，也许真有你平时注意不到的细节呢。\n变量的作用域也就是平时所说的变量可见性，如上所说，一般的编程语言都有局部变量（Local Variable）和全局变量（Global Variable）之分。分析以下代码：\n程序执行结果如下：\n来分析一下代码：在函数discounts()中，两个参数是price和rate，还有一个是final_price，它们都是discounts()函数中的局部变量。为什么把它们称为局部变量呢？不妨修改一下代码：\n程序走起，像刚才一样输入之后程序便报错了：\n错误原因：final_price没有被定义过，也就是说，Python找不到final_price这个变量。这是因为final_price只是一个局部变量，它的作用范围只在它的地盘上——discounts()函数的定义范围内——有效，出了这个范围，就不再属于它的地盘了，它将什么都不是。\n总结一下：在函数里边定义的参数以及变量，都称为局部变量，出了这个函数，这些变量都是无效的。事实上的原理是，Python在运行函数的时候，利用栈（Stack）进行存储，当执行完该函数后，函数中的所有数据都会被自动删除。所以在函数外边是无法访问到函数内部的局部变量的。\n与局部变量相对的是全局变量，程序中old_price、new_price、rate都是在函数外边定义的，它们都是全局变量，全局变量拥有更大的作用域，例如在函数中可以访问到它们：\n程序执行结果如下：\n真的可以实现，看上去似乎全局变量更为霸道！不过使用全局变量的时候要千万小心，在任何一种编程语言中都是如此。在Python中，你可以在函数中肆无忌惮地访问一个全局变量，但如果你试图去修改它，就会有奇怪的事情会发生了。分析下面的代码：\n程序执行结果如下：\n这里我就不吊大家的胃口了，如果在函数内部试图修改全局变量，那么Python会创建一个新的局部变量替代（名字跟全局变量相同），但真正的全局变量是纹丝不动的，所以实现的结果和大家的预期不同。\n关于全局变量，我们也来总结一下：全局变量在整个代码段中都是可以访问到的，但是不要试图在函数内部去修改全局变量的值，因为那样Python会自动在函数内部新建一个名字一样的局部变量代替。\n对于初学者来说，局部变量和全局变量在使用上很容易犯错，尤其是很多朋友都试图去建立一个跟全局变量同名的局部变量，这类做法小甲鱼是强烈反对的。那我如果想在函数里边去修改全局变量的值，有办法实现吗？如果我在函数里边想嵌套定义一个新的函数，可以吗？这些问题的答案都是肯定的，不过我们将在下一节再跟大家详细讲解。\n6.4　内嵌函数和闭包\n6.4.1　global关键字\n全局变量的作用域是整个模块（整个代码段），也就是代码段内所有的函数内部都可以访问到全局变量。但要注意的一点是，在函数内部仅仅去访问全局变量就好，不要试图去修改它。\n因为那样的话，Python会使用屏蔽（Shadowing）的方式“保护”全局变量：一旦函数内部试图修改全局变量，Python就会在函数内部自动创建一个名字一模一样的局部变量，这样修改的结果只会修改到局部变量，而不会影响到全局变量。看下面的例子：\n但是毕竟人是要灵活应变的，假设你已经完全了解在函数中修改全局变量可能会导致程序可读性变差、出现莫名其妙的BUG、代码的维护成本提高，但你还是坚持“虚心接受，死性不改”这八字原则，仍然觉得有必要在函数中去修改这个全局变量，那么你不妨可以使用global关键字来达到目的！修改程序如下：\n6.4.2　内嵌函数\nPython的函数定义是可以嵌套的，也就是允许在函数内部创建另一个函数，这种函数叫作内嵌函数或者内部函数。接着看另一个例子：\n这是函数嵌套的最简单的例子，虽然看起来没什么用……不过它麻雀虽小，五脏俱全。关于内部函数的使用，有一个比较值得注意的地方，就是内部函数整个作用域都在外部函数之内。就像刚才例子中的fun2()整个函数的作用域都在fun1()里边。\n需要注意的地方是，除了在fun1()这个函数体中可以随意调用fun2()这个内部函数外，出了fun1()，就没有任何可以对fun2()进行的调用。如果在fun1()外部试图调用内部函数fun2()，就会报错：\n6.4.3　闭包（closure）\n闭包（closure）是函数式编程的一个重要的语法结构，函数式编程是一种编程范式，著名的函数式编程语言就是LISP语言（大家可能听说过这门语言，主要应用于绘图和人工智能，一直被认为是天才程序员使用的语言）。\n那么不同的编程语言实现闭包的方式不同，Python中的闭包从表现形式上定义为：如果在一个内部函数里，对在外部作用域（但不是在全局作用域）的变量进行引用，那么内部函数就被认为是闭包（closure）。还是来举个例子说明比较好理解：\n也可以直接这么写：\n通过上面的例子理解闭包的概念：如果在一个内部函数里（funY就是这个内部函数）对外部作用域（但不是在全局作用域）的变量进行引用（x就是被引用的变量，x在外部作用域funX函数里面，但不在全局作用域里），则这个内部函数（funY）就是一个闭包。\n使用闭包需要注意的是：因为闭包的概念就是由内部函数而来的，所以你也不能在外部函数以外的地方对内部函数进行调用，下面的做法是错误的：\n在闭包中，外部函数的局部变量对应内部函数的局部变量，事实上相当于之前讲的全局变量跟局部变量的对应关系，在内部函数中，你只能对外部函数的局部变量进行访问，但不能进行修改。\n这个报错信息跟之前讲解全局变量的时候基本一样，Python认为在内部函数的x是局部变量的时候，外部函数的x就被屏蔽了起来，所以执行x * = x的时候，在右边根本就找不到局部变量x的值，因此报错。\n在Python3以前并没有直接的解决方案，只能间接地通过容器类型来存放，因为容器类型不是放在栈里，所以不会被“屏蔽”掉。容器类型这个词儿大家是不是似曾相识？之前介绍的字符串、列表、元组，这些啥都可以往里的放的就是容器类型。于是可以把代码改造如下：\n到了Python3的世界里，有了不少的改进。如果希望在内部函数里可以修改外部函数里的局部变量的值，那么也有一个关键字可以使用，就是nonlocal，使用方式跟global一样：\n扩展阅读->游戏中的移动角色：闭包（closure）在实际开发中的作用（地址是http://bbs.fishc.com/thread-42656-1-1.html）。\n6.5　lambda表达式\nPython允许使用lambda关键字来创建匿名函数。我们提到一个新的关键字——匿名函数。那什么是匿名函数呢？匿名函数跟普通函数在使用上又有什么不同呢？使用匿名函数又有怎样的优势呢？\n那先来谈谈lambda表达式怎么用，然后再来讨论它的意义吧。先来定义一个普通的函数：\n如果使用lambda语句来定义这个函数，就会变成这样：\nPython的lambda表达式语法非常精简（符合Python的风格），基本语法是在冒号（：）左边放原函数的参数，可以有多个参数，用逗号（，）隔开即可；冒号右边是返回值。在上面的例子中我们发现lambda语句实际上是返回一个函数对象，如果要对它进行使用，只需要进行简单的赋值操作即可：\n下面演示lambda表达式带两个参数的例子：\nlambda表达式的作用：\n（1）Python写一些执行脚本时，使用lambda就可以省下定义函数过程，比如说只是需要写个简单的脚本来管理服务器时，就不需要专门定义一个函数然后再写调用，使用lambda就可以使得代码更加精简。\n（2）对于一些比较抽象并且整个程序执行下来只需要调用一两次的函数，有时候给函数起个名字也是比较头疼的问题，使用lambda就不需要考虑命名的问题了。\n（3）简化代码的可读性，由于阅读普通函数经常要跳到开头def定义的位置，使用lambda函数可以省去这样的步骤。\n介绍两个BIF：filter()和map()\n接下来给大家介绍Python在实际应用中比较实用的两个BIF，这两个BIF使用比起之前一步到位的内建函数来说，相对要复杂一点，也尝试着把今天学到的lambda表达式结合在一起。\n1．filter()\n我们研究的第一个内建函数是一个过滤器。我们每天会接触到大量的数据，过滤器的作用就显得非常重要了，通过过滤器，就可以保留你所关注的信息，把其他不感兴趣的东西直接丢掉。这么讲大家应该就了解了，那Python的这个filter()如何来实现过滤的功能呢？先来看下Python自己的注释：\n大概意思是：filter有两个参数。第一个参数可以是一个函数也可以是None，如果是一个函数的话，则将第二个可迭代数据里的每一个元素作为函数的参数进行计算，把返回True的值筛选出来；如果第一个参数为None，则直接将第二个参数中为True的值筛选出来。\n这么说有些朋友可能还不大理解，小甲鱼还是用简单的例子帮助解释一下吧：\n利用filter()，尝试写一个筛选奇数的过滤器：\n那现在学习lambda表达式后，完全可以把上述过程转化成一行：\n2．map()\nmap在这里不是地图的意思，在编程领域，map一般作“映射”来解释。map()这个内置函数也有两个参数，仍然是一个函数和一个可迭代序列，将序列的每一个元素作为函数的参数进行运算加工，直到可迭代序列每个元素都加工完毕，返回所有加工后的元素构成的新序列。\n有了刚才filter()的经验，这里举个例子让大家知道map()的用法：\n6.6　递归\n6.6.1　递归是“神马”\n本节的主题叫递归是“神马”，小甲鱼将通过带感的讲解，来告诉大家“神马”是递归。如果说优秀的程序员是伯乐，那么把递归比喻成神马是再形象不过的了！\n递归到底是什么东西呢？有那么厉害吗？为什么大家常说“普通程序员用迭代，天才程序员用递归”呢？没错，通过本节的学习，你将了解递归，通过独立完成课后布置的练习，你将彻底摆脱递归给你生活带来的困扰！\n递归这个概念，是算法的范畴，本来不属于Python语言的语法内容，但小甲鱼基本在每个编程语言系列教学里都要讲递归，那是因为如果你掌握了递归的方法和技巧，你会发现这是一个非常棒的编程思路！\n那么递归算法在日常编程中有哪些例子呢？\n汉诺塔游戏如图6-1所示。\n图6-1　汉诺塔游戏\n树结构的定义如图6-2所示。\n图6-2　树结构的定义\n谢尔宾斯基三角形如图6-3所示。\n图6-3　谢尔宾斯基三角形\n女神自拍如图6-4所示。\n图6-4　女神自拍\n说了这么多，在编程上，递归是什么这个概念还没讲呢！递归，从原理上来说就是函数调用自身这么一个行为。你没听错，在函数内部你可以调用所有可见的函数，当然也包括自己。举个例子：\n这个例子尝试了初学者玩递归最容易出现的错误。从理论上来讲，这个程序将永远执行下去直至耗尽所有内存资源。不过Python3出于“善意的保护”，对递归的深度默认限制是100层，所以你的代码才会停下来。不过如果你写网络爬虫等工具，可能会爬很深，那你也可以自己设置递归的深度限制。方法如下：\n刚才一来就错误地使用递归把Python干掉了，可见递归的厉害和危险，这个后边讲，接下来举个正常的例子跟大家完整解释一下递归。噢，对了，如果你真的设置了一百万层递归，那么一不小心又玩脱了，Python可能会卡在那里很久，这时你可以通过Ctrl+C让它停止哦。\n6.6.2　写一个求阶乘的函数\n正整数的阶乘是指从1乘以2乘以3乘以4一直乘到所要求的数。例如所要求的数是5，则阶乘式是1×2×3×4×5，得到的积是120，所以120就是5的阶乘。好，那大家先自己尝试下实现一个非递归版本：\n程序实现结果如下：\n普通函数的实现相信大家都会写，那再来演示一下递归版本：\n以前没接触过递归的小伙伴肯定会怀疑这是否能正常执行？没错，这完全符合递归的预期和标准，所以函数无疑可以正确执行并返回正确的结果！程序实现结果跟上边的结果是一样的：\n我们说过，麻雀虽小，却五脏俱全。这个例子满足了递归的两个条件：\n（1）调用函数本身。\n（2）设置了正确的返回条件。\n上面程序的详细分析如图6-5所示。\n图6-5　递归函数的实现分析\n最后要郑重说一下“普通程序员用迭代，天才程序员用递归”这句话是不无道理的。但是你不要理解错了，不是说会使用递归，把所有能迭代的东西用递归来代替就是“天才程序员”了，恰好相反，如果你真的这么做的话，那你就是“乌龟程序员”啦。为什么这么说呢？不要忘了，递归的实现可以是函数自个儿调用自个儿，每次函数的调用都需要进行压栈、弹栈、保存和恢复寄存器的栈操作，所以在这上边是非常消耗时间和空间的。\n另外，如果递归一旦忘记了返回，或者错误地设置了返回条件，那么执行这样的递归代码就会变成一个无底洞：只进不出！所以在写递归代码的时候，千万要记住口诀：递归递归，归去来兮！\n因此，结合以上两点致命缺陷，很多初学者经常就会在论坛上讨论递归存在的必要性，他们认为递归完全没必要，用循环就可以实现。其实这就跟讨论C语言好还是Python优秀一样，是没有必要的。因为一样东西既然能够持续存在，那必然有它存在的道理。递归用在妙处，自然代码简洁、精练，所以说“天才程序员使用递归”。\n6.6.3　这帮小兔崽子\n按理来说，今天的话题跟兔子不拉边，不过嘛，大家也知道小甲鱼的风格了，天南地北，总有相关联的东西可以拉过来扯淡。本节就用递归来实现斐波那契（Fibonacci）数列吧。\n斐波那契数列的发明者，是意大利数学家列昂纳多·斐波那契（Leonardo Fibonacci）。这老头说来跟小甲鱼也有一定的渊源，就是老爱拿动物交配说事儿，不同的是小甲鱼注重过程和细节，而这老头更关心结果，下边就有一个他讲过的故事：如果说兔子在出生两个月后，就有繁殖能力，在拥有繁殖能力之后，这对兔子每个月能生出一对小兔子来。假设所有兔子都不会死去，能够一直干下去，那么一年之后可以繁殖多少对兔子呢？\n我们都知道兔子繁殖能力是惊人的，如图6-6所示。\n图6-6　斐波那契数列\n数据统计如表6-1所示。\n表6-1　斐波那契数列\n可以用数学函数来定义，如图6-7所示。\n图6-7　求斐波那契数列的公式\n假设需要求出经历了20个月后，总共有多少对小兔崽子，不妨一起考虑一下分别用迭代和递归如何实现？\n迭代实现：\n接下来看看递归的实现原理，如图6-8所示。\n图6-8　递归实现斐波那契数列的原理\n递归实现：\n可见逻辑非常简单，直接把想的东西写成代码就是递归算法了。不过，之前我们总说递归如果使用不当，效率会很低，但是有多低呢？我们这就来证明一下。我们试图把20个月修改为35个月，然后试试看把程序执行起来……\nN\nN\n为了体现递归正确使用的优势，下一节我们来谈谈利用递归解决汉诺塔难题。如果你不懂得递归，试图想要写个程序来解决问题是相当困难的，但如果使用了递归，你会发现问题奇迹般的变简单了！\n这里可以在线玩这个游戏，大家不妨边玩边思考代码该怎么实现：http://www.kaixin001.com/flashgame/game/10406.html。\n6.6.4　汉诺塔\n看过小甲鱼其他教程的“鱼油”们可能会说，怎么一谈到递归算法就要拿汉诺塔来举例呢？没办法，因为小甲鱼小时候太笨了，这个游戏老是玩不过关，好不容易在自学编程的时候，也卡在这里好长一段时间，所以呢，现在懂了啊，可以得瑟了嘛！\n汉诺塔（如图6-9所示）的来源据说是这样的：一位法国数学家曾编写过一个印度的古老传说：说的是，在世界中心贝拿勒斯的圣庙里边，有一块黄铜板，上边插着三根宝针。印度教的主神梵天在创造世界的时候，在其中一根针上从下到上地穿好了由大到小的64片金片，这就是所谓的汉诺塔。然后不论白天或者黑夜，总有一个僧侣在按照下面的法则来移动这些金片：“一次只移动一片，不管在哪根针上，小片必须在大片上面。”规则很简单，另外僧侣们预言，当所有的金片都从梵天穿好的那根针上移到另外一根针上时，世界就将在一声霹雳中消灭，而梵塔、庙宇和众生也都将同归于尽。\n图6-9　汉诺塔\n要解决一个问题，大家说什么最重要？没错，思路！思路有了，问题就可以随之迎刃而解。游戏上节课我们也玩了，小甲鱼可不是让大家白玩的，玩过之后大家心里有底，现在的分析大家才容易听进去。\n对于游戏的玩法，可以简单分解为三个步骤：\n（1）将前63个盘子从X移动到Y上，确保大盘在小盘下。\n（2）将最底下的第64个盘子从X移动到Z上。\n（3）将Y上的63个盘子移动到Z上。\n这样看上去问题就简单一点了，有些鱼油说小甲鱼你这不废话嘛！？有说跟没说一样！因为关键在于步骤（1）和步骤（3）应该如何执行才是让人头疼的问题。\n但是你仔细思考下，在游戏中，我们发现由于每次只能移动一个圆盘，所以在移动的过程中显然要借助另外一根针才可以实施。也就是说，步骤（1）将1～63个盘子需要借助Z移到Y上，步骤（3）将Y针上的63个盘子需要借助X移到Z针上。\n所以把新的思路聚集为以下两个问题：\n问题一，将X上的63个盘子借助Z移到Y上；\n问题二，将Y上的63个盘子借助X移到Z上。\n然后我们惊奇地发现，解决这两个问题的方法跟刚才第一个问题的思路是一样的，都可以拆解成三个步骤来实现。\n问题一（将X上的63个盘子借助Z移到Y上）拆解为：\n（1）将前62个盘子从X移动到Z上，确保大盘在小盘下。\n（2）将最底下的第63个盘子移动到Y上。\n（3）将Z上的62个盘子移动到Y上。\n问题二（将Y上的63个盘子借助X移到Z上）拆解为：\n（1）将前62个盘子从Y移动到X上，确保大盘在小盘下。\n（2）将最底下的第63个盘子移动到Z上。\n（3）将X上的62个盘子移动到Y上。\n说到这里，是不是发现了什么？没错，汉诺塔的拆解过程刚好满足递归算法的定义，因此，对于如此难题，使用递归来解决，问题就变得相当的简单。参考代码：\n看，这就是递归的魔力！\n第7章　字典和集合\n7.1　字典：当索引不好用时\n图7-1　映射\n在Python中也有字典，就拿刚才的例子来说，Python的字典把这个字（或单词）称为“键（key）”，把其对应的含义称为“值（value）”。另外值得提一下的是，Python的字典在有些地方称为哈希（hash），有些地方称为关系数组，其实这些都跟今天要讲的Python字典是同一个概念。\n字典是Python中唯一的映射类型，映射是数学上的一个术语，指两个元素集之间元素相互“对应”的关系，如图7-1所示。\n映射类型区别于序列类型，序列类型以数组的形式存储，通过索引的方式来获取相应位置的值，一般索引值与对应位置存储的数据是毫无关系的。举个例子：\n列表brand、slogan的索引和相对的值是没有任何关系的，可以看出，唯一有联系的就是两个列表间，索引号相同的元素是有关系的（品牌对应口号嘛），所以这里通过“brand.index（'鱼C工作室'）”这样的语句，间接地实现通过品牌查找对应的口号的功能。\n这确实是一种可实现方法，但用起来多少有些别扭，而且效率还不高。况且Python是以简洁为主，这样的实现肯定是差强人意的。所以，需要有字典这种映射类型的出现。\n7.1.1　创建和访问字典\n先演示一下用法：\n字典的使用非常简单，它有自己的标志性符号，就是用大括号（{}）定义。字典由多个键及其对应的值共同构成，每一对键值组合称为项。在刚才的例子中，“李宁”、“耐克”、“阿迪达斯”、“鱼C工作室”这些品牌就是键，而“一切皆有可能”、“Just do it”、“Impossible is nothing”、“让编程改变世界”这些口号就是对应的值。眼尖的读者可能已经发现了：字典中的项跟创建的顺序是不一样的？没错，字典跟序列不同，序列讲究顺序，字典讲究映射，不讲顺序。\n另外需要注意的是：字典的键必须独一无二，而值可以取任何数据类型，但必须是不可变的（如字符串、数或元组）。\n要声明一个空字典，直接用个大括号即可：\n有读者朋友可能会问，为什么上面的例子中这么多括号？\n因为dict()函数的参数可以是一个序列（但不能是多个），所以要打包成一个元组序列（列表也可以）。当然，如果嫌上面的做法太麻烦，还可以通过提供具有映射关系的参数来创建字典：\n这里要注意的是键的位置不能加上字符串的引号，否则会报错：\n还有一种创建方法是直接给字典的键赋值，如果键存在，则改写键对应的值；如果不存在，则创建一个新的键并赋值：\n正所谓殊途同归，下面列举的五种方法都是创建同样的字典，请大家仔细体会下：\n7.1.2　各种内置方法\n字典是Python中唯一的映射类型，字典不是序列。如果在序列中试图为一个不存在的位置赋值的时候，会报错；但是如果是在字典中，会自动创建相应的键并添加对应的值进去。\n1．fromkeys()\nfromkeys()方法用于创建并返回一个新的字典，它有两个参数：第一个参数是字典的键；第二个参数是可选的，是传入键对应的值。如果不提供，那么默认是None。举个例子：\n上面最后一个例子告诉我们做事不能总是想当然，有时候现实会给你狠狠的一棒。fromkeys()方法并不会将值＂one＂、＂two＂和＂three＂分别赋值键1、2和3，因为fromkeys()把（＂one＂，＂two＂，＂three＂）当成一个值了。\n2．keys()、values()和items()\n访问字典的方法有keys()、values()和items()。\nkeys()用于返回字典中的键，values()用于返回字典中所有的值，那么items()当然就是返回字典中所有的键值对（也就是项）啦。举个例子：\n字典可以很大，有些时候我们并不知道提供的项是否在字典中存在，如果不存在，Python就会报错：\n对于代码调试阶段，报错让程序员及时发现程序存在的问题并修改之。但是如果程序面向用户了，那么经常报错的程序肯定会被用户所遗弃……\n3．get()\nget()方法提供了更宽松的方式去访问字典项，当键不存在的时候，get()方法并不会报错，只是默默地返回了一个None，表示啥都没找到：\n如果希望找不到数据时返回指定的值，那么可以在第二个参数设置对应的默认返回值：\n如果不知道一个键是否在字典中，那么可以使用成员资格操作符（in或not in）来判断：\n在字典中检查键的成员资格比序列更高效，当数据规模相当大的时候，两者的差距会很明显（注：因为字典是采用哈希的方法一对一找到成员，而序列则是采取迭代的方式逐个比对）。最后要注意的一点是，这里查找的是键而不是值，但是在序列中查找的是元素的值而不是元素的索引。\n如果需要清空一个字典，则使用clear()方法：\n有的读者可能会使用变量名赋值为一个空字典的方法来清空字典，这样做存在一定的弊端。举个例子跟大家说说两种清除方法有什么不同：\n从上面的例子中可以看到，a、b指向同一个字典，然后试图通过将a重新指向一个空字典来达到清空的效果时，我们发现原来的字典并没有被真正清空，只是a指向了一个新的空字典而已。所以这种做法在一定条件下会留下安全隐患（例如，账户的数据和密码等资料有可能会被窃取）。\n推荐的做法是使用clear()方法：\n4．copy()\ncopy()方法是复制字典：\n5．pop()和popitem()\n接下来讲讲pop()和popitem()，pop()是给定键弹出对应的值，而popitem()是弹出一个项，这两个比较容易：\nsetdefault()方法和get()方法有点相似，但是setdefault()在字典中找不到相应的键时会自动添加：\n6．update()\n最后一个是update()方法，可以利用它来更新字典：\n还记得在6.2节的末尾我们埋下了一个伏笔，在末尾讲到收集参数的时候，我们说Python还有另一种收集方式，就是用两个星号（**）表示。两个星号的收集参数表示为将参数们打包成字典的形式，现在讲到了字典，就顺理成章地给大家讲讲吧。\n收集参数其实有两种打包形式：一种是以元组的形式打包，另一种则是以字典的形式打包：\n当参数带两个星号（**）时，传递给函数的任意个key=value实参会被打包进一个字典中。那么有打包就有解包，来看一个例子：\n7.2　集合：在我的世界里，你就是唯一\n上节讲了Python中的字典，Python的字典是对数学中映射概念支持的直接体现。而今天呢，我们请来了字典的表亲：集合。\n喔？难道它们长得很像？来，大家看下代码：\n你们确实没有眼花，在Python3里，如果用大括号括起一堆数字但没有体现映射关系，那么Python就会认为这堆玩意儿就是个集合。\n那集合有什么特色呢？不知道大家有没有注意到本节的标题——“集合：在我的世界里，你就是唯一”？\n好，说回主题，集合在Python中几乎起到的所有作用就是两个字：唯一。举个例子：\n大家看到，我们根本不需要做什么，集合就会帮我们把重复的数据清理掉，这样是不是很方便呢？但要注意的是，集合是无序的，也就是你不能试图去索引集合中的某一个元素：\n7.2.1　创建集合\n创建集合有两种方法：一种是直接把一堆元素用大括号（{}）括起来；另一种是用set()。\n现在要求去除列表［1，2，3，4，5，5，3，1，0］中重复的元素。如果还没有学习过集合，你可能会这么写：\n当你学习了集合之后，就可以这么干：\n看，知识才是第一生产力！不过大家发现没有？由于set()创造了的集合内部是无序的，所以再调用list()将无序的集合转换成列表就不能保证原来的列表的顺序了（这里Python好心办坏事儿，把0放到前边了），所以如果关注列表中元素的前后顺序问题，使用set()这个函数时就要提高警惕啦！\n7.2.2　访问集合\n由于集合中的元素是无序的，所以并不能像序列那样用下标来进行访问，但是可以使用迭代把集合中的数据一个个读取出来：\n当然也可以使用in和not in判断一个元素是否在集合中已经存在：\n使用add()方法可以为集合添加元素，使用remove()方法可以删除集合中已知的元素：\n7.2.3　不可变集合\n有些时候希望集合中的数据具有稳定性，也就是说，像元组一样不能随意地增加或删除集合中的元素。那么我们可以定义不可变集合，这里使用的是frozenset()函数，没错，就是把元素给frozen（冰冻）起来：\n第8章　永久存储\n8.1　文件：因为懂你，所以永恒\n大多数的程序都遵循着：输入->处理->输出的模型，首先接收输入数据，然后按照要求进行处理，最后输出数据。到目前为止，我们已经很好地了解了如何处理数据，然后打印出需要的结果。不过你可能已经胃口大开，不再只满足于使用input接收用户输入，使用print输出处理结果了。你迫切想要的是关注到系统的方方面面，你需要自己的代码可以自动分析系统的日志，你需要分析的结果可以保存为一个新的日志，甚至你需要跟外面的世界进行交流。\n相信大家都曾经有这样的经历：当你在编写代码写起劲儿的时候，系统突然蓝屏崩溃了，重启之后发现刚才写入的代码都不见了，这时候你就会吐槽这破系统怎么这么不稳定等等。\n在你编写代码的时候，操作系统为了更快地做出响应，把所有当前的数据都放在内存中，因为内存和CPU数据传输的速度要比在硬盘和CPU之间传输的速度快很多倍。但内存有一个天生的不足，就是一旦断电就没戏，所以小甲鱼在这里再一次呼吁广大未来即将成为伟大程序员的读者们：请养成一个优雅的习惯，随时使用快捷键Ctrl+S保存你的数据。\n由于Windows是以扩展名来指出文件是什么类型，所以相信很多习惯使用Windows的朋友很快就反应过来了，.exe是可执行文件格式，.txt是文本文件，.ppt是PowerPoint的专用格式……所有这些都称为文件。\n8.1.1　打开文件\n在Python中，使用open()这个函数来打开文件并返回文件对象：\nopen(file, mode = 'r', buffering = -1, encoding = None, errors = None, newline = None, closefd = True, opener = None)\nopen()这个函数有很多参数，但作为初学者的我们，只需要先关注第一个和第二个参数即可。第一个参数是传入的文件名，如果只有文件名，不带路径的话，那么Python会在当前文件夹中去找到该文件并打开。有的读者可能会问：如果我要打开的文件事实上并不存在呢？\n那就要看第二个参数了，第二个参数指定文件打开模式，如表8-1所示。\n表8-1　文件的打开模式\n使用open()成功打开一个文件之后，它会返回一个文件对象，拿到这个文件对象，就可以读取或修改这个文件：\n没有消息就是好消息，说明我们的文件成功被打开了。\n8.1.2　文件对象的方法\n打开文件并取得文件对象之后，就可以利用文件对象的一些方法对文件进行读取或修改等操作。表8-2列举了平时常用的一些文件对象方法。\n表8-2　文件对象方法\n8.1.3　文件的关闭\nclose()方法用于关闭文件。如果是讲C语言编程教学，小甲鱼一定会一万次地强调文件的关闭非常重要。而Python拥有垃圾收集机制，会在文件对象的引用计数降至零的时候自动关闭文件，所以在Python编程里，如果忘记关闭文件并不会造成内存泄露那么危险的结果。\n但并不是说就可以不要关闭文件，如果你对文件进行了写入操作，那么应该在完成写入之后关闭文件。因为Python可能会缓存你写入的数据，如果中途发生类似断电之类的事故，那些缓存的数据根本就不会写入到文件中。所以，为了安全起见，要养成使用完文件后立刻关闭的好习惯。\n8.1.4　文件的读取和定位\n文件的读取方法很多，可以使用文件对象的read()和readline()方法，也可以直接list(f)或者直接使用迭代来读取。read()是按字节为单位读取，如果不设置参数，那么会全部读取出来，文件指针指向文件末尾。tell()方法可以告诉你当前文件指针的位置：\n刚才提到的文件指针是啥？你可以认为它是一个“书签”，起到定位的作用。使用seek()方法可以调整文件指针的位置。seek(offset, from)方法有两个参数，表示从from（0代表文件起始位置，1代表当前位置，2代表文件末尾）偏移offset字节。因此将文件指针设置到文件起始位置，使用seek(0, 0)即可：\n（注：因为1个中文字符占用2个字节的空间，所以4个中文加1个英文冒号刚好到位置9。）\nreadline()方法用于在文件中读取一整行，就是从文件指针的位置向后读取，直到遇到换行符（\\n）结束：\n此前介绍过列表的强大，说什么都可以往里放，这不，也可以把整个文件的内容放到列表中：\n对于迭代读取文本文件中的每一行，有些读者可能会这么写：\n这样写并没有错，但给人的感觉就像是你拿酒精灯去烧开水，水是烧得开，不过效率不是很高。因为文件对象自身是支持迭代的，所以没必要绕圈子，直接使用for语句把内容迭代读取出来即可：\n8.1.5　文件的写入\n如果需要写入文件，请确保之前的打开模式有'w'或'a'，否则会出错：\n然而一定要小心的是：使用'w'模式写入文件，此前的文件内容会被全部删除！如图8-1所示，小甲鱼和小客服的对话备份已经不在了。\n图8-1　'w'打开模式会删除原来的文件内容\n如果要在原来的内容上追加，一定要使用'a'模式打开文件哦。这是血淋淋的教训，不要问我为什么（想想都是泪啊）！\n8.1.6　一个任务\n本节要求读者朋友独立来完成一个任务——将文件（record2.txt）中的数据进行分割并按照以下规则保存起来：\n（1）将小甲鱼的对话单独保存为boy_*.txt的文件（去掉“小甲鱼：”）。\n（2）将小客服的对话单独保存为girl_*.txt的文件（去掉“小客服：”）。\n（3）文件中总共有三段对话，分别保存为boy_1.txt、girl_1.txt、boy_2.txt、girl_2.txt、boy_3.txt、girl_3.txt共6个文件（提示：文件中不同的对话间已经使用“＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝”分割）。\n大家一定要自己先动动手再参考答案哦：\n事实上可以利用函数封装得更好看一些：\n8.2　文件系统：介绍一个高大上的东西\n接下来会介绍跟Python的文件相关的一些十分有用的模块。模块是什么？其实我们写的每一个源代码文件（*.py）都是一个模块。Python自身带有非常多实用的模块，在日常编程中，如果能够熟练地掌握它们，将事半功倍。\n比如刚开始介绍的文字小游戏，里边就用random模块的randint()函数来生成随机数。然而要使用这个randint()函数，直接就调用可不行：\n正确的做法应该是先使用import语句导入模块，然后再使用：\n首先要介绍的是高大上的OS模块，OS就是Operating System的缩写，意思是操作系统，而平时经常说iOS就是iPhone OS的意思，即苹果手机的操作系统。但这里小甲鱼说OS模块高大上，并不是因为跟苹果或土豪金拉边才这么说。之所以说OS模块高大上，是因为对于文件系统的访问，Python一般是通过OS模块来实现的。我们所知道常用的操作系统就有Windows、Mac OS、Linux、UNIX等，这些操作系统底层对于文件系统的访问工作原理是不一样的，因此你可能就要针对不同的系统来考虑使用哪些文件系统模块……这样的做法是非常不友好且麻烦的，因为这意味着当你的程序运行环境一旦改变，你就要相应地去修改大量的代码来应付。\n但是Python是跨平台的语言，也就是说，同样的源代码在不同的操作系统不需要修改就可以同样实现。有了OS模块，不需要关心什么操作系统下使用什么模块，OS模块会帮你选择正确的模块并调用。\n表8-3列举了OS模块中关于文件／目录常用的函数使用方法。\n表8-3　OS模块中关于文件／目录常用的函数使用方法\n1．getcwd()\n在有些情况下我们需要获得应用程序当前的工作目录（比如要保存临时文件），那么可以使用getcwd()函数获得：\n2．chdir(path)\n用chdir()函数可以改变当前工作目录，比如可以切换到E盘：\n3．listdir(path='.')\n有时候你可能需要知道当前目录下有哪些文件和子目录，那么listdir()函数可以帮你列举出来。path参数用于指定列举的目录，默认值是'.'，代表根目录，也可以使用'..'代表上一层目录：\n4．mkdir(path)\nmkdir()函数用于创建文件夹，如果该文件夹存在，则抛出FileExistsError异常：\n5．makedirs(path)\nmakedirs()函数可以用于创建多层目录：\n效果如图8-2所示。\n图8-2　makedirs()函数\n6．remove(path)、rmdir(path)和removedirs(path)\nremove()函数用于删除指定的文件，注意是删除文件，不是删除目录。如果要删除目录，则用rmdir()函数；如果要删除多层目录，则用removedirs()函数。\n7．rename(old, new)\nrename()函数用于重命名文件或文件夹：\n8．system(command)\n几乎每个操作系统都会提供一些小工具，system()函数用于使用这些小工具：\n回车后即弹出计算器，效果如图8-3所示。\n图8-3　system()函数\n9．walk(top)\n最后是walk()函数，这个函数在有些时候确实非常有用，可以省去你很多麻烦。该函数的作用是遍历top参数指定路径下的所有子目录，并将结果返回一个三元组（路径，［包含目录］，［包含文件］）。来看下面的例子：\n为了便于理解，我画个实际的文件夹分布图给大家对比一下，如图8-4所示。\n图8-4　walk()函数\n另外path模块还提供了一些很实用的定义，分别是：os.curdir表示当前目录；os.pardir表示上一级目录（'..'）；os.sep表示路径的分隔符，比如Windows系统下为'\\\\'，Linux下为'/'；os.linesep表示当前平台使用的行终止符（在Windows下为'\\r\\n'，Linux下为'\\n'）；os.name表示当前使用的操作系统。\n另一个强大的模块是os.path，它可以完成一些针对路径名的操作。表8-4列举了os.path中常用到的函数使用方法。\n表8-4　os.path模块中关于路径常用的函数使用方法\n10．basename(path)和dirname(path)\nbasename()和dirname()函数分别用于获得文件名和路径名：\n11．join(path1[, path2[, ...]])\njoin()函数跟BIF的那个join()函数不同，os.path.join()是用于将路径名和文件名组合成一个完整的路径：\n12．split(path)和splitext(path)\nsplit()和splitext()函数都用于分割路径，split()函数分割路径和文件名（如果完全使用目录，它也会将最后一个目录作为文件名分离，且不会判断文件或者目录是否存在）；splitext()函数则是用于分割文件名和扩展名：\n13．getsize(file)\ngetsize()函数用于获取文件的尺寸，返回值是以字节为单位：\n14．getatime(file)、getctime(file)和getmtime(file)\ngetatime()、getctime()和getmtime()分别用于获得文件的最近访问时间、创建时间和修改时间。不过返回值是浮点型秒数，可用time模块的gmtime()或localtime()函数换算：\n还有一些函数返回布尔类型的值，具体的解释见表8-4，这里就不一一举例了。\n8.3　pickle：腌制一缸美味的泡菜\n从一个文件里读取字符串非常简单，但如果想要读取出数值，那就需要多费点儿周折。因为无论是read()方法，还是readline()方法，都是返回一个字符串，如果希望从字符串里边提取出数值的话，可以使用int()函数或float()函数把类似'123'或'3.14'这类字符串强制转换为具体的数值。\n此前一直在讲保存文本，然而当要保存的数据像列表、字典甚至是类的实例这些更复杂的数据类型时，普通的文件操作就会变得不知所措。也许你会把这些都转换为字符串，再写入到一个文本文件中保存起来，但是很快你就会发现要把这个过程反过来，从文本文件恢复数据对象，就变得异常麻烦了。\n所幸的是，Python提供了一个标准模块，使用这个模块，就可以非常容易地将列表、字典这类复杂数据类型存储为文件了。这个模块就是本节要介绍的pickle模块。\npickle就是泡菜，腌菜的意思，相信很多女读者都对韩国泡菜尤其情有独钟。至于Python的作者为何把这么一个高大上模块命名为泡菜，我想应该是跟韩剧脱不了干系。\n好，说回这个泡菜。用官方文档中的话说，这是一个令人惊叹（amazing）的模块，它几乎可以把所有Python的对象都转化为二进制的形式存放，这个过程称为pickling，那么从二进制形式转换回对象的过程称为unpickling。\n说了这么多，还是来点干货吧：\n分析一下：这里希望把这个列表永久保存起来（保存成文件），打开的文件一定要以二进制的形式打开，后缀名倒是可以随意，不过既然是使用pickle保存，为了今后容易记忆，建议还是使用.pkl或.pickle。使用dump方法来保存数据，完成后记得保存，跟操作普通文本文件一样。\n程序执行之后E盘会出现一个my_list.pkl的文件，用记事本打开之后显示乱码（因为它保存的是二进制形式），如图8-5所示。\n那么在使用的时候只需用二进制模式先把文件打开，然后用load把数据加载进来：\n图8-5　保存为pickle文件\n程序执行后又取回我们的列表啦：\n利用pickle模块，不仅可以保存列表，事实上pickle可以保存任何你能想象得到的东西。\n第9章　异常处理\n9.1　你不可能总是对的\n因为我们是人，不是神，所以我们经常会犯错。当然程序员也不例外，就算是经验丰富的码农，也不能保证写出来的代码百分之百没有任何问题（要不哪来那么多0Day漏洞）。另外，作为一个合格的程序员，在编程的时候一定要意识到一点，就是永远不要相信你的用户。要把他们想象成熊孩子，把他们想象成黑客，这样你写出来的程序自然会更加安全和稳定。\n那么既然程序总会出问题，我们就应该学会用适当的方法去解决问题。程序出现逻辑错误或者用户输入不合法都会引发异常，但这些异常并不是致命的，不会导致程序崩溃死掉。可以利用Python提供的异常处理机制，在异常出现的时候及时捕获，并从内部自我消化掉。\n那么什么是异常呢？举个例子：\n这里当然假设用户的输入是正确的，但只要用户输入一个不存在的文件名，那么上面的代码就不堪一击：\n上面的例子就抛出了一个FileNotFoundError异常，那Python通常还可能抛出哪些异常呢？这里给大家做个总结，今后遇到这样的异常时就不会感觉到陌生了。\n1．AssertionError：断言语句（assert）失败\n大家还记得断言语句吧？在关于分支和循环的章节里讲过。当assert这个关键字后边的条件为假的时候，程序将停止并抛出AssertionError异常。assert语句一般是在测试程序的时候用于在代码中置入检查点：\n2．AttributeError：尝试访问未知的对象属性\n当试图访问的对象属性不存在时抛出的异常：\n3．IndexError：索引超出序列的范围\n在使用序列的时候就常常会遇到IndexError异常，原因是索引超出序列范围的内容：\n4．KeyError：字典中查找一个不存在的关键字\n当试图在字典中查找一个不存在的关键字时就会引发KeyError异常，因此建议使用dict.get()方法：\n5．NameError：尝试访问一个不存在的变量\n当尝试访问一个不存在的变量时，Python会抛出NameError异常：\n6．OSError：操作系统产生的异常\nOSError顾名思义就是操作系统产生的异常，像打开一个不存在的文件会引发FileNotFoundError，而这个FileNotFoundError就是OSError的子类。例子上面已经演示过，这里就不再重复。\n7．SyntaxError：Python的语法错误\n如果遇到SyntaxError是Python的语法错误，这时Python的代码并不能继续执行，你应该先找到并改正错误：\n8．TypeError：不同类型间的无效操作\n有些类型不同是不能相互进行计算的，否则会抛出TypeError异常：\n9．ZeroDivisionError：除数为零\n地球人都知道除数不能为零，所以除以零就会引发ZeroDivisionError异常：\n好了，知道程序抛出异常就说明这个程序有问题，但问题并不致命，所以可以通过捕获这些异常，并纠正这些错误就行。那应该如何捕获和处理异常呢？\n异常捕获可以使用try语句来实现，任何出现在try语句范围内的异常都会被及时捕获到。try语句有两种实现形式：一种是try-except，另一种是try-finally。\n9.2　try-except语句\ntry-except语句格式如下：\ntry: 检测范围 except Exception[as reason]: 出现异常(Exception)后的处理代码\ntry-except语句用于检测和处理异常，举个例子来说明这一切是如何工作的：\n# p9_2.py f = open('我为什么是一个文档.txt') print(f.read()) f.close()\n以上代码在“我为什么是一个文档.txt”这个文档不存在的时候，Python就会报错说文件不存在：\n显然这样的用户体验不好，因此可以这么修改：\n# p9_3.py try: f = open('我为什么是一个文档.txt)' print(f.read()) f.close() except OSError: print('文件打开的过程中出错啦T_T)'\n上面的例子由于使用了大家习惯的语言来表述错误信息，用户体验当然会好很多：\n但是从程序员的角度来看，导致OSError异常的原因有很多（例如FileExistsError、FileNotFoundError、PermissionError等等），所以可能会更在意错误的具体内容，这里可以使用as把具体的错误信息给打印出来：\nexcept OSError as reason: print('文件出错啦T_T\\n错误原因是:' + str(reason))\n9.2.1　针对不同异常设置多个except\n一个try语句还可以和多个except语句搭配，分别对感兴趣的异常进行检测处理：\n#p9_4.py try: sum = 1 + '1' f = open('我是一个不存在的文档.txt)' print(f.read()) f.close() except OSError as reason: print('文件出错啦T_T\\n错误原因是:' + str(reason)) except TypeError as reason: print('类型出错啦T_T\\n错误原因是:' + str(reason))\n9.2.2　对多个异常统一处理\nexcept后边还可以跟多个异常，然后对这些异常进行统一的处理：\n#p9_5.py try: int('abc') sum + 1 + '1' f = open('我是一个不存在的文档.txt)' print(f.read()) f.close() except (OSError, TypeError): print('出错啦T_T\\n错误原因是:' + str(reason))\n9.2.3　捕获所有异常\n如果你无法确定要对哪一类异常进行处理，只是希望在try语句块里一旦出现任何异常，可以给用户一个“看得懂”的提醒，那么可以这么做：\n… except: print('出错啦~)' …\n不过通常不建议你这么做，因为它会隐藏所有程序员未想到并且未做好处理准备的错误，例如当用户输入Ctrl+C试图终止程序，却被解释为KeyboardInterrupt异常。另外要注意的是，try语句检测范围内一旦出现异常，剩下的语句将不会被执行。\n9.3　try-finally语句\n如果“我是一个不存在的文档”确实存在，open()函数正常返回文件对象，但异常却发生在成功打开文件后的sum=1+'1'语句上。此时Python将直接跳到except语句，也就是说，文件打开了，但并没有执行关闭文件的命令：\n#p9_6.py try: f = open('我是一个不存在的文档.txt)' print(f.read()) sum = 1 + '1' f.close() except: print('出错啦')\n为了实现像这种“就算出现异常，但也不得不执行的收尾工作（比如在程序崩溃前保存用户文档）”，引入了finally来扩展try：\n#p9_7.py try: f = open('我是一个不存在的文档.txt)' print(f.read()) sum = 1 + '1' except: print('出错啦') finally: f.close()\n如果try语句块中没有出现任何运行时错误，会跳过except语句块执行finally语句块的内容。如果出现异常，则会先执行except语句块的内容再执行finally语句块的内容。总之，finally语句块中的内容就是确保无论如何都将被执行的内容。\n9.4　raise语句\n有读者可能会问，我的代码能不能自己抛出一个异常呢？答案是可以的，你可以使用raise语句抛出一个异常：\n抛出的异常还可以带参数，表示异常的解释：\n9.5　丰富的else语句\n有读者可能会说，else语句还有啥好讲的？经常跟if语句进行搭配用于条件判断嘛。没错，对于大多数编程语言来说，else语句都只能跟if语句搭配。但在Python里，else语句的功能更加丰富。\n在Python中，else语句不仅能跟if语句搭，构成“要么怎样，要么不怎样”的句式；它还能跟循环语句（for语句或者while语句），构成“干完了能怎样，干不完就别想怎样”的句式；其实else语句还能够跟刚刚讲的异常处理进行搭配，构成“没有问题？那就干吧”的句式，下边逐个给大家解释。\n1．要么怎样，要么不怎样\n典型的if-else搭配：\nif条件: 条件为真执行 else: 条件为假执行\n2．干完了能怎样，干不完就别想怎样\nelse可以跟for和while循环语句配合使用，但else语句块只在循环完成后执行，也就是说，如果循环中间使用break语句跳出循环，那么else里边的内容就不会被执行了。举个例子：\n这个小程序主要是求用户输入的数的最大约数，如果是素数的话就顺便提醒“这是一个素数”。注意要使用地板除法（count=num//2）哦，否则结果会出错。使用暴力的方法一个个尝试（num%count==0），如果符合条件则打印出最大的约数，并break，同时不会执行else语句块的内容了。但如果一直没有遇到合适的条件，则会执行else语句块内容。\nfor语句的用法跟while一样，这里就不重复举例了。\n3．没有问题？那就干吧\nelse语句还能跟刚刚学的异常处理进行搭配，实现跟与循环语句搭配差不多：只要try语句块里没有出现任何异常，那么就会执行else语句块里的内容啦。举个例子：\n#p9_9.py try: int('abc') except ValueError as reason: print('出错啦:' + str(reason)) else: print('没有任何异常!)'\n9.6　简洁的with语句\n有读者可能觉着打开文件又要关闭文件，还要关注异常处理有点烦人，所以Python提供了一个with语句，利用这个语句抽象出文件操作中频繁使用的try/except/finally相关的细节。对文件操作使用with语句，将大大减少代码量，而且你再也不用担心出现文件打开了忘记关闭的问题了（with会自动帮你关闭文件）。举个例子：\n#p9_10.py try: f = open('data.txt', 'w)' for each_line in f: print(each_line) except OSError as reason: print('出错啦:' + str(reason)) finally: f.close()\n使用with语句，可以改成这样：\n#p9_11.py try: with open('data.txt', 'w')as f: for each_line in f: print(each_line) except OSError as reason: print('出错啦:' + str(reason))\n是不是很方便呢？有了with语句，就再也不用担心忘记关闭文件了。\n第10章　图形用户界面入门\n本章给大家介绍图形用户界面编程，也就是平时常说的GUI（Graphical User Interface，读作[gu：i]）编程，那些带有按钮、文本、输入框的窗口的编程，相信大家都不会陌生。\n目前有很多Python的GUI工具包可供选择，Python有一个非常简单的GUI工具包：EasyGui。EasyGui跟它的名字一样简单，一旦你的模块导入EasyGui，GUI操作就是一个简单地调用EasyGui函数的几个参数的问题了。\nEasyGui官网：http://easygui.sourceforge.net。\n本书配套资源：easygui-0.96.zip。\n使用标准方法安装：\n解压easygui-0.96.zip。\n使用命令窗口切换到easygui-docs-0.96的目录下。\n在Windows下执行C:\\Python34\\python.exe setup.py install。\n在Linux或Mac下执行sudo/usr/bin/python34 setup.py install。\nWindows下的安装界面如图10-1所示。\n图10-1　EasyGui的安装\n希望深入学习Python的读者，可以在本书配套资源中的easygui-0.96.zip压缩包中找到EasyGui各个函数的实现源代码（下载地址http://bbs.fishc.com/thread-46069-1-1.html）。\n附件：easygui-0.96.zip。\n10.1　导入EasyGui\n为了使用EasyGui这个模块，你应该先导入它。最简单的导入语句是import easygui。\n如果使用这种形式导入的话，那么在使用EasyGui的函数的时候，必须在函数的前面加上前缀easygui：\n回车后即弹出消息框，如图10-2所示。\n图10-2　导入EasyGui模块（方法一）\n另一种选择是导入整个EasyGui包：from easygui import *，这样使得我们更容易调用EasyGui的函数，可以直接这样编写代码：\n回车后即弹出消息框，如图10-3所示。\n第三种方案是使用类似下边的import语句（建议使用）：import easygui as g，这样可以让你保持EasyGui的命名空间，同时减少输入字符的数量：\n回车后即弹出消息框，如图10-4所示。\n图10-3　导入EasyGui模块（方法二）\n图10-4　导入EasyGui模块（方法三）\n10.2　使用EasyGui\n举一个简单的例子：\n实现过程如图10-5～图10-8所示。\n图10-5　使用EasyGui编写第一个界面小游戏（一）\n图10-6　使用EasyGui编写第一个界面小游戏（二）\n图10-7　使用EasyGui编写第一个界面小游戏（三）\n图10-8　使用EasyGui编写第一个界面小游戏（四）\n10.3　修改默认设置\n默认情况下显示的对话框非常大，而且字体也相对难看。这里可以手动调整EsayGui的参数修改。\n修改位置为C:\\Python34\\Lib\\site-packages\\easygui.py。\n更改对话框尺寸：找到def__choicebox，下边的root_width=int((screen_width * 0.8))和root_height = int((screen_height * 0.5))分别改为root_width=int((screen_width * 0.4))和root_height=int((screen_height * 0.25))。\n更改字体：找到PROPORTIONAL_FONT_FAMILY=(＂MS＂, ＂Sans＂, ＂Serif＂)改为PROPORTIONAL_FONT_FAMILY=（＂微软雅黑＂）。\nEasyGui提供了非常多的组件供我们实现一个完整的界面程序，刚才给大家演示的就是msgbox、choicebox和ccbox的用法。关于更多的组件使用，大家可以参考小甲鱼翻译改编的《EasyGui学习文档》：http://bbs.fishc.com/thread-46069-1-1.html。\n第11章　类和对象\n11.1　给大家介绍对象\n很多读者此前肯定听说过Python无处不对象，然而他们并不知道对象到底是个什么东西。他们只是在学习的时候听说过有面向对象编程……这就像学开车，你并不用理解汽车为什么会跑，但作为赛车手，这些原理就必须要懂，因为这有助于他把车开得更好。因此，本章就向大家隆重地介绍对象！\n大家之前已经听说过封装的概念，把乱七八糟的数据扔进列表里边，这是一种封装，是数据层面的封装；把常用的代码段打包成一个函数，这也是一种封装，是语句层面的封装；本章学习的对象，也是一种封装的思想，不过这种思想显然要更先进一步：对象的来源是模拟真实世界，把数据和代码都封装在了一起。\n打个比方，乌龟就是真实世界的一个对象，那么通常应该如何来描述这个对象呢？是不是把它分为两部分来说？\n（1）可以从静态的特征来描述，例如，绿色的、有四条腿，10kg重，有外壳，还有个大嘴巴，这是静态一方面的描述。\n（2）还可以从动态的行为来描述，例如说它会爬，你如果追它，它就会跑，然后你把它逼急了，它就会咬人，被它咬到了，据说要打雷才会松开嘴巴……它的嘴巴的重要作用不是用来咬人，是用来吃东西的，然后它还会睡觉。这些都是从行为方面进行描述的。\n那如果把一个人作为对象，你会从哪两方面来描述这个人？\n对嘛，无非就是他长什么样？这是从外观方面找特征，例如，眼歪鼻子斜、胸大屁股翘，这些都是静态的特征。另一方面就是描述他的行为？例如，唱歌、街舞、打篮球等等。\n11.2　对象＝属性＋方法\nPython中的对象也是如此，一个对象的特征称为“属性”，一个对象的行为称为“方法”。\n如果把“乌龟”写成代码，将会是下边这样：\n以上代码定义了对象的特征（属性）和行为（方法），但还不是一个完整的对象，将定义的这些称为类（Class）。需要使用类来创建一个真正的对象，这个对象就叫作这个类的一个实例（Instance），也叫实例对象（Instance Objects）。\n有些读者可能还不大理解，你可以这么想：这就好比工厂的流水线要生产一系列玩具，是不是要先做出这个玩具的模具，然后根据这个模具再进行批量生产，才得到真正的玩具？\n再举个例子：盖房子，是不是先要有个图纸，但光有个图纸你能不能住进去？显然不能，图纸只能告诉你这个房子长什么样，但图纸并不是真正的房子。要根据图纸用钢筋水泥建造出来的房子才能住人，另外根据一张图纸就能盖出很多的房子。\n好，说了这么多，那真正的实例对象怎么创建？\n创建一个对象，也叫类的实例化，其实非常简单：\n注意，类名后边跟着的小括号，这跟调用函数是一样的，所以在Python中，类名约定用大写字母开头，函数用小写字母开头，这样更容易区分。另外赋值操作并不是必需的，但如果没有把创建好的实例对象赋值给一个变量，那这个对象就没办法使用，因为没有任何引用指向这个实例，最终会被Python的垃圾收集机制自动回收。\n那如果要调用对象里的方法，使用点操作符（.）即可，其实我们已经用了何止千百遍：\n11.3　面向对象编程\n经过前边的热身，相信大家对类和对象已经有了初步的认识，但似乎还是懵懵懂懂：好像面向对象编程很厉害，但不知道具体怎么用？下面通过几个主题，尝试给大家进一步剖析Python的类和对象。\n11.3.1　self是什么\n细心的读者会发现对象的方法都会有一个self参数，那这个self到底是个什么东西呢？如果此前接触过其他面向对象的编程语言，例如C++，那么你应该很容易对号入座，Python的self其实就相当于C++的this指针。\n这里为了照顾大部分的初学编程的读者，讲解下self到底是个什么东西。如果把类比作是图纸，那么由类实例化后的对象才是真正可以住的房子。根据一张图纸就可以设计出成千上万的房子，它们长得都差不多，但它们都有不同的主人。每个人都只能回自己的家里，陪伴自己的孩子……所以self这里就相当于每个房子的门牌号，有了self，你就可以轻松找到自己的房子。\nPython的self参数就是同一个道理，由同一个类可以生成无数对象，当一个对象的方法被调用的时候，对象会将自身的引用作为第一个参数传给该方法，那么Python就知道需要操作哪个对象的方法了。\n通过一个例子稍微感受下：\n11.3.2　你听说过Python的魔法方法吗\n据说，Python的对象天生拥有一些神奇的方法，它们是面向对象的Python的一切。它们是可以给你的类增加魔力的特殊方法，如果你的对象实现了这些方法中的某一个，那么这个方法就会在特殊的情况下被Python所调用，而这一切都是自动发生的。\nPython的这些具有魔力的方法，总是被双下划线所包围，今天就讲其中一个最基本的特殊方法：__init__()，关于其他Python的魔法方法，接下来会专门用一个章节来详细讲解。\n通常把__init__()方法称为构造方法，__init__()方法的魔力体现在只要实例化一个对象，这个方法就会在对象被创建时自动调用（在C++里你也可以看到类似的东西，叫“构造函数”）。其实，实例化对象时是可以传入参数的，这些参数会自动传入__init__()方法中，可以通过重写这个方法来自定义对象的初始化操作。举个例子：\n11.3.3　公有和私有\n一般面向对象的编程语言都会区分公有和私有的数据类型，像C++和Java它们使用public和private关键字，用于声明数据是公有的还是私有的，但在Python中并没有用类似的关键字来修饰。\n难道Python所有东西都是透明的？也不全是，默认上对象的属性和方法都是公开的，可以直接通过点操作符（.）进行访问：\n为了实现类似私有变量的特征，Python内部采用了一种叫name mangling（名字改编）的技术，在Python中定义私有变量只需要在变量名或函数名前加上“__”两个下划线，那么这个函数或变量就会成为私有的了：\n这样在外部将变量名“隐藏”起来了，理论上如果要访问，就需要从内部进行：\n但是你认真琢磨一下这个技术的名字name mangling（名字改编），那就不难发现其实Python只是动了一下手脚，把双下横线开头的变量进行了改名而已。实际上在外部你使用“_类名__变量名”即可访问双下横线开头的私有变量了：\n（注：Python目前的私有机制其实是伪私有，Python的类是没有权限控制的，所有变量都是可以被外部调用的。最后的这部分有些读者（尤其是没有接触过面向对象编程的读者）可能看不懂，想不明白有什么用？没事，先放着，下节讲完继承机制你就会豁然开朗了。）\n11.4　继承\n现在需要扩展游戏，对鱼类进行细分，有金鱼（Goldfish）、鲤鱼（Carp）、三文鱼（Salmon），还有鲨鱼（Shark）。那么我们就再思考一个问题：能不能不要每次都从头到尾去重新定义一个新的鱼类呢？因为我们知道大部分鱼的属性和方法是相似的，如果有一种机制可以让这些相似的东西得以自动传递，那就方便快捷多了。没错，你猜到了，这种机制就是今天要讲的：继承。\n语法很简单：\nclass类名(被继承的类): …\n被继承的类称为基类、父类或超类；继承者称为子类，一个子类可以继承它的父类的任何属性和方法。举个例子：\n需要注意的是，如果子类中定义与父类同名的方法或属性，则会自动覆盖父类对应的方法或属性：\n好，那尝试来写一下刚才提到的金鱼（Goldfish）、鲤鱼（Carp）、三文鱼（Salmon），还有鲨鱼（Shark）的例子：\n奇怪！同样是继承于Fish类，为什么金鱼（goldfish）可以移动，而鲨鱼（shark）一移动就报错呢？\n其实这里抛出的异常说得很清楚了：Shark对象没有x属性。原因其实是这样的：在Shark类中，重写了魔法方法__init__，但新的__init__方法里边没有初始化鲨鱼的x坐标和y坐标，因此调用move方法就会出错。那么解决这个问题的方案就很明显了，应该在鲨鱼类中重写__init__方法的时候先调用基类Fish的__init__方法。\n下面介绍两种可以实现的技术：\n调用未绑定的父类方法。\n使用super函数。\n11.4.1　调用未绑定的父类方法\n调用未绑定的父类方法，听起来有些高深，但大家参考下面改写的代码就能心领神会了：\n再运行下发现鲨鱼也可以成功移动了：\n这里需要注意的是这个self并不是父类Fish的实例对象，而是子类Shark的实例对象，所以这里说的未绑定是指并不需要绑定父类的实例对象，使用子类的实例对象代替即可。\n有些读者可能不大理解，没关系，这一点都不重要！因为在Python中，有一个更好的方案可以取代它，就是使用super函数。\n11.4.2　使用super函数\nsuper函数能够帮我自动找到基类的方法，而且还为我们传入了self参数，这样就不需要做这些事情了：\n运行后得到同样的结果：\nsuper函数的“超级”之处在于你不需要明确给出任何基类的名字，它会自动帮您找出所有基类以及对应的方法。由于你不用给出基类的名字，这就意味着如果需要改变类继承关系，只要改变class语句里的父类即可，而不必在大量代码中去修改所有被继承的方法。\n11.5　多重继承\n除此之外Python还支持多继承，就是可以同时继承多个父类的属性和方法：\n上面就是基本的多重继承语法。但多重继承其实很容易导致代码混乱，所以当你不确定是否真的必须使用多重继承的时候，请尽量避免使用它，因为有些时候会出现不可预见的BUG。\n【扩展阅读】多重继承的陷阱：钻石继承（菱形继承）问题（http://bbs.fishc.com/thread-48759-1-1.html）。\n11.6　组合\n前边先是学习了继承的概念，然后又学习了多重继承，但听到大牛们强调说不到必要的时候不使用多重继承。哎呀，这可让大家烦恼死了，就像上回我们有了乌龟类、鱼类，现在要求定义一个类，叫水池，水池里要有乌龟和鱼。用多重继承就显得很奇怪，因为水池和乌龟、鱼是不同物种，那要怎样才能把它们组合成一个水池的类呢？\n在Python里其实很简单，直接把需要的类放进去实例化就可以了，这就叫组合：\nPython的特性其实还支持另外一种很流行的编程模式：Mixin，有兴趣的朋友可以看看【扩展阅读】Mixin编程机制（http://bbs.fishc.com/thread-48888-1-1.html）。\n11.7　类、类对象和实例对象\n先来分析一段代码：\n图11-1　类、类对象和实例对象\n从上面的例子可以看出，对实例对象c的count属性进行赋值后，就相当于覆盖了类对象C的count属性。如图11-1所示，如果没有赋值覆盖，那么引用的是类对象的count属性。\n需要注意的是，类中定义的属性是静态变量，也就是相当于C语言中加上static关键字声明的变量，类的属性是与类对象进行绑定，并不会依赖任何它的实例对象。这点待会儿继续讲解。\n另外，如果属性的名字跟方法名相同，属性会覆盖方法：\n为了避免名字上的冲突，大家应该遵守一些约定俗成的规矩：\n类的定义要“少吃多餐”，不要试图在一个类里边定义出所有能想到的特性和方法，应该利用继承和组合机制来进行扩展。\n[1]\n11.8　到底什么是绑定\nPython严格要求方法需要有实例才能被调用，这种限制其实就是Python所谓的绑定概念。前面也粗略地解释了一下绑定，但有些读者可能会这么尝试，然后发现也可以调用：\n但这样做会有一个问题，就是根据类实例化后的对象根本无法调用里边的函数：\n实际上由于Python的绑定机制，这里自动把bb对象作为第一个参数传入，所以才会出现TypeError。\n为了让大家更好地理解，再深入挖一挖：\n可以使用__dict__查看对象所拥有的属性：\n__dict__属性是由一个字典组成，字典中仅有实例对象的属性，不显示类属性和特殊属性，键表示的是属性名，值表示属性相应的数据值。\n为什么会这样呢？完全是归功于self参数：当实例对象dd去调用setXY方法的时候，它传入的第一个参数就是dd，那么self.x=4，self.y=5也就相当于dd.x=4，dd.y=5，所以你在实例对象，甚至类对象中都看不到x和y，因为这两个属性是只属于实例对象dd的。\n接着再深入一下，请思考：如果我把类实例删除掉，实例对象dd还能否调用printXY方法？\n11.9　一些相关的BIF\n下面介绍与类和对象相关的一些BIF（内置函数）。\n1．issubclass(class, classinfo)\n如果第一个参数（class）是第二个参数（classinfo）的一个子类，则返回True，否则返回False：\n（1）一个类被认为是其自身的子类。\n（2）classinfo可以是类对象组成的元组，只要class是其中任何一个候选类的子类，则返回True。\n（3）在其他情况下，会抛出一个TypeError异常。\n2．isinstance(object, classinfo)\n如果第一个参数（object）是第二个参数（classinfo）的实例对象，则返回True，否则返回False：\n（1）如果object是classinfo的子类的一个实例，也符合条件。\n（2）如果第一个参数不是对象，则永远返回False。\n（3）classinfo可以是类对象组成的元组，只要object是其中任何一个候选对象的实例，则返回True。\n（4）如果第二个参数不是类或者由类对象组成的元组，会抛出一个TypeError异常。\nPython提供以下几个BIF用于访问对象的属性。\n3．hasattr(object, name)\nattr即attribute的缩写，属性的意思。接下来将要介绍的几个BIF都是跟对象的属性有关系的，例如这个hasattr()的作用就是测试一个对象里是否有指定的属性。\n第一个参数（object）是对象，第二个参数（name）是属性名（属性的字符串名字），举个例子：\n4．getattr(object, name[, default])\n返回对象指定的属性值，如果指定的属性不存在，则返回default（可选参数）的值；若没有设置default参数，则抛出ArttributeError异常。\n5．setattr(object, name, value)\n与getattr()对应，setattr()可以设置对象中指定属性的值，如果指定的属性不存在，则会新建属性并赋值。\n6．delattr(object, name)\n与setattr()相反，delattr()用于删除对象中指定的属性，如果属性不存在，则抛出AttributeError异常。\n7．property(fget=None, fset=None, fdel=None, doc=None)\n俗话说：条条大路通罗马。同样是完成一件事，Python其实提供了好几个方式供你选择。property()是一个比较奇葩的BIF，它的作用是通过属性来设置属性。说起来有点绕，看一下例子：\nproperty()返回一个可以设置属性的属性，当然如何设置属性还是需要人为来写代码。第一个参数是获得属性的方法名（例子中是getSize），第二个参数是设置属性的方法名（例子中是setSize），第三个参数是删除属性的方法名（例子中是delSize）。\nproperty()有什么作用呢？举个例子，在上面的例题中，为用户提供setSize方法名来设置size属性，并提供getSize方法名来获取属性。但是有一天你心血来潮，突然想对程序进行大改，就可能需要把setSize和getSize修改为setXSize和getXSize，那就不得不修改用户调用的接口，这样的体验非常不好。\n有了property()，所有问题就迎刃而解了，因为像上边一样，为用户访问size属性只提供了x属性。无论内部怎么改动，只需要相应的修改property()的参数，用户仍然只需要去操作x属性即可，没有任何影响。\n很神奇是吧？想知道它是如何工作的？学完紧接着要讲的魔法方法，你就知道了。\n[1]\n第12章　魔法方法\n12.1　构造和析构\n在此之前，已经接触过Python最常用的魔法方法，小甲鱼也把魔法方法说得神乎其神，似乎用了就可以化腐朽为神奇，化干戈为玉帛，化不可能为可能！\n说的这么厉害，那什么是魔法方法呢？\n魔法方法总是被双下划线包围，例如__init__()。\n魔法方法是面向对象的Python的一切，如果你不知道魔法方法，说明你还没能意识到面向对象的Python的强大。\n魔法方法的“魔力”体现在它们总能够在适当的时候被调用。\n12.1.1　__init__(self[, …])\n之前我们讨论过__init__()方法，说它相当于其他面向对象编程语言的构造方法，也就是类在实例化成对象的时候首先会调用的一个方法。\n有读者可能会问：“有时候在类定义时写__init__()方法，有时候却没有，这是为什么呢？”这是我在论坛中看到的一个问题，我想应该不仅只有一位朋友有疑惑，所以在这里解释下：在现实生活中，有一种东西迫使我们去努力拼搏，使我们获得创造力和生产力，使我们不惜背井离乡来到一个陌生的城市承受孤独和寂寞，这个东西就叫需求……嗯，我想我已经很好地回答了这个问题。举个例子：\n这里需要注意的是，__init__()方法的返回值一定是None，不能是其他：\n所以一般在需要进行初始化的时候才重写__init__()方法，现在大家应该就可以理解造物者的逻辑了。但是你要知道，神之所以是神，是因为他做什么事都留有一手。其实，这个__init__()并不是实例化对象时第一个被调用的魔法方法。\n12.1.2　__new__(cls[, …])\n__new__()才是在一个对象实例化的时候所调用的第一个方法。它跟其他魔法方法不同，它的第一个参数不是self而是这个类（cls），而其他的参数会直接传递给__init__()方法的。\n__new__()方法需要返回一个实例对象，通常是cls这个类实例化的对象，当然你也可以返回其他对象。\n__new__()方法平时很少去重写它，一般让Python用默认的方案执行就可以了。但是有一种情况需要重写这个魔法方法，就是当继承一个不可变的类型的时候，它的特性就显得尤为重要了。\n这里返回str.__new__(cls, string)这种做法是值得推崇的，只需要重写我们关注的那部分内容，然后其他的琐碎东西交给Python的默认机制去完成就可以了，毕竟它们出错的几率要比我们自己写小得多。\n12.1.3　__del__(self)\n如果说__init__()和__new__()方法是对象的构造器的话，那么Python也提供了一个析构器，叫作__del__()方法。当对象将要被销毁的时候，这个方法就会被调用。但一定要注意的是，并非del x就相当于自动调用x.__del__()，__del__()方法是当垃圾回收机制回收这个对象的时候调用的。举个例子：\n12.2　算术运算\n现在来讲一个新的名词：工厂函数，不知道大家还有没有听过？其实在老早就一直在使用它，但由于那时候还没有学习类和对象，我知道那时候说了也是白说。但我知道现在来告诉大家，理解起来就不再是问题了。\nPython2.2以后，对类和类型进行了统一，做法就是将int()、float()、str()、list()、tuple()这些BIF转换为工厂函数：\n看到没有，普通的BIF应该是<class'builtin_function_or_method'>，而工厂函数则是<class'type'>。大家有没有觉得这个<class'type'>很眼熟，在哪里看过？没错啦，如果定义一个类：\n它的类型也是type类型，也就是类对象，其实所谓的工厂函数，其实就是一个类对象。当你调用它们的时候，事实上就是创建一个相应的实例对象：\n现在你是不是豁然发现：原来对象是可以进行计算的！其实你早该发现这个问题了，Python中无处不对象，当在求a+b等于多少的时候，事实上Python就是在将两个对象进行相加操作。Python的魔法方法还提供了自定义对象的数值处理，通过对下面这些魔法方法的重写，可以自定义任何对象间的算术运算。\n12.2.1　算术操作符\n表12-1列举了算数运算相关的魔法方法。\n表12-1　算数运算相关的魔法方法\n举个例子，下面定义一个比较特立独行的类：\n那有些读者可能会问：我想自己写代码，不想通过调用Python默认的方案行不行？答案是肯定行，但要格外小心！\n为什么会陷入无限递归呢？问题就出在这里：\n当对象涉及加法操作时，自动调用魔法方法__add__()，但看看上边的魔法方法写的是什么？写的是return self+other，也就是返回对象本身加另外一个对象，这不就又自动触发调用__add__()方法了吗？这样就形成了无限递归。所以，像下面这么写就不会触发无限递归了：\n上边介绍了很多有关算术运算的魔法方法，意思是当对象进行了相关的算术运算，自然而然就会自动触发对应的魔法方法。嘿，有悟性的读者就会说：“哇，我似乎感觉到拥有了上帝的力量。没错吧？”\nPython正是如此，对于初学者，他们不知道魔法方法，所以默认的魔法方法会让他们以合乎逻辑的形式运行。但当你逐步深入学习，慢慢有了沉淀之后，你突然发现如果有更多的灵活性，就可以把程序写得更好……这时候，Python也可以满足你。通过对指定魔法方法的重写，你完全可以让Python根据你的意愿去执行。\n当然，我这样做从逻辑上是说不过去的……我只是想跟大家说，随着学习的足够深入，Python允许你做的事情就更多、更灵活！\n12.2.2　反运算\n表12-2列举了反运算相关的魔法方法。\n表12-2　反运算相关的魔法方法\n不难发现，这里的反运算魔法方法跟上节介绍的算术运算符保持一一对应，不同之处就是反运算的魔法方法多了一个“r”，例如，__add__()就对应__radd__()。举个例子：\n试一下：\n关于反运算，这里还要注意一点：对于a+b，b的__radd__(self, other)的self是b对象，other是a对象。\n所以不能这么写：\n所以对于注重操作数顺序的运算符（例如减法、除法、移位），在重写反运算魔法方法的时候，就一定要注意顺序问题了。\n12.2.3　增量赋值运算\nPython也有大量的魔术方法可以来定制增量赋值语句，增量赋值其实就是一种偷懒的形式，它将操作符与赋值来结合起来。例如：\n12.2.4　一元操作符\n一元操作符就是只有一个操作数的意思，像a+b这样，加号左右有a、b两个操作数，叫作二元操作符。只有一个操作数的，例如把减号放在一个操作数的前边，就是取这个操作数的相反数的意思，这时候管它叫负号。\nPython支持的一元操作符主要有__neg__()（表示正号行为），__pos__()（定义负号行为），__abs__()（定义当被abs()调用时的行为，就是取绝对值的意思），还有一个__invert__()（定义按位取反的行为）。\n12.3　简单定制\n基本要求：\n定制一个计时器的类。\nstart和stop方法代表启动计时和停止计时。\n假设计时器对象t1，print(t1)和直接调用t1均显示结果。\n当计时器未启动或已经停止计时，调用stop方法会给予温馨的提示。\n两个计时器对象可以进行相加：t1+t2。\n只能使用提供的有限资源完成。\n这里需要限定你只能使用哪些资源，因为Python的模块是非常多的，你要是直接上网找个写好的模块进来，那就达不到锻炼的目的了。\n下边是演示：\n你需要下面的资源：\n使用time模块的localtime方法获取时间（有关time模块可参考：http://bbs.fishc.com/thread-51326-1-1.html）。\ntime.localtime返回struct_time的时间格式。\n表现你的类：__str__()和__repr__()魔法方法。\n有了这些知识，可以开始来编写代码了：\n似乎做得不错了，但这里还有一些问题。假设用户不按常理出牌，问题就会很多：\n当直接执行t1的时候，Python会调用__str__()魔法方法，但它却说这个类没有prompt属性。prompt属性在哪里定义的？在_calc()方法里定义的，对不？但是没有执行stop()方法，_calc()方法就没有被调用到，所以也就没有prompt属性的定义了。\n要解决这个问题也很简单，大家应该还记得在类里边，用得最多的一个魔法方法是什么？是__init__()嘛，所有属于实例对象的变量只要在这里边先定义，就不会出现这样的问题了。\n这里又出错了（当然我是故意的），大家先检查一下是什么问题？\n其实会导致这个问题，是因犯了一个微妙的错误，这样的错误通常很容易疏忽，而且很难排查。Python这里抛出了一个异常：TypeError：'int'object is not callable。\n仔细瞧，在调用start()方法的时候报错，也就是说，Python认为start是一个整型变量，而不是一个方法。为什么呢？大家看__init__()方法里，是不是也命名了一个叫作self.start的变量，如果类中的方法名和属性同名，属性会覆盖方法。\n好了，让我们把所有的self.start和self.end都改为self.begin和self.end吧！\n现在程序没问题了，但显示时间是000003这样不大人性化，还是希望可以按照“年月日小时分钟秒”这么去显示，然后值为0的就不显示啦，这样才是人看的嘛，对不对？！所以这里添加一个列表用来存放对应的单位：\n然后在适当的地方增加温馨提示：\n最后，再重写一个魔法方法__add__()，让两个计时器对象相加会自动返回时间的和：\n看上去代码是不错，也能正常计算了。但是，这个程序有几点不足还需要大家课后来思考一下如何修改：\n（1）如果开始计时的时间是（2022年2月22日16：30：30），停止时间是（2025年1月23日15：30：30），那么按照用停止时间减开始时间的计算方式就会出现负数，你应该对此做一些转换。\n（2）现在的计算机速度都非常快，而这个程序最小的计算单位却只是秒，精度是远远不够的。\n12.4　属性访问\n通常可以通过点（.）操作符的形式去访问对象的属性，在11.9节中也谈到了如何通过几个BIF适当地去访问属性：\n然后还介绍了一个叫作property()函数的用法，这个property()使得我们可以用属性去访问属性：\n那么关于属性访问，肯定也有相应的魔法方法来管理。通过对这些魔法方法的重写，你可以随心所欲地控制对象的属性访问。大家是不是想想就有点小激动了呢？来吧，让我们开始吧！\n表12-3列举了属性相关的魔法方法。\n表12-3　属性相关的魔法方法\n做个小测试：\n这几个魔法方法在使用上需要注意的是，有一个死循环的陷阱，初学者比较容易中招，还是通过一个实例来讲解！写一个矩形类（Rectangle），默认有宽（width）和高（height）两个属性；如果为一个叫square的属性赋值，那么说明这是一个正方形，值就是正方形的边长，此时宽和高都应该等于边长。\n这是为什么呢？\n分析一下：实例化对象，调用__init__()方法，在这里给self.width和self.heigth分别初始化赋值。一发生赋值操作，就会自动触发__setattr__()魔法方法，width和height两个属性被赋值，于是执行else的下边的语句，就又变成了self.width=value，那么就相当于又触发了__setattr__()魔法方法了，死循环陷阱就是这么来的。\n那怎么解决呢？我这里说两个方法。第一个就是跟刚才一样，用super()来调用基类的__setattr__()，那么这样就依赖基类的方法来实现赋值：\n另一种方法就是给特殊属性__dict__赋值。对象有一个特殊的属性，叫作__dict__，它的作用是以字典的形式显示出当前对象的所有属性以及相对应的值：\n12.5　描述符（property的原理）\n此前提到过property()函数，这不提不要紧，一提不得了，把大家的好奇心都给提起来了。大家都在问：“这property()到底被下了什么药？怎么这么神奇？”如果你想知道property()函数的实现原理，那么本节的内容就不能错过。\n本节要讲的内容叫作描述符（descriptor），用一句话来解释，描述符就是将某种特殊类型的类的实例指派给另一个类的属性。那什么是特殊类型的类呢？就是至少要在这个类里边定义__get__()、__set__()或__delete__()三个特殊方法中的任意一个。\n表12-4列举了描述符相关的魔法方法。\n表12-4　描述符相关的魔法方法\n举个最直观的例子：\n由于MyDescriptor实现了__get__()、__set__()和__delete__()方法，并且将它的类实例指派给Test类的属性，所以MyDescriptor就是所谓描述符类。到这里，大家有没有看到property()的影子？\n好，实例化Test类，然后尝试对x属性进行各种操作，看看描述符类会有怎样的响应：\n当访问x属性的时候，Python会自动调用描述符的__get__()方法，几个参数的内容分别是：self是描述符类自身的实例；instance是这个描述符的拥有者所在的类的实例，在这里也就是Test类的实例；owner是这个描述符的拥有者所在的类本身。\n对x属性进行赋值操作的时候，Python会自动调用__set__()方法，前两个参数跟__get__()方法是一样的，最后一个参数value是等号右边的值。\n最后一个del操作也是同样的道理：\n只要弄清楚描述符，那么property的秘密就不再是秘密了！property事实上就是一个描述符类。下边就定义一个属于我们自己的MyProperty：\n看，这不就自己实现property()函数了嘛，简单吧？！\n最后讲一个实例：先定义一个温度类，然后定义两个描述符类用于描述摄氏度和华氏度两个属性。两个属性会自动进行转换，也就是说，你可以给摄氏度这个属性赋值，然后打印的华氏度属性是自动转换后的结果。\n12.6　定制序列\n常言道，无规矩不成方圆，讲的是万事万物的发展都是要在一定的规则下进行，只有遵照一定的协议去做了，事情才能往正确的方向上发展。\n本节要谈的是定制容器，要想成功地实现容器的定制，便需要先谈一谈协议。协议是什么呢？协议（Protocol）与其他编程语言中的接口很相似，它规定哪些方法必须要定义。然而，在Python中的协议就显得不那么正式。事实上，在Python中，协议更像是一种指南。\n这有点像Python极力推崇的鸭子类型（扩展阅读：http://bbs.fishc.com/thread-51471-1-1.html），当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。Python就是这样，并不会严格地要求你一定要怎样去做，而是让你靠着自觉和经验把事情做好！\n在Python中，像序列类型（如列表、元组、字符串）或映射类型（如字典）都是属于容器类型。本节来讲定制容器，那就必须要知道，定制容器有关的一些协议：\n如果说你希望定制的容器是不可变的话，你只需要定义__len__()和__getitem__()方法。\n如果你希望定制的容器是可变的话，除了__len__()和__getitem__()方法，你还需要定义__setitem__()和__delitem__()两个方法。\n表12-5列举了定制容器类型相关的魔法方法及含义。\n表12-5　定制容器类型相关的魔法方法\n验证大家学习能力的时候到了。现在动动手，编写一个不可改变的自定义列表，要求记录列表中每个元素被访问的次数。\n12.7　迭代器\n自始至终，有一个概念一直在用，但我们却从来没有认真地去深入剖析它。这个概念就是迭代。迭代这个词听得很多了，现在不仅在数学领域使用这个词，我们经常听到类似这个产品经过多次迭代，质量和品质已经有了大幅度提高，这次事件纯属意外……\n大家应该听出来了，迭代的意思类似于循环，每一次重复的过程被称为一次迭代的过程，而每一次迭代得到的结果会被用来作为下一次迭代的初始值。提供迭代方法的容器称为迭代器，通常接触的迭代器有序列（列表、元组、字符串）还有字典也是迭代器，都支持迭代的操作。\n举个例子，通常使用for语句来进行迭代：\n字符串就是一个容器，同时也是一个迭代器，for语句的作用就是触发这个迭代器的迭代功能，每次从容器里依次拿出一个数据，这就是迭代操作。\n字典和文件也是支持迭代操作的：\n关于迭代，Python提供了两个BIF：\niter()。\nnext()。\n对一个容器对象调用iter()就得到它的迭代器，调用next()迭代器就会返回下一个值，然后怎么样结束呢？如果迭代器没有值可以返回了，Python会抛出一个叫作StopIteration的异常：\n所以，利用这两个BIF，可以分析出for语句其实是这么工作的：\n那么关于实现迭代器的魔法方法有两个：\n__iter()__。\n__next()__。\n一个容器如果是迭代器，那就必须实现__iter__()魔法方法，这个方法实际上就是返回迭代器本身。接下来重点要实现的是__next__()魔法方法，因为它决定了迭代的规则。简单举个例子大家就清楚了：\n好了，这个迭代器的唯一亮点就是没有终点，所以如果没有跳出循环，它会不断迭代下去。那可不可以加一个参数，用于控制迭代的范围呢？\n是不是很容易呢？嗯，Python就是可以这么简简单单的一门语言！\n12.8　生成器（乱入）\n由于前边介绍了迭代器，所以这里趁热打铁，给大家讲一讲这个生成器。虽然说生成器和迭代器可以说是Python近几年来引入的最强大的两个特性，但是生成器的学习，并不涉及魔法方法，甚至它巧妙地避开了类和对象，仅通过普通的函数就可以实现了。\n由于生成器的概念要比较高级一些，所以在函数章节就没有提及它，还是那句老话，因为那时候讲了也是白讲。学习就是这么一个渐进的过程，像上节介绍的迭代器，很多人学完之后感叹：哎呀，Python怎么就这么简单呐！但如果在讲循环那个章节来讲迭代器的实现原理，那大家势必就会一头雾水了。\n正如刚才说的，生成器其实是迭代器的一种实现，那既然迭代可以实现，为何还要生成器呢？有一句话叫“存在即合理”，生成器的发明一方面是为了使得Python更为简洁，因为，迭代器需要我们自己去定义一个类和实现相关的方法，而生成器则只需要在普通的函数中加上一个yield语句即可。\n在另一个更重要的方面，生成器的发明，使得Python模仿协同程序的概念得以实现。所谓协同程序，就是可以运行的独立函数调用，函数可以暂停或者挂起，并在需要的时候从程序离开的地方继续或者重新开始。\n对于调用一个普通的Python函数，一般是从函数的第一行代码开始执行，结束于return语句、异常或者函数所有语句执行完毕。一旦函数将控制权交还给调用者，就意味着全部结束。函数中做的所有工作以及保存在局部变量中的数据都将丢失。再次调用这个函数时，一切都将从头创建。\nPython是通过生成器来实现类似于协同程序的概念：生成器可以暂时挂起函数，并保留函数的局部变量等数据，然后在再次调用它的时候，从上次暂停的位置继续执行下去。\n好，多说不如实干，举个例子：\n正如大家所看到的，当函数结束时，一个StopIteration异常就会被抛出。由于Python的for循环会自动调用next()方法和处理StopIteration异常，所以for循环当然也是可以对生成器产生作用的：\n像前面介绍的斐波那契的例子，也可以用生成器来实现：\n事到如今，你应该已经很好地掌握了列表推导式，那大家猜猜看下边这个列表推导式表达的是啥意思：\n其实上边这个列表推导式求的就是100以内，能够被2整除，但不能够被3整除的所有整数：\nPython3除了有列表推导式之外，还有字典推导式：\n还有集合推导式：\n那这时有读者可能就会想：“那按照这种剧情发展下去，应该会有字符串推导式和元组推导式吧？”不妨试试：\n噢，不行，因为只要在双引号内，所有的东西都变成了字符串，所以不存在字符串推导式了。那元组推导式呢？\n咦？似乎这个不是什么推导式，大家看出来什么门道了吗？generator，多么熟悉的单词啊，不就是生成器嘛！没错，用普通的小括号括起来的正是生成器推导式，来证明一下：\n用for语句把剩下的都打印出来：\n还有一点特性更牛，生成器推导式如果作为函数的参数，可以直接写推导式，而不用加小括号：\n关于生成器的技术要点，这里小甲鱼还给大家转了一篇不错的文章，大家课后可以参考学习一下：解释yield和Generators（生成器）（http://bbs.fishc.com/thread-56023-1-1.html）。\n第13章　模块\n",
  "factionName": "零基础入门学习Python",
  "newest": 10,
  "comments": [],
  "source": [],
  "index": "3"
},{
  "_id": "b4a8e14f-54b6-4987-a478-4edbccf7148c",
  "headerImage": "https://wk-gulimall.oss-cn-beijing.aliyuncs.com/ProgramBook/221d9391-4feb-4a3d-85b7-a6830e487236.jpg",
  "updateTime": {
    "$date": "2023-01-23T17:00:59.062Z"
  },
  "author": "Schwar",
  "des": "我们写这本书不仅仅是为了满足MySQL应用开发者的需求，也是为了满足MySQL数据库管理员的需要。我们假定读者已经有了一定的MySQL基础。我们还假定读者对于系统管理、网络和类Unix的操作系统都有一些了解。\n本书的第二版为读者提供了大量的信息，但没有一本书是可以涵盖一个主题的所有方面的。在第二版和第三版之间的这段时间里，我们记录了数以千计有趣的问题，其中有些是我们解决的，也有一些是我们观察到其他人解决的。当我们在规划第三版的时候发现，如果要把这些主题完全覆盖，可能三千页到五千页的篇幅都还不够，这样本书的完成就遥遥无期了。在反思这个问题后，我们意识到第二版强调的广泛的覆盖度事实上有其自身的限制，从某种意义上来说也没有引导读者如何按照MySQL的方式来思考问题。\n所以第三版和第二版的关注点有很大的不同。我们虽然还是会包含很多的信息，并且会强调同样的诸如可靠性和正确性的目标，但我们也会在本书中尝试更深入的讨论：我们会指出MySQL为什么会这样做，而不是MySQL做了什么。我们会使用更多的演示和案例学习来将上述原则落地。通过这样的方式，我们希望能够尝试回到下面这样的问题：“给出MySQL的内部结构和操作，对于实际应用能带来什么帮助？为什么能有这样的帮助？如何让MySQL适合（或者不适合）特定的需求？”\n最后，我们希望关于MySQL内部原理的知识能够帮助大家解决本书没有覆盖到的一些情况。我们更希望读者能培养发现新问题的洞察力，能学习和实践合理的方式来设计、维护和诊断基于MySQL的系统。\n本书是如何组织的\n本书涵盖了许多复杂的主题。在这里，我们将解释一下是如何将这些主题有序地组织在一起的，以便于阅读和学习。\n概述\n第1章是非常基础的一章，在更深入地学习之前建议先熟悉一下这部分内容。在有效地使用MySQL之前应当理解它是如何组织的。本章解释了MySQL的架构及其存储引擎的关键设计。如果读者还不太熟悉关系数据库和事务的基础知识，本章也可以带来一点帮助。如果之前已经对其他关系数据库如Oracle比较熟悉，本章也可以帮助读者了解MySQL的入门知识。本章还包括了一点MySQL的历史背景：MySQL随着时间的演进、最近的公司所有权更替，以及我们认为比较重要的内容。\n打造坚实的基础\n本书前几章的内容在今后使用MySQL的过程中可能会被不断地引用到，它们是非常基础的内容。\n第2章讨论了基准测试的基础，例如服务器可以处理的工作负载的类型、处理特定任务的速度等。基准测试是一项至关重要的技能，可用于评估服务器在不同负载下的表现，但也要明白在什么情况下基准测试不能发挥作用。\n第3章介绍了我们常用于故障诊断和服务器性能问题分析的一种面向响应时间的方法。该方法已经被证明可以解决我们曾碰到过的一些极为棘手的问题。当然也可以选择修改我们所使用的方法（实际上我们的方法也是从Cary Millsap的方法修改而来的），但无论如何，至少不能没有方法胡乱猜测。\n从第4章到第6章，连续介绍了三个关于良好的数据库逻辑设计和物理设计基础的话题。第4章涵盖了不同数据类型的细节差别以及表设计的原则。第5章则展开讨论了索引，这是数据库的物理设计。对于索引的深入理解和利用是高效使用MySQL的基础，相信这一章会经常需要回头翻看。而第6章则包含了分析MySQL的查询是如何执行的，以及如何利用查询优化器的话题。该章也包含了大量常见类型查询的例子，演示了MySQL是如何做好工作的，以及如何改写查询以利用MySQL的特性。\n到此为止，已经覆盖了关于数据库的基础内容：表、索引、数据和查询。第7章则在MySQL基础知识之外介绍了MySQL的高级特性是如何工作的。这章的内容包括分区、存储引擎、触发器，以及字符集。MySQL中这些特性的实现可能不同于其他数据库，可能之前读者并不清楚这些不同，因此理解它们对于性能可能会带来新的收益。\n配置应用程序\n接下来的两章讲述的是如何让MySQL、应用程序及硬件一起很好地工作。第8章介绍了如何配置MySQL，以便更好地利用硬件，达到更好的可靠性和鲁棒性。第9章解释了如何让操作系统和硬件工作得更好。另外也深入讨论了固态硬盘，为高可扩展性应用发挥更好的性能提供了硬件配置的建议。\n上面两章都一定程度地涉及了MySQL的内部知识。这将会是一个反复出现的主题，附录中也会有相关内容可以学习到MySQL的内部是如何实现的，理解了这些知识将帮助读者更好地理解某些现象背后的原理。\n作为基础设施组件的MySQL\nMySQL不是存在于真空中的，而是应用整体的一个环节，因此需要考虑整个应用架构的鲁棒性。下面的章节将告诉我们该如何做到这一点。\n第10章讨论了MySQL的杀手级特性：能够设置多个服务器从一台主服务器同步数据。不幸的是，复制可能也是MySQL给很多用户带来困扰的一个特性。但实际上不应该发生这样的情况，本章将告诉你如何让复制运行得更好。\n第11章讨论了什么是可扩展性（这和性能不是一回事），应用和系统为什么会无法扩展，该怎么改善扩展性。如果能够正确地处理，MySQL的可扩展性是足以应付任何需求的。第12章讲述的是和可扩展性相关但又完全不同的主题：如何保障MySQL稳定而正确地持续运行。第13章将告诉你当MySQL在云计算环境中运行时会有什么不同的事情发生。第14章解释了什么是全方位的优化（full-stack optimization），就是从前端到后端的整体优化，从用户体验开始直到数据库。\n即使是世界上设计最好、最具可扩展性的架构，如果停电会导致彻底崩溃，无法抵御恶意攻击，解决不了应用的bug和程序员的错误，以及其他一些灾难场景，那就不是什么好的架构。第15章讨论了MySQL数据库各种备份与恢复的场景。这些策略可以帮助读者减少在各种不可抗的硬件失效时的宕机时间，保证在各种灾难下的数据最终可恢复。\n其他有用的主题\n在本书的最后一章以及附录中，我们探讨了一些无法明确地放到前面章节的内容，以及一些被前面多个章节引用而需要特别注意的主题。\n第16章探索了一些可以帮助用户更有效地管理和监控MySQL服务器的工具，有些是开源的，也有些是商业的。\n附录A介绍了近年来成长迅速的三个主要的非MySQL官方版本，其中一个是我们公司在维护的产品。知道还有其他什么是可用的选择是有价值的；很多MySQL难以解决的棘手问题在其他的变种版本中说不定就不是问题了。这三个版本中的两个（Percona Server和MariaDB）是MySQL的完全可替换版本，所以尝试使用的成本相对来说是很低的。当然，在这里我们也需要补充一点，Oracle提供的MySQL官方版本对于大多数用户来说都能服务得很好。\nSHOW INNODB STATUS\nEXPLAIN\n软件版本与可用性\nMySQL是一个移动靶。从Jeremy写作本书第一版到现在，MySQL已经发布了好几个版本。当本书第一版的初稿交给出版社的时候，MySQL 4.1和5.0还只是alpha版本，而如今MySQL 5.1和5.5已经是很多在线应用的主力版本。在我们写完这第三版的时候，MySQL 5.6也即将发布。\nhttp://dev.mysql.com/doc/\n(1)\n(2)\nDBI\nDBD::MySQL\n本书使用的约定\n下面是本书中使用的一些约定。\nItalic\n新的名字、URL、邮件地址、用户名、主机名、文件名、文件扩展名、路径名、目录，以及Unix命令和工具都使用斜体表示。\n等宽字体（Constant width）\n包括代码元素、配置选项、数据库和表名、变量和值、函数、模块、文件内容、命令输出等，使用的是等宽字体。\n加粗的等宽字体（Constant width bold）\n命令或者其他需要用户输入的文本，命令输出中需要强调的某些内容，会使用加粗的等宽字体。\nConstant width italic\n需要用户替换的文本以斜体的等宽字体表示。\n使用示例代码\n本书的目标是为了帮助读者更好地工作。一般来说，你可以在程序或者文档中使用本书中的代码。只要不是大规模地复制重要的代码，使用的时候不需要联系我们。例如，你编写的程序中如果只是使用了本书部分的代码片段则无须取得授权，而出售或者分发O'Reilly书籍示例代码的CD-ROM盘片则需要经过授权。引用本书的代码回答问题也无须取得授权，而大量引用本书的示例代码到产品文档中则需要获取授权。\nhttp://www.highperfmysql.com\nHigh Performance MySQL，Third Edition\npermissions@oreilly.com\nSafari在线书店\nwww.safaribooksonline.com\nSafari在线书店为组织、政府机构和个人提供了一系列的产品组合和定价计划。订阅者可以访问数以千计的图书、培训视频和手稿，这些存在于一个可搜索的数据库中，涵盖的出版公司有O'Reilly Media，Prentice Hall Professional，Addison-Wesley Professional，Microsoft Press，Sams，Que，Peachpit Press，Focal Press，Cisco Press，John Wiley&Sons，Syngress，Morgan Kaufmann，IBM Redbooks，Packt，Adobe Press，FT Press，Apress，Manning，New Riders，McGraw-Hill，Jones&Bartlett，Course Technology，等等。如需了解更多关于Safari在线书店的情况，请访问在线网站。\n如何联系我们\n若有关于本书的任何评论或者问题，请和出版公司联系。\n美国：\nO'Reilly Media，Inc.\n1005 Gravenstein Highway North\nSebastopol，CA 95472\n中国：\n北京市西城区西直门南大街2号成铭大厦C座807室（100035）\n奥莱利技术咨询（北京）有限公司\n本书有一个配套的网页，上面列出了勘误表、示例代码及其他相关信息。下面是此网页的地址：\nhttp://shop.oreilly.com/product/0636920022343.do\n如果有关于本书的评论和技术问题，也可以通过邮件进行沟通：\nbookquestions@oreilly.com\n如果想了解更多关于我们出版公司的书籍、会议、资源中心和O'Reilly网络的信息，请访问网站：\nhttp://www.oreilly.com\nhttp://facebook.com/oreilly\nhttp://twitter.com/oreillymedia\nhttp://www.youtube.com/oreillymedia\nhttp://www.percona.com\n本书第三版的致谢\n(3)\nBaron也要感谢他的妻子Lynn、他的母亲Connie，以及他的岳父母Jane和Roger，感谢他们一如既往地支持他的工作，尤其是不断地鼓励他，并且承担了所有的家务和照顾整个家庭的重任。也要感谢Peter和Vadim，你们是如此优秀的老师和同事。Baron将此版本献给Alan Rimm-Kaufman，以纪念他给予的伟大的爱和鼓励，这些都将永志不忘。\n本书第二版的致谢\nSphinx的开发者Andrew Aksyonoff编写了附录F。我们非常感谢他首次对此进行深入的讨论。\n在编写本书的时候，我们得到了很多人的无私帮助。在此无法一一列举——我们真的非常感谢MySQL社区和MySQL AB公司的每一个人。下面是对本书做出了直接贡献的人，如有遗漏，还请见谅。他们是：Tobias Asplund，Igor Babaev，Pascal Borghino，Roland Bouman，Ronald Bradford，Mark Callaghan，Jeremy Cole，Britt Crawford和他的HiveDB项目，Vasil Dimov，Harrison Fisk，Florian Haas，Dmitri Joukovski和他的Zmanda项目（同时感谢Dmitri为解释LVM快照提供的配图），Alan Kasindorf，Sheeri Kritzer Cabral，Marko Makela，Giuseppe Maxia，Paul McCullagh，B. Keith Murphy，Dhiren Patel，Sergey Petrunia，Alexander Rubin，Paul Tuckfield，Heikki Tuuri,以及Michael“Monty”Widenius。在这里还要特别感谢O'Reilly的编辑Andy Oram和助理编辑Isabel Kunkle，以及审稿人Rachel Wheeler，同时也要感谢O'Reilly团队的其他所有成员。\n来自Baron\n我要感谢我的妻子Lynn Rainville和小狗Carbon。如果你也曾写过一本书，我相信你就能体会到我是如何地感谢他们。我也非常感谢Alan Rimm-Kaufman和我在Rimm-Kaufman集团的同事，在写书的过程中，他们给了我支持和鼓励。谢谢Peter、Vadim和Arjen，是你们给了我梦想成真的机会。最后，我要感谢Jeremy和Derek为我们开了个好头。\n来自Peter\n我从事MySQL性能和可扩展性方面的演讲、培训和咨询工作已经很多年了，我一直想把它们扩展到更多的受众。因此，当Andy Oram加入到本书的编写当中时，我感到非常兴奋。此前我没有写过书，所以我对所需要的时间和精力都毫无把握。一开始我们谈到只对第一版做一些更新，以跟上MySQL最新的版本升级，但我们想把更多新素材加入到书中，结果几乎相当于重写了整本书。\n这本书是真正的团队合作的结晶。因为我忙于Percona公司的事情——这是我和Vadim的咨询公司，而且英语并非我的第一语言，所以我们有着不同的角色分工。我负责提供大纲和技术性内容，评审所有的材料，在写作的时候再进行修订和扩展。当Arjen（MySQL文档团队的前负责人）加入之后，我们就开始勾画出整个提纲。在Baron加入后，一切才开始真正行动起来，他能够以不可思议的速度编写出高质量的内容。Vadim则在深入检查MySQL源代码和提供基准测试及其他研究来巩固我们的论点时提供了巨大的帮助。\n当我们编写本书时，我们发现有越来越多的领域需要刨根问底。本书的大部分主题，如复制、查询优化、InnoDB、架构和设计都足以单独成书。因此，有时候我们不得不在某个点停止深入，把余下的材料用在将来可能出版的新版本中，或者我们的博客、演讲和技术文章中。\n本书的评审者给了我们非常大的帮助，无论是来自MySQL AB公司内部的人员，还是外部的人员，他们都是MySQL领域最优秀的世界级专家。其中包括MySQL的创建者Michael Widenius、InnoDB的创建者Heikki Tuuri、MySQL优化器团队的负责人Igor Babaev，以及其他人。\n我还要感谢我的妻子Katya Zaytseva，我的孩子Ivan和Nadezhda，他们允许我把家庭时间花在了本书的写作上。我也要感谢Percona的员工，当我在公司里“人间蒸发”去写书时，他们承担了日常事务的处理工作。当然，我也要感谢O'Reilly和Andy Oram让这一切成为可能。\n来自Vadim\n我要感谢Peter，能够在本书中和他合作，我感到十分开心，期望在其他项目中能继续共事。我也要感谢Baron，他在本书的写作过程中起了很大的作用。还有Arjen，跟他一起工作非常好玩。我还要感谢我们的编辑Andy Oram，他抱着十二万分的耐心和我们一起工作。此外，还要感谢MySQL团队，是他们创造了这个伟大的软件。我还要感谢我们的客户给予我调优MySQL的机会。最后，我要特别感谢我的妻子Valerie，以及我们的孩子Myroslav和Timur，他们一直支持我，帮助我一步步前进。\n来自Arjen\n我要感谢Andy的睿智、指导和耐心，感谢Baron中途加入到我们当中来、感谢Peter和Vadim坚实的背景信息和基准测试。也要感谢Jeremy和Derek在第一版中打下的基础。在我的书上，Derak题写着：“要诚实——这就是我的所有要求”。\n我也要感谢我在MySQL AB公司时的所有同事，在那里我获得了关于本书主题的大多数知识。在此，我还要特别提到Monty，我一直认为他是令人自豪的MySQL之父，尽管他的公司如今已经成为Sun公司的一部分。我要感谢全球MySQL社区里的每一个人。\n最后同样重要的是，我要感谢我的女儿Phoebe，在她尚年少的生活舞台上，不用关心什么是MySQL，也不用考虑Wiggles指的是什么东西。从某些方面来讲，无知就是福。它能给予我们一个全新的视角来看清生命中真正重要的是什么。对于读者，祝愿你们的书架上又增添了一本有用的书，还有，不要忘记你的生活。\n本书第一版的致谢\n要完成这样一本书的写作，离不开许许多多人的帮助。没有他们的无私援助，你手上的这本书就可能仍然是我们显示器屏幕四周的那一堆贴纸。这是本书的一部分，在这里，我们可以感谢每一个曾经帮助我们脱离困境的人，而无须担心突然奏响的背景音乐催促我们闭上嘴巴赶紧走掉——如同你在电视里看到的颁奖晚会那样。\n如果没有编辑Andy Oram坚决的督促、请求、央求和支持，我们就无法完成本书。如果要找对于本书最负责的一个人，那就是Andy。我们真的非常感谢每周一次的唠唠叨叨的会议。\n然而，Andy不是一个人在战斗。在O'Reilly，还有一批人都参与了将那些小贴纸变成你正在看的这本书的工作。所以我们也要感谢那些在生产、插画和销售环节的人们，感谢你们把这本书变成实体。当然，也要感谢Tim O'Reilly，是他持久不变地承诺为广大开源软件出版一批业内最好的图书。\nhttp://vbmysql.com\n来自Jeremy\n我要在此感谢Andy，是他同意接纳这个项目，并持续不断地鞭策我们加入新的章节内容。Derek的帮助也非常关键，本书最后的20％～30％内容由他一手完成，这使得我们没有错过下一个目标日期。感谢他同意中途加入进来，代替我只能偶尔爆发一下的零星生产力，完成了关于XML的烦琐工作、第10章、附录F，以及我丢给他的那些活儿。\n我也要感谢我的父母，在多年以前他们就给我买了Commodore 64电脑，他们不仅在前10年里容忍了我就像要以身相许般的对电子和计算机技术的痴迷，并在之后还成为我不懈学习和探索的支持者。\n接下来，我要感谢在过去几年里在Yahoo！布道推广MySQL时遇到的那一群人。跟他们共事，我感到非常愉快。在本书的筹备阶段，Jeffrey Friedl和Ray Goldberger给了我鼓励和反馈意见。在他们之后还有Steve Morris、James Harvey和Sergey Kolychev容忍了我在Yahoo! Finance MySQL服务器上做着看似固定不变的实验，即使这打扰了他们的重要工作。我也要感谢Yahoo!的其他成员，是他们帮我发现了MySQL上的那些有趣的问题和解决方法。还有，最重要的是要感谢他们对我有足够的信任和信念，让我把MySQL用在Yahoo!重要和可见的部分业务上。\nLinux Magazine\n我要感谢Monty和David，感谢你们与这个世界分享了MySQL。说到MySQL AB，也要感谢在那里的其他“牛”人，是他们鼓励我写成本书：Kerry，Larry，Joe，Marten，Brian，Paul，Jeremy，Mark，Harrison，Matt，以及团队中的其他人。他们真的非常棒。\n最后，我要感谢我博客的读者，是他们鼓励我撰写基于日常工作的非正式的MySQL及其他技术文章。最后同样重要的是，感谢Goon Squad。\n来自Derek\n就像Jeremy一样，有太多同样的原因，我也要感谢我的家庭。我要感谢我的父母，是他们不停地鼓励我去写一本书，哪怕他们头脑中都没有任何和它相关的东西。我的祖父母给我上了两堂很有价值的课：美元的含义，以及我跟电脑相爱有多深，他们还借钱给我去购买了我平生第一台电脑：Commodore VIC-20。\n我万分感谢Jeremy邀请我加入他那旋风般的写作“过山车”中来。这是一个很棒的体验，我希望将来还能跟他一起工作。\n我要特别感谢Raymond De Roo，Brian Wohlgemuth，David Calafrancesco，Tera Doty，Jay Rubin，Bill Catlan，Anthony Howe，Mark O'Neal，George Montgomery，George Barber，以及其他无数耐心听我抱怨的人，我从他们那里了解到我所讲述的内容是否能让门外汉也能理解，或者仅仅得到一个我所希望的笑脸。没有他们，这本书可能也能写出来，但我几乎可以肯定我会在这个过程中疯掉。\n————————————————————\n(1)\n(2)\nhttp://unxutils.sourceforge.net\nhttp://gnuwin32.sourceforge.net\n(3)\nhttp://planet.mysql.com\n",
  "factionName": "高性能MySQL：第3版",
  "newest": 10,
  "comments": [],
  "source": [],
  "index": "5"
},{
  "_id": "a505bf88-4ccb-45c0-9134-58e0c88c506f",
  "headerImage": "https://wk-gulimall.oss-cn-beijing.aliyuncs.com/ProgramBook/8151e76d-e741-49fc-a4ca-5ab09f418174.jpg",
  "updateTime": {
    "$date": "2023-01-23T17:00:59.871Z"
  },
  "author": "亨特，苏帕拉",
  "des": "公元21世纪，软件业江湖动荡，人才辈出，各大门派林立，白道黑帮，都欲靠各自门派的武功称霸武林。 在那些外家功门派（传统的瀑布开发方法、CMM、ISO和RUP等）和非正统教（中国式太极敏捷UDD等）当道之际，一股新势力正在崛起——以敏捷方法为总称的一批内家功门派。 下面的歌诀是对内家武功招数的概述： 迭代开发，价值优先 分解任务，真实进度 站立会议，交流畅通 用户参与，调整方向 结对编程，代码质量 测试驱动，安全可靠 持续集成，尽早反馈 自动部署，一键安装 定期回顾，持续改进 不断学习，提高能力 上面的每种招式，都可寻得一本手册，介绍其动作要领和攻防章法。几乎每个内家功门派都有自己的拳法和套路。 但，正所谓“练拳不练功，到老一场空”。学习招数和套路不难，难的是如何练就一身真功夫。内家功，以练内为主，内外结合，以动作引领内气，以内气催领动作，通过后天的修炼来弥补先天的不足。 本书是一本内功手册。它注重于培养软件开发者的态度、原则、操守、价值观，即识、胆、气、劲、神是也。 敏捷的实践者Venkat Subramaniam和Andy Hunt携手著下此书。望有志之士有缘得到此书，依法修习，得其精要；由心知到身知，入筋、入骨、入髓，修炼得道。而后，匡扶正义，交付高质量的软件，为人类造福。",
  "factionName": "高效程序员的45个习惯：敏捷开发修炼之道",
  "newest": 10,
  "comments": [],
  "source": [],
  "index": "5"
},{
  "_id": "36a57699-fa98-4825-a56a-a2490d8c02c8",
  "headerImage": "https://wk-gulimall.oss-cn-beijing.aliyuncs.com/ProgramBook/02de0cd3-de93-4c51-b0c4-1d6c0c95ec12.jpg",
  "updateTime": {
    "$date": "2023-01-23T17:01:01.525Z"
  },
  "author": "黄文毅, ",
  "des": "Spring Boot是近几年非常流行的微服务框架，相对于其他开发框架，Spring Boot不但使用更加简单，而且功能更加丰富、性能更加稳定和健壮。Spring Boot是在Spring框架基础上创建的一个全新的框架，其设计目的是简化Spring应用的搭建和开发过程，使得开发人员不仅能提高开发速度和生产效率，而且能够增强系统的稳定性和扩展性。\n本书通过完整的项目实例带领大家一步一步学习Spring Boot。通过实战项目学习Spring Boot的基础知识、使用技巧以及技术原理，最终达到融会贯通。\n本书内容安排\n本书是一本Spring Boot项目实战书籍，从内容结构上可以分为两部分，第1～17章是项目实战篇，主要介绍如何使用Spring Boot、如何通过Spring Boot整合其他热门技术、如何通过Spring Boot开发完整的项目。第18章是原理篇，主要介绍Spring Boot背后的原理和执行的流程。\n下面是各章的内容概要。\n第1章介绍开始学习Spring Boot之前的环境准备、如何一分钟快速搭建Spring Boot、Spring Boot文件目录以及Maven Helper插件的安装和使用等。\n第2章主要介绍如何安装和使用MySQL、Spring Boot集成MySQL数据库、Spring Boot集成Druid以及通过实例讲解Spring Boot具体的运用。\n第3章主要介绍Spring Data JPA核心接口及继承关系、在Spring Boot中集成Spring Data JPA以及如何通过Spring Data JPA实现增删改查及自定义查询等。\n第4章主要介绍Thymeleaf模板引擎、Thymeleaf模板引擎标签和函数、在Spring Boot中使用Thymeleaf、集成测试以及Rest Client工具的使用。\n第5章主要介绍Spring声明式事务、Spring注解事务行为以及在Spring Boot中如何使用方法级别事务和类级别事务等。\n第6章主要介绍如何在Spring Boot中使用过滤器Filter和监听器Listener。\n第7章主要介绍如何安装Redis缓存、Redis缓存5种基本数据类型的增删改查、在Spring Boot中如何集成Redis缓存以及如何使用Redis缓存用户数据等。\n第8章主要介绍Log4j基础知识、在Spring Boot中集成Log4j、Log4j在Spring Boot中的运用以及如何把日志打印到控制台和记录到日志文件中。\n第9章主要介绍在Spring Boot中使用XML配置和Java注解两种方式定义和使用Quartz定时器以及如何在Spring Boot中通过JavaMailSender接口给用户发送广告邮件等。\n第10章主要介绍如何在Spring Boot中集成MyBatis框架、通过MyBatis框架实现查询等功能以及如何使用MyBatisCodeHelper插件快速生成增删改查代码。\n第11章主要介绍ActiveMQ的安装与使用、Spring Boot集成ActiveMQ、利用ActiveMQ实现异步发表微信说说以及Spring Boot异步调用@Async等。\n第12章主要介绍Srping Boot全局异常使用、自定义错误页面、全局异常类开发、Retry重试机制等。\n第13章主要介绍如何安装和使用MongoDB数据库、NoSQL Manager for MongoDB客户端的安装与使用以及在Spring Boot中集成MongoDB数据库开发简单的功能等。\n第14章主要介绍Spring Security的基础知识、Spring Boot如何集成Spring Security、利用Spring Security实现授权登录以及利用Spring Boot实现数据库数据授权登录等。\n第15章主要介绍如何通过Spring Boot监控和管理应用、自定义监控端点以及自定义HealthIndicator等。\n第16章主要介绍如何安装并运行Zookeeper、Spring Boot集成Dubbo、myspring-boot项目的服务拆分和实践、正式版API如何发布、服务注册等。\n第17章主要介绍Spring Boot多环境配置及使用、Spring Boot如何打包成War包并部署到外部Tomcat服务器上等。\n第18章主要回顾MySpringApplication入口类的注解和run方法的原理，梳理Spring Boot启动执行的流程并简单分析spring-boot-starter起步依赖原理等。\n学习本书的预备知识\nJava基础\n读者需要掌握J2SE基础知识，这是最基本的也是最重要的。\nJava Web开发技术\n在项目实战中需要用到Java Web的相关技术，比如Spring、HTML、Tomcat、MyBatis等技术。\n数据库基础\n读者需要掌握主流数据库基本知识，比如MySQL等，掌握基本的SQL语法以及常用数据库的安装。\n本书使用的软件版本\n本书项目实战开发环境为Windows 10，开发工具使用IntelliJ IDEA 2016.2，JDK使用1.8版本，Tomcat使用1.8版本，Spring Boot使用2.0.0.RC1版本。\n读者对象\n本书适合所有Java编程语言开发人员、所有对Spring Boot感兴趣并希望使用Spring Boot开发框架进行开发的人员、缺少Spring Boot项目实战经验以及对Spring Boot内部原理感兴趣的开发人员学习。\n源代码和教学视频下载\nGitHub源代码下载地址：git@github.com:huangwenyi10/stepbystep-learn-springboot.git\n教学视频下载地址：https://pan.baidu.com/s/1A5xjEcvE5A2T6I5bmAmkYQ\n也可以扫描二维码下载。\n如果你在下载过程中遇到问题，可发送邮件至booksaga@126.com获得帮助，邮件标题为“一步一步学Spring Boot：微服务项目实战”。\n勘误与交流\n限于笔者水平和写作时间，书中出现疏漏之处在所难免，欢迎大家通过电子邮件等方式批评指正。\n笔者的邮箱：huangwenyi10@163.com\n笔者的博客：http://blog.csdn.net/huangwenyi1010\n致谢\n本书能够顺利出版，首先要感谢清华大学出版社王金柱编辑给笔者一次和大家分享技术、交流学习的机会，感谢王金柱编辑在本书出版过程中的辛勤付出。\n感谢厦门星耀蓝图科技有限公司，笔者的Spring Boot知识是在贵公司积累沉淀的，书中很多知识点和项目实战经验都来源于贵公司，感谢公司总经理杨小雄、主管林良昆、架构师高志强、同事陈明元和林腾亚对笔者的关心和帮助。\n感谢上海美团科技有限公司的同事，感谢公司主管王纪伟、导师叶永林、组长文慧、同事杨伟勤对笔者的栽培与帮助。\n感谢笔者的家人和何庆华学长，他们对笔者生活的照顾使得笔者没有后顾之忧，全身心投入本书的写作当中。\n最后，感谢你选择了本书，让我们开始Spring Boot的探险之旅吧！\n",
  "factionName": "一步一步学Spring Boot",
  "newest": 10,
  "comments": [],
  "source": [],
  "index": "2"
},{
  "_id": "8d9128c0-9e20-45e7-b728-24ff71358a63",
  "headerImage": "https://wk-gulimall.oss-cn-beijing.aliyuncs.com/ProgramBook/b98edcc7-8e40-4d91-b243-540621abe3d9.jpg",
  "updateTime": {
    "$date": "2023-01-23T17:01:02.371Z"
  },
  "author": "wizard",
  "des": "有三种方式安装 Node.js：一是通过安装包安装，二是通过源码编译安装，三是在 Linux 下可以通过 yum|apt-get 安装，在 Mac 下可以通过 Homebrew 安装。对于 Windows 和 Mac 用户，推荐使用安装包安装，Linux 用户推荐使用源码编译安装。",
  "factionName": "一起学 Node.js",
  "newest": 10,
  "comments": [],
  "source": [],
  "index": "4"
},{
  "_id": "49635379-fad1-44bc-8721-dc696df0b186",
  "headerImage": "https://wk-gulimall.oss-cn-beijing.aliyuncs.com/ProgramBook/bc5b794f-4d01-4748-b430-76ebce3766ad.jpg",
  "updateTime": {
    "$date": "2023-01-23T17:01:03.343Z"
  },
  "author": "腾讯研究院;",
  "des": "即使我们可以使机器屈服于人类，比如，可以在关键时刻关掉电源，然而作为一个物种，我们也应当感到极大的敬畏。 ——阿兰·图灵 人工智能再一次成为社会各界关注的焦点，这距人工智能这一概念首次提出来已经过去了六十年。在这期间，人工智能的发展经历了三起两落。2016年，以AlphaGo为标志，人类失守了围棋这一被视为最后智力堡垒的棋类游戏，人工智能开始逐步升温，成为政府、产业界、科研机构以及消费市场竞相追逐的对象。在各国人工智能战略和资本市场的推波助澜下，人工智能的企业、产品和服务层出不穷。第三次人工智能浪潮已经到来，这是更强大的计算能力、更先进的算法、大数据、物联网等诸多因素共同作用的结果。人们不仅继续探寻有望超越人类的“强人工智能”，而且在研发可以提高生产力和经济效益的各种人工智能应用（所谓的“弱人工智能”）上面，取得了极大的进步。 一方面，人工智能异常火热。另一方面，大众与专业人士之间、技术研发人员与社科研究人员之间，在对人工智能的认知上存在深深的裂痕。正是由于这一认知鸿沟的存在，很多时候，人们彼此之间谈论的人工智能其实并非同一概念。这常常导致无谓的争执和分歧，既无助于人工智能的发展，也不利于探讨人工智能带来的真正社会影响。 伊隆·马斯克和马克·扎克伯格关于人工智能威胁论的辩论，代表了两种典型的声音。一边是公众舆论对强人工智能和超人工智能可能失控、威胁人类生存的未来主义式的担忧和警告；另一边是产业界从功用和商业角度出发，对人工智能研发和应用的持续探索，在自动驾驶、图像识别、智能机器人等诸多领域取得了长足进步。与此同时，很多技术研发人员认为人工智能不可能超越人类，威胁论是杞人忧天。 回顾计算机技术发展的历史，就会发现计算机、机器人等人类手中的昔日工具，正在成为某种程度上具有一定自主性的能动体（Intelligent Agent），开始替代人类进行决策或者从事任务。而这些事情之前一直被认为只能存在于科幻文学中，现实中不可能由机器来完成，比如开车、翻译、文艺创作等。",
  "factionName": "人工智能",
  "newest": 10,
  "comments": [],
  "source": [],
  "index": "3"
},{
  "_id": "c55b6a3a-ae29-47c7-be68-26b5896ab40b",
  "headerImage": "https://wk-gulimall.oss-cn-beijing.aliyuncs.com/ProgramBook/be7b6d5b-4e11-48b5-ad66-cdd79bfec6fe.jpg",
  "updateTime": {
    "$date": "2023-01-23T17:01:04.112Z"
  },
  "author": "刘新浙, ",
  "des": "这是一本在研究大量C/C++程序Bug基础上集结而成的书！\n这是一本汇集众多一线C/C++编程人员智慧的书！\n这是一本让您学好C/C++，绕过编程陷阱和障碍的必备案头书！\n为什么写这样一本书\n▪在不同的项目或产品中，不同的开发人员重复着同样的Bug，甚至同一个人重复相同的Bug。如果将时间周期拉得更长一些看：一个程序员，从刚毕业参加工作到具备丰富编程经验，从一个新手到成为专家，在这个过程中，每个人都在重复着前人走过的弯路，重复着同样的编程错误。测试人员在日常工作中积累了大量验证Bug方面的经验，这些Bug是有价值的，总结出来可以让更多人受益。\n▪C/C++是软件/互联网行业最常用的编程语言之一，相对其他语言学习难度高，从新手到专家往往需要多年的磨练。另一方面，C/C++开发的系统往往更容易产生严重的生产事故，一旦出现事故，定位问题根源也比较困难。所以，每一个程序员掌握扎实的C/C++基础知识，对于构建稳定可靠的生产系统非常重要。我们希望通过这本书帮助C/C++程序员以最快速度全面了解C/C++编程中的陷阱，编写健壮可靠的代码，从而达到提高软件质量、减少生产故障、提高工作效率的目的。\n相对其他C/C++类书籍，本书有以下特点和优势：\n▪从具体Bug中学习\n全书由102个案例组成，每个案例分析一个Bug。读者掌握了一个案例就是掌握了一个知识点，就能避免一类问题。由于是从具体Bug案例中学习，这种学习方式更直接，更让人印象深刻。普通的C/C++编程书，即便看完后，写代码时也无法避免Bug，这是因为，书虽然看完了，知识也理解了，但你并不知道哪里有陷阱。\n▪来源于工程实战的宝贵经验\n本书中的所有案例都来自于软件/互联网行业开发生产中遇到的实际问题，都是在前人的错误和弯路中总结出来的实战经验，堪称C/C++编程方面的“干货”。\n▪学习起来更有成就感\n本书由一个个案例组成，在每个案例中，先给出错误代码示例，然后描述Bug的现象和后果，随后对该Bug进行具体分析，最后给出解决方案及建议。这种案例分析式的组织方式，会引导读者先对案例中提出的问题进行思考，当看到案例分析和解决方案时常常有恍然大悟的感觉，让学习过程变得简单，并充满乐趣。\n▪更宽的知识面\n一个C/C++程序员即使工作多年，由于受所接触项目和技术方向的限制，视野（C/C++编程中值得注意的知识点）往往是有限的。这本书中的案例收集于大量工程项目，几乎涵盖了C/C++编程中的方方面面，远超出一般程序员所能接触的范围。掌握了这本书中的内容，能避免大多数问题。\n本书适用范围\n▪本书适合已经写过一些C/C++代码、期望尽快积累实战经验的C/C++程序员阅读学习。本书也适合打算提高代码编写和代码阅读分析能力的软件测试人员，书中的每个案例都可应用于白盒测试中。\n本书代码运行环境\n▪本书中的所有案例代码都是针对Linux C/C++环境，在Redhat Linux环境下编译（GCC，G++）测试通过。代码可以通过人民邮电出版社网站（www.ptpress.com.cn）下载。\n最后，由于本书作者在C/C++编程方面的经验和技能有限，书中可能会有一些描述不够清晰或不正确的地方，读者如有发现请及时告诉我们，我们会再进行修正。我们的联系邮箱是cppbugbook@gmail.com，编辑联系邮箱是zhangtao@ptpress.com.cn。在此表示感谢！\n期望这本书能真真切切地帮助到他人。\n编者\n",
  "factionName": "从缺陷中学习C/C++",
  "newest": 10,
  "comments": [],
  "source": [],
  "index": "1"
}]